```
Universidad del Quindío
Programa de Ingeniería de Sistemas y Computación
Programación III - Manejo de archivos
Docente: Carlos Andrés Florez V.
```

# Manejo de archivos

Elixir proporciona varias herramientas para trabajar con archivos, principalmente a través de los módulos `File`, `IO` y `Path`. Estas herramientas permiten leer, escribir, y manipular archivos y directorios de una manera funcional y segura. En esta guía, exploraremos las funciones más comunes y cómo utilizarlas eficazmente.

## Filosofía de manejo de archivos en Elixir

En Elixir, el manejo de archivos sigue principios funcionales:

1. **Inmutabilidad**: Los datos leídos son inmutables
2. **Tuplas de resultado**: Las operaciones retornan `{:ok, resultado}` o `{:error, razón}`
3. **Funciones con `!`**: Lanzan excepciones en lugar de retornar tuplas de error
4. **Streams**: Procesamiento eficiente de archivos grandes sin cargarlos en memoria
5. **Pattern matching**: Manejo elegante de resultados

---

## Módulo `File`

El módulo `File` contiene funciones para interactuar con el sistema de archivos. Las funciones más comunes del módulo `File` las podemos clasificar en varias categorías:

### Lectura de archivos

- `read/1`: Lee todo el contenido de un archivo y lo devuelve como binario
- `read!/1`: Versión que lanza excepciones
- `stream!/1` o `stream!/3`: Crea un stream para lectura línea por línea

### Escritura de archivos

- `write/2`: Escribe datos en un archivo (sobrescribe)
- `write!/2`: Versión que lanza excepciones
- `write/3`: Con opciones (ej: `[:append]` para agregar)

### Operaciones de archivos

- `open/2`: Abre un archivo con un modo específico (`:read`, `:write`, `:append`, etc.)
- `close/1`: Cierra un archivo abierto
- `exists?/1`: Verifica si un archivo existe
- `rm/1`: Elimina un archivo
- `rm_rf/1`: Elimina un archivo o directorio recursivamente
- `cp/2`: Copia un archivo
- `rename/2`: Renombra o mueve un archivo
- `mkdir/1`: Crea un directorio
- `mkdir_p/1`: Crea un directorio y todos sus padres si no existen

### Información de archivos

- `stat/1`: Obtiene información detallada del archivo (tamaño, fechas, permisos)
- `ls/1`: Lista los archivos en un directorio
- `dir?/1`: Verifica si una ruta es un directorio

---

## Módulo `Path`

El módulo `Path` ofrece utilidades para trabajar con rutas de archivos de forma **independiente del sistema operativo**. Dentro de las funciones más útiles del módulo `Path` se encuentran:

- `join/1` o `join/2`: Une partes de una ruta de forma segura
- `expand/1` o `expand/2`: Convierte una ruta relativa en absoluta
- `dirname/1`: Devuelve el directorio que contiene el archivo
- `basename/1` o `basename/2`: Devuelve el nombre del archivo
- `extname/1`: Obtiene la extensión del archivo
- `rootname/1`: Obtiene el nombre sin extensión
- `absname/1`: Convierte a ruta absoluta
- `relative_to/2`: Calcula la ruta relativa entre dos rutas
- `split/1`: Divide una ruta en sus componentes

### Ejemplos

```elixir
# Unir rutas de forma segura (usa / o \ según el SO)
Path.join(["carpeta", "subcarpeta", "archivo.txt"])
# => "carpeta/subcarpeta/archivo.txt" (en Unix)
# => "carpeta\\subcarpeta\\archivo.txt" (en Windows)

# Expandir ruta relativa
Path.expand("../datos/archivo.csv")
# => "/home/usuario/proyecto/datos/archivo.csv"

# Extraer componentes
ruta = "/home/usuario/documentos/reporte.pdf"
Path.dirname(ruta)   # => "/home/usuario/documentos"
Path.basename(ruta)  # => "reporte.pdf"
Path.extname(ruta)   # => ".pdf"
Path.rootname(ruta)  # => "/home/usuario/documentos/reporte"

# Dividir ruta
Path.split("/home/usuario/archivo.txt")
# => ["/", "home", "usuario", "archivo.txt"]
```

---

## Leer archivos y Pattern Matching

La forma más sencilla de leer un archivo es usando `File.read/1`. Esta función, como muchas otras en Elixir, sigue la convención de devolver una tupla para indicar el éxito o el fracaso de la operación.

- Si la lectura es **exitosa**, devuelve `{:ok, contenido}`, donde `contenido` es un binario con los datos del archivo.
- Si ocurre un **error** (por ejemplo, el archivo no existe), devuelve `{:error, razón}`, donde `razón` es un átomo que describe el error.

### Códigos de error comunes

- `:enoent`: El archivo no existe (No such file or directory)
- `:eacces`: Permiso denegado
- `:eisdir`: Es un directorio, no un archivo
- `:enotdir`: Se esperaba un directorio, pero no lo es
- `:enomem`: Memoria insuficiente

### Ejemplo básico

```elixir
defmodule Lector do
  def leer_archivo(ruta) do
    case File.read(ruta) do
      {:ok, contenido} ->
        IO.puts("Contenido del archivo:")
        IO.puts(contenido)
      {:error, :enoent} ->
        IO.puts("Error: El archivo no existe")
      {:error, :eacces} ->
        IO.puts("Error: Sin permisos para leer el archivo")
      {:error, razon} ->
        IO.puts("Error al leer el archivo: #{razon}")
    end
  end
end

Lector.leer_archivo("mi_archivo.txt")
```

---

## Escribir archivos

Para escribir en un archivo, se puede usar `File.write/2` o `File.write/3`. 

### Escritura simple (sobrescribe)

La forma más sencilla de escribir en un archivo es usando `File.write/2`, que sobrescribe el contenido existente:

```elixir
defmodule Escritor do
  def escribir_archivo(ruta, contenido) do
    case File.write(ruta, contenido) do
      :ok ->
        IO.puts("Archivo escrito exitosamente")
      {:error, razon} ->
        IO.puts("Error al escribir el archivo: #{razon}")
    end
  end
end

Escritor.escribir_archivo("nuevo_archivo.txt", "Este es el contenido.")
```

### Escritura con opciones (append, permisos)

Puede especificar opciones adicionales al escribir:

```elixir
# Agregar al final sin sobrescribir
File.write("log.txt", "Nueva entrada\n", [:append])

# Múltiples opciones
File.write("config.txt", "datos", [:append, :utf8])

# Crear directorio si no existe antes de escribir
def escribir_seguro(ruta, contenido) do
  directorio = Path.dirname(ruta)
  File.mkdir_p(directorio)
  File.write(ruta, contenido)
end
```

---

## Módulo `IO` para archivos abiertos

El módulo `IO` se utiliza para operaciones de entrada/salida en archivos abiertos. Permite leer y escribir datos de manera más controlada.

Aquí hay un ejemplo básico de cómo abrir un archivo, escribir en él y luego leer desde él usando `IO`:

```elixir
# Abrir, escribir líneas y cerrar manualmente
{:ok, file} = File.open("datos.txt", [:write])
IO.puts(file, "Línea 1") # Escribir línea 1
IO.puts(file, "Línea 2") # Escribir línea 2
File.close(file) # Cerrar archivo después de escribir

# Leer desde archivo abierto
{:ok, file} = File.open("datos.txt", [:read])
linea1 = IO.read(file, :line) # Leer primera línea
linea2 = IO.read(file, :line) # Leer segunda línea
File.close(file) # Cerrar archivo después de leer

# Imprimir las líneas leídas
IO.puts("Primera línea: #{linea1}")
IO.puts("Segunda línea: #{linea2}")
```

### Funciones principales de `IO`

Las funciones más comunes del módulo `IO` para trabajar con archivos son:

- `read/2`: Lee del archivo (`:line`, `:all`, o número de bytes)
- `write/2`: Escribe en el archivo
- `puts/2`: Escribe con salto de línea
- `gets/2`: Lee una línea (similar a `read(file, :line)`)

A diferencia de `File.write/2` o `File.read/1`, las funciones de `IO` requieren que el archivo esté abierto previamente con `File.open/2`, lo que permite un control más fino sobre la lectura y escritura, especialmente útil para archivos grandes o cuando se necesita mantener el archivo abierto durante varias operaciones.

---

## Procesar archivos grandes con Streams

Cuando se trabaja con archivos muy grandes, no es eficiente cargarlos completamente en memoria. En su lugar, se puede usar `File.stream!/1` para crear un **stream**. Un stream es una **colección "perezosa" (lazy)**, lo que significa que el archivo se lee pieza por pieza (generalmente línea por línea) solo cuando se necesita.

> ⚠️ **Importante**: Recuerde que en elixir, se usa la convención de `!` para funciones que lanzan excepciones en caso de error. Debe manejar adecuadamente los errores al usar estas funciones.

### ¿Cómo funciona un Stream?

Un stream es como una “receta” para generar una secuencia de datos, no los datos en sí. Cuando se pasa un stream a una función del módulo `Enum` (como `Enum.count`, `Enum.map`, etc.), ocurre lo siguiente:

1. `Enum` pide el **primer elemento** al stream (la primera línea del archivo).
2. Stream lee **solo esa línea** del archivo y se la entrega a `Enum`.
3. `Enum` procesa ese elemento aplicando alguna función (por ejemplo `Enum.count/1`, `Enum.map/2`, `Enum.to_list/1`, etc.).
4. `Enum` pide el **segundo elemento** al stream.
5. Stream lee la **segunda línea** y la entrega a `Enum`.
6. Se repite hasta que el stream se agota (llega al final del archivo).

De esta manera, en ningún momento se carga el archivo completo en memoria. `Enum` "tira" de los datos del stream uno por uno, haciéndolo increíblemente eficiente para archivos de cualquier tamaño.

### Ejemplos de uso de Streams

A continuación, algunos ejemplos prácticos de cómo usar streams para procesar archivos grandes.

#### Contar líneas

En este ejemplo, contamos el número de líneas en un archivo grande sin cargar todo el archivo en memoria:

```elixir
defmodule ContadorLineas do
  def contar(ruta) do
    ruta
    |> File.stream!()
    |> Enum.count()
  end
end

numero_lineas = ContadorLineas.contar("archivo_grande.txt")
IO.puts("El archivo tiene #{numero_lineas} líneas")
```

#### Procesar y transformar líneas

En este ejemplo, se procesa un archivo por medio de un stream, y se aplica alguna función de transformación, filtrado o mapeo:

```elixir
defmodule ProcesadorArchivo do
  def mayusculas(ruta_entrada, ruta_salida) do
    File.stream!(ruta_entrada)
    |> Stream.map(&String.upcase/1) # Convierte cada línea a mayúsculas
    |> Enum.into(File.stream!(ruta_salida, [:write])) # Escribe en nuevo archivo cada línea transformada
  end

  def filtrar_lineas_largas(ruta, min_longitud) do
    File.stream!(ruta)
    |> Stream.filter(fn linea -> String.length(linea) > min_longitud end) # Filtra líneas largas
    |> Enum.to_list() # Convierte a lista (o puede procesar de otra forma)
  end

  def primeras_n_lineas(ruta, n) do
    File.stream!(ruta)
    |> Enum.take(n) # Toma las primeras n líneas
  end
end
```

#### Procesamiento por lotes (chunks)

Es posible procesar archivos en bloques o "chunks" para operaciones más complejas:

```elixir
# Procesar archivo en grupos de 100 líneas
File.stream!("grande.txt")
|> Stream.chunk_every(100)
|> Enum.each(fn lote ->
  # Procesar lote de 100 líneas
  IO.puts("Procesando lote de #{length(lote)} líneas")
end)
```

---

## Manejo de rutas de forma segura

Cuando se trabaja con archivos, es crucial manejar las rutas de manera segura y flexible para evitar problemas al mover el proyecto entre diferentes entornos o sistemas operativos.

### Problema: rutas hardcodeadas

```elixir
# Malo: hardcoded, solo funciona en un directorio específico
File.read("/home/usuario/proyecto/datos.txt")

# Malo: asume directorio actual
File.read("datos.txt")
```

### Solución: rutas relativas al script

```elixir
# Bueno: relativo al archivo actual
defmodule MiModulo do
  @datos_dir Path.join([__DIR__, "datos"])
  
  def leer_configuracion do
    ruta = Path.join(@datos_dir, "config.txt")
    File.read(ruta)
  end
end
```

### Variables especiales

- `__DIR__`: Directorio del archivo actual
- `__ENV__.file`: Ruta completa del archivo actual

```elixir
IO.puts("Este archivo está en: #{__DIR__}")
IO.puts("Ruta completa: #{__ENV__.file}")
```

---

## Ejercicios

### Ejercicio 1: Frecuencia de palabras

Cree un programa que:
1. Lea un archivo de texto
2. Cuente la frecuencia de cada palabra (ignorando mayúsculas y signos de puntuación)
3. Guarde los resultados en `frecuencia.txt` ordenados de mayor a menor frecuencia
4. El formato debe ser: `palabra: frecuencia`

**Ejemplo de entrada (`texto.txt`):**
```
Hola mundo. Hola Elixir!
Elixir es genial. Mundo, hola.
```

**Ejemplo de salida (`frecuencia.txt`):**
```
hola: 3
elixir: 2
mundo: 2
es: 1
genial: 1
```

**Pistas:**
- Use `String.downcase/1` para normalizar
- Use `String.replace/3` para eliminar puntuación
- Use `String.split/1` para separar palabras
- Use `Enum.frequencies/1` para contar

### Ejercicio 2: Procesamiento de datos de un CSV

Dado el archivo `productos.csv`:

```csv
nombre,precio,cantidad
Laptop,1200,10
Mouse,25,50
Teclado,75,30
Monitor,300,15
```

Cree un módulo que:
1. Lea el archivo `productos.csv`
2. Convierta cada línea en un mapa: `%{nombre: "Laptop", precio: 1200, cantidad: 10}`
3. Calcule el valor total del inventario (suma de `precio * cantidad`)
4. Encuentre el producto más caro y el más barato
5. Genere un reporte en `reporte.txt` con:
   - Valor total del inventario
   - Producto más caro
   - Producto más barato
   - Lista de productos ordenados por valor en inventario

**Pistas:**
- Use `File.stream!/1` y `Enum.drop(1)` para saltar el encabezado
- Use `String.split/2` y `String.to_integer/1`
- Use `Enum.reduce/3` para calcular totales
- Use `Enum.max_by/2` y `Enum.min_by/2`

### Ejercicio 3: Informe de directorio

Desarrolle un script que:
1. Reciba una ruta a un directorio
2. Liste todos los archivos y subdirectorios
3. Genere `informe.txt` con:
   - Nombre del archivo/directorio
   - Tamaño en bytes (solo para archivos)
   - Tipo (archivo/directorio)

**Formato esperado:**
```
=== Informe del Directorio ./datos ===
Generado: 2025-01-15 10:30:45

[DIR]  subcarpeta/           
[FILE] config.txt      (245 bytes)  
[FILE] datos.csv      (1024 bytes)  

Total: 2 archivos, 1 directorio
Tamaño total: 1269 bytes
```

**Pistas:**
- Use `File.ls!/1` para listar
- Use `File.stat!/1` para obtener información
- Use `File.dir?/1` para distinguir directorios

### Ejercicio 4: Proyecto del Gimnasio con persistencia

Extienda el proyecto del gimnasio que hemos desarrollado en capítulos anteriores para que haga lo siguiente:

1. Guardar todos los socios en `socios.txt`
2. Formato: `cedula;nombre;edad;clase1,clase2,clase3`
3. Cargar datos al iniciar el programa
4. Guardar automáticamente después de cada operación

**Ejemplo de `socios.txt`:**
```
123;Juan Pérez;30;Yoga,Pilates,Spinning
456;Ana García;25;CrossFit,Yoga
789;Carlos López;35;Spinning,Natación,Yoga
```

**Funciones requeridas:**
- `Gimnasio.cargar_datos/0`
- `Gimnasio.guardar_datos/0`

---

## Para la próxima clase

Se proponen los siguientes temas para investigación:

- Qué es un proceso y un hilo (thread) en el contexto de la programación concurrente.
- A qué se refiere el modelo de actor en Elixir y Erlang.
- Cómo Elixir maneja la concurrencia utilizando procesos ligeros.