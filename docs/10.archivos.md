```
Universidad del Quindío
Programa de Ingeniería de Sistemas y Computación
Programación III - Manejo de archivos
Docente: Carlos Andrés Florez V.
```

# Manejo de archivos

Elixir proporciona varias herramientas para trabajar con archivos, principalmente a través de los módulos `File`, `IO` y `Path`. Estas herramientas permiten leer, escribir y manipular archivos y directorios de una manera funcional y segura. En esta guía, exploraremos las funciones más comunes y cómo utilizarlas eficazmente.

## Filosofía de manejo de archivos en Elixir

En Elixir, el manejo de archivos sigue principios funcionales:

1. **Inmutabilidad**: Los datos leídos son inmutables
2. **Tuplas de resultado**: Las operaciones retornan `{:ok, resultado}` o `{:error, razón}`
3. **Funciones con `!`**: Lanzan excepciones en lugar de retornar tuplas de error
4. **Streams**: Procesamiento eficiente de archivos grandes sin cargarlos en memoria
5. **Pattern matching**: Manejo elegante de resultados

---

## Módulo `File`

El módulo `File` contiene funciones para interactuar con el sistema de archivos.

### Funciones principales

#### Lectura de archivos

- **`File.read/1`**: Lee todo el contenido de un archivo y lo devuelve como binario
- **`File.read!/1`**: Versión que lanza excepciones
- **`File.stream!/1`** o **`File.stream!/3`**: Crea un stream para lectura línea por línea

#### Escritura de archivos

- **`File.write/2`**: Escribe datos en un archivo (sobrescribe)
- **`File.write!/2`**: Versión que lanza excepciones
- **`File.write/3`**: Con opciones (ej: `[:append]` para agregar)

#### Operaciones de archivos

- **`File.open/2`**: Abre un archivo con un modo específico (`:read`, `:write`, `:append`, etc.)
- **`File.close/1`**: Cierra un archivo abierto
- **`File.exists?/1`**: Verifica si un archivo existe
- **`File.rm/1`**: Elimina un archivo
- **`File.rm_rf/1`**: Elimina un archivo o directorio recursivamente
- **`File.cp/2`**: Copia un archivo
- **`File.rename/2`**: Renombra o mueve un archivo
- **`File.mkdir/1`**: Crea un directorio
- **`File.mkdir_p/1`**: Crea un directorio y todos sus padres si no existen

#### Información de archivos

- **`File.stat/1`**: Obtiene información detallada del archivo (tamaño, fechas, permisos)
- **`File.ls/1`**: Lista los archivos en un directorio
- **`File.dir?/1`**: Verifica si una ruta es un directorio
- **`File.regular?/1`**: Verifica si es un archivo regular

---

## Módulo `Path`

El módulo `Path` ofrece utilidades para trabajar con rutas de archivos de forma **independiente del sistema operativo**.

### Funciones principales

- **`Path.join/1`** o **`Path.join/2`**: Une partes de una ruta de forma segura
- **`Path.expand/1`** o **`Path.expand/2`**: Convierte una ruta relativa en absoluta
- **`Path.dirname/1`**: Devuelve el directorio que contiene el archivo
- **`Path.basename/1`** o **`Path.basename/2`**: Devuelve el nombre del archivo
- **`Path.extname/1`**: Obtiene la extensión del archivo
- **`Path.rootname/1`**: Obtiene el nombre sin extensión
- **`Path.absname/1`**: Convierte a ruta absoluta
- **`Path.relative_to/2`**: Calcula la ruta relativa entre dos rutas
- **`Path.split/1`**: Divide una ruta en sus componentes

### Ejemplos

```elixir
# Unir rutas de forma segura (usa / o \ según el SO)
Path.join(["carpeta", "subcarpeta", "archivo.txt"])
# => "carpeta/subcarpeta/archivo.txt" (en Unix)
# => "carpeta\\subcarpeta\\archivo.txt" (en Windows)

# Expandir ruta relativa
Path.expand("../datos/archivo.csv")
# => "/home/usuario/proyecto/datos/archivo.csv"

# Extraer componentes
ruta = "/home/usuario/documentos/reporte.pdf"
Path.dirname(ruta)   # => "/home/usuario/documentos"
Path.basename(ruta)  # => "reporte.pdf"
Path.extname(ruta)   # => ".pdf"
Path.rootname(ruta)  # => "/home/usuario/documentos/reporte"

# Dividir ruta
Path.split("/home/usuario/archivo.txt")
# => ["/", "home", "usuario", "archivo.txt"]
```

---

## Leer archivos y Pattern Matching

La forma más sencilla de leer un archivo es usando `File.read/1`. Esta función, como muchas otras en Elixir, sigue la convención de devolver una tupla para indicar el éxito o el fracaso de la operación.

- Si la lectura es **exitosa**, devuelve `{:ok, contenido}`, donde `contenido` es un binario con los datos del archivo.
- Si ocurre un **error** (por ejemplo, el archivo no existe), devuelve `{:error, razón}`, donde `razón` es un átomo que describe el error.

### Códigos de error comunes

- `:enoent`: El archivo no existe (No such file or directory)
- `:eacces`: Permiso denegado
- `:eisdir`: Es un directorio, no un archivo
- `:enotdir`: Se esperaba un directorio, pero no lo es
- `:enomem`: Memoria insuficiente

### Ejemplo básico

```elixir
defmodule Lector do
  def leer_archivo(ruta) do
    case File.read(ruta) do
      {:ok, contenido} ->
        IO.puts("Contenido del archivo:")
        IO.puts(contenido)
      {:error, :enoent} ->
        IO.puts("Error: El archivo no existe")
      {:error, :eacces} ->
        IO.puts("Error: Sin permisos para leer el archivo")
      {:error, razon} ->
        IO.puts("Error al leer el archivo: #{razon}")
    end
  end
end

Lector.leer_archivo("mi_archivo.txt")
```

---

## Escribir archivos

Para escribir en un archivo, se puede usar `File.write/2` o `File.write/3`. 

### Escritura simple (sobrescribe)

La forma más sencilla de escribir en un archivo es usando `File.write/2`, que sobrescribe el contenido existente:

```elixir
defmodule Escritor do
  def escribir_archivo(ruta, contenido) do
    case File.write(ruta, contenido) do
      :ok ->
        IO.puts("Archivo escrito exitosamente")
      {:error, razon} ->
        IO.puts("Error al escribir el archivo: #{razon}")
    end
  end
end

Escritor.escribir_archivo("nuevo_archivo.txt", "Este es el contenido.")
```

### Escritura con opciones (append, permisos)

Puede especificar opciones adicionales al escribir:

```elixir
# Agregar al final sin sobrescribir
File.write("log.txt", "Nueva entrada\n", [:append])

# Múltiples opciones
File.write("config.txt", "datos", [:append, :utf8])

# Crear directorio si no existe antes de escribir
def escribir_seguro(ruta, contenido) do
  directorio = Path.dirname(ruta)
  File.mkdir_p(directorio)
  File.write(ruta, contenido)
end
```

---

## Módulo `IO` para archivos abiertos

El módulo `IO` se usa para leer/escribir en archivos ya abiertos con `File.open/2`:

```elixir
# Abrir, escribir líneas y cerrar manualmente
{:ok, file} = File.open("datos.txt", [:write])
IO.puts(file, "Línea 1")
IO.puts(file, "Línea 2")
File.close(file)

# Leer desde archivo abierto
{:ok, file} = File.open("datos.txt", [:read])
linea1 = IO.read(file, :line)
linea2 = IO.read(file, :line)
File.close(file)

IO.puts("Primera línea: #{linea1}")
IO.puts("Segunda línea: #{linea2}")
```

### Funciones principales de `IO`

- **`IO.read/2`**: Lee del archivo (`:line`, `:all`, o número de bytes)
- **`IO.write/2`**: Escribe en el archivo
- **`IO.puts/2`**: Escribe con salto de línea
- **`IO.gets/2`**: Lee una línea (similar a `IO.read(file, :line)`)
- **`IO.binread/2`**: Lee en modo binario
- **`IO.binwrite/2`**: Escribe en modo binario

---

## Procesar archivos grandes con Streams

Cuando se trabaja con archivos muy grandes, no es eficiente cargarlos completamente en memoria. En su lugar, se puede usar `File.stream!/1` para crear un **stream**. Un stream es una **colección "perezosa" (lazy)**, lo que significa que el archivo se lee pieza por pieza (generalmente línea por línea) solo cuando se necesita.

> ⚠️ **Importante**: Recuerde que en elixir, se usa la convención de `!` para funciones que lanzan excepciones en caso de error. Debe manejar adecuadamente los errores al usar estas funciones.

### ¿Cómo funciona un Stream?

Un stream es como una “receta” para generar una secuencia de datos, no los datos en sí. Cuando se pasa un stream a una función del módulo `Enum` (como `Enum.count`, `Enum.map`, etc.), ocurre lo siguiente:

1. `Enum` pide el **primer elemento** al stream (la primera línea del archivo).
2. Stream lee **solo esa línea** del archivo y se la entrega a `Enum`.
3. `Enum` procesa ese elemento aplicando alguna función (por ejemplo `Enum.count/1`, `Enum.map/2`, `Enum.to_list/1`, etc.).
4. `Enum` pide el **segundo elemento** al stream.
5. Stream lee la **segunda línea** y la entrega a `Enum`.
6. Se repite hasta que el stream se agota (llega al final del archivo).

De esta manera, en ningún momento se carga el archivo completo en memoria. `Enum` "tira" de los datos del stream uno por uno, haciéndolo increíblemente eficiente para archivos de cualquier tamaño.

### Ejemplos de uso de Streams

A continuación, algunos ejemplos prácticos de cómo usar streams para procesar archivos grandes.

#### Contar líneas

En este ejemplo, contamos el número de líneas en un archivo grande sin cargar todo el archivo en memoria:

```elixir
defmodule ContadorLineas do
  def contar(ruta) do
    ruta
    |> File.stream!()
    |> Enum.count()
  end
end

numero_lineas = ContadorLineas.contar("archivo_grande.txt")
IO.puts("El archivo tiene #{numero_lineas} líneas")
```

#### Procesar y transformar líneas

En este ejemplo, se procesa un archivo por medio de un stream, y se aplica alguna función de transformación, filtrado o mapeo:

```elixir
defmodule ProcesadorArchivo do
  def mayusculas(ruta_entrada, ruta_salida) do
    File.stream!(ruta_entrada)
    |> Stream.map(&String.upcase/1) # Convierte cada línea a mayúsculas
    |> Enum.into(File.stream!(ruta_salida, [:write])) # Escribe en nuevo archivo cada línea transformada
  end

  def filtrar_lineas_largas(ruta, min_longitud) do
    File.stream!(ruta)
    |> Stream.filter(fn linea -> String.length(linea) > min_longitud end) # Filtra líneas largas
    |> Enum.to_list() # Convierte a lista (o puede procesar de otra forma)
  end

  def primeras_n_lineas(ruta, n) do
    File.stream!(ruta)
    |> Enum.take(n) # Toma las primeras n líneas
  end
end
```

#### Procesamiento por lotes (chunks)

Es posible procesar archivos en bloques o "chunks" para operaciones más complejas:

```elixir
# Procesar archivo en grupos de 100 líneas
File.stream!("grande.txt")
|> Stream.chunk_every(100)
|> Enum.each(fn lote ->
  # Procesar lote de 100 líneas
  IO.puts("Procesando lote de #{length(lote)} líneas")
end)
```

---

## Manejo de rutas de forma segura

Cuando se trabaja con archivos, es crucial manejar las rutas de manera segura y flexible para evitar problemas al mover el proyecto entre diferentes entornos o sistemas operativos.

### Problema: rutas hardcodeadas

```elixir
# Malo: hardcoded, solo funciona en un directorio específico
File.read("/home/usuario/proyecto/datos.txt")

# Malo: asume directorio actual
File.read("datos.txt")
```

### Solución: rutas relativas al script

```elixir
# ✓ Bueno: relativo al archivo actual
defmodule MiModulo do
  @datos_dir Path.join([__DIR__, "datos"])
  
  def leer_configuracion do
    ruta = Path.join(@datos_dir, "config.txt")
    File.read(ruta)
  end
end
```

### Variables especiales

- `__DIR__`: Directorio del archivo actual
- `__ENV__.file`: Ruta completa del archivo actual

```elixir
IO.puts("Este archivo está en: #{__DIR__}")
IO.puts("Ruta completa: #{__ENV__.file}")
```

---

## Buenas prácticas

Es importante seguir ciertas buenas prácticas al trabajar con archivos en Elixir para asegurar un código limpio, eficiente y seguro.

### 1. Siempre cerrar archivos abiertos

Si un archivo no se cierra correctamente, puede causar fugas de recursos. Use `File.write/2` o `File.stream!/1` cuando sea posible.

```elixir
# Malo: puede dejar el archivo abierto si hay error
{:ok, file} = File.open("datos.txt", [:write])
IO.puts(file, "datos")
File.close(file)

# Bueno: usa File.write que cierra automáticamente
File.write("datos.txt", "datos")

# Bueno: usar streams para lectura
File.stream!("datos.txt") |> Enum.count()
```

### 2. Usar streams para archivos grandes

Como se explicó antes, use `File.stream!/1` para procesar archivos grandes sin cargarlos completamente en memoria.

```elixir
# Malo: carga todo en memoria
{:ok, contenido} = File.read("archivo_grande.csv")
lineas = String.split(contenido, "\n")

# Bueno: procesa línea por línea
File.stream!("archivo_grande.csv")
|> Enum.count()
```

### 3. Manejar errores apropiadamente

Igualmente importante es manejar los posibles errores al leer o escribir archivos.

```elixir
# Malo: ignora errores
File.write("datos.txt", contenido)

# Bueno: maneja resultados
case File.write("datos.txt", contenido) do
  :ok -> :ok
  {:error, razon} -> Logger.error("Fallo al escribir: #{razon}")
end
```

### 4. Usar Path para rutas multiplataforma

Evite concatenar rutas manualmente; use `Path.join/1` o `Path.join/2` para asegurar compatibilidad entre sistemas operativos.

```elixir
# Malo: solo funciona en Unix
ruta = "carpeta/subcarpeta/archivo.txt"

# Bueno: funciona en todos los SO
ruta = Path.join(["carpeta", "subcarpeta", "archivo.txt"])
```

### 5. Validar rutas antes de operar

Siempre valide que la ruta existe y es del tipo esperado (archivo o directorio) antes de operar.

```elixir
def procesar_archivo(ruta) do
  cond do
    not File.exists?(ruta) ->
      {:error, :no_existe}
    File.dir?(ruta) ->
      {:error, :es_directorio}
    true ->
      File.read(ruta)
  end
end
```

---

## Ejercicios

### Ejercicio 1: Frecuencia de palabras

Cree un programa que:
1. Lea un archivo de texto
2. Cuente la frecuencia de cada palabra (ignorando mayúsculas y signos de puntuación)
3. Guarde los resultados en `frecuencia.txt` ordenados de mayor a menor frecuencia
4. El formato debe ser: `palabra: frecuencia`

**Ejemplo de entrada (`texto.txt`):**
```
Hola mundo. Hola Elixir!
Elixir es genial. Mundo, hola.
```

**Ejemplo de salida (`frecuencia.txt`):**
```
hola: 3
elixir: 2
mundo: 2
es: 1
genial: 1
```

**Pistas:**
- Use `String.downcase/1` para normalizar
- Use `String.replace/3` para eliminar puntuación
- Use `String.split/1` para separar palabras
- Use `Enum.frequencies/1` para contar

### Ejercicio 2: Procesamiento de datos de un CSV

Dado el archivo `productos.csv`:

```csv
nombre,precio,cantidad
Laptop,1200,10
Mouse,25,50
Teclado,75,30
Monitor,300,15
```

Cree un módulo que:
1. Lea el archivo `productos.csv`
2. Convierta cada línea en un mapa: `%{nombre: "Laptop", precio: 1200, cantidad: 10}`
3. Calcule el valor total del inventario (suma de `precio * cantidad`)
4. Encuentre el producto más caro y el más barato
5. Genere un reporte en `reporte.txt` con:
   - Valor total del inventario
   - Producto más caro
   - Producto más barato
   - Lista de productos ordenados por valor en inventario

**Pistas:**
- Use `File.stream!/1` y `Enum.drop(1)` para saltar el encabezado
- Use `String.split/2` y `String.to_integer/1`
- Use `Enum.reduce/3` para calcular totales
- Use `Enum.max_by/2` y `Enum.min_by/2`

### Ejercicio 3: Informe de directorio

Desarrolle un script que:
1. Reciba una ruta a un directorio
2. Liste todos los archivos y subdirectorios
3. Genere `informe.txt` con:
   - Nombre del archivo/directorio
   - Tamaño en bytes (solo para archivos)
   - Tipo (archivo/directorio)

**Formato esperado:**
```
=== Informe del Directorio ./datos ===
Generado: 2025-01-15 10:30:45

[DIR]  subcarpeta/           
[FILE] config.txt      (245 bytes)  
[FILE] datos.csv      (1024 bytes)  

Total: 2 archivos, 1 directorio
Tamaño total: 1269 bytes
```

**Pistas:**
- Use `File.ls!/1` para listar
- Use `File.stat!/1` para obtener información
- Use `File.dir?/1` para distinguir directorios

### Ejercicio 4: Análisis de ventas desde CSV

Una empresa desea analizar su historial de ventas a partir de un archivo CSV que contiene miles de registros.

El equipo de análisis solicita un informe automatizado que identifique a los 10 clientes que más dinero han generado, junto con estadísticas relevantes.

El archivo CSV tiene el siguiente formato:

```csv
cliente_id,producto,cantidad,precio
12,Mouse Gamer,2,49.9
7,Teclado Mecánico,1,89.5
12,Monitor 27",1,219.0
...
```

Cada línea representa una venta individual. Los campos significan:

- **cliente_id**: identificador del cliente (entero)
- **producto**: nombre del producto vendido (cadena)
- **cantidad**: unidades compradas (entero > 0)
- **precio**: precio unitario (float > 0)
  
El sistema debe procesar archivos potencialmente muy grandes, por lo que se debe usar procesamiento perezoso con Streams siempre que sea posible.

Se solicita modificar el módulo `AnalizadorVentas` hecho en la clase anterior para que cumpla con todos los requisitos pero leyendo los datos desde un archivo CSV llamado `ventas.csv` con el formato descrito.

### Ejercicio 5: Proyecto del Gimnasio con persistencia

Extienda el proyecto del gimnasio para:
1. Guardar todos los socios en `socios.txt`
2. Formato: `cedula;nombre;edad;clase1,clase2,clase3`
3. Cargar datos al iniciar el programa
4. Guardar automáticamente después de cada operación

**Ejemplo de `socios.txt`:**
```
123;Juan Pérez;30;Yoga,Pilates,Spinning
456;Ana García;25;CrossFit,Yoga
789;Carlos López;35;Spinning,Natación,Yoga
```

**Funciones requeridas:**
- `Gimnasio.cargar_datos/0`
- `Gimnasio.guardar_datos/0`

---

## Para la próxima clase

1. **Investigar sobre procesos en Elixir**:
   - ¿Qué es un proceso en Elixir?
   - Diferencia entre procesos de Elixir y procesos del SO
   - Funciones `spawn/1`, `send/2` y `receive`

2. **Concurrencia básica**:
   - ¿Qué es concurrencia vs paralelismo?
   - Modelo de actores
   - Comunicación entre procesos mediante mensajes

3. **Preparación**:
   - Instalar Elixir si no lo tienen
   - Familiarizarse con la terminal/consola
   - Leer sobre `iex` (Interactive Elixir)