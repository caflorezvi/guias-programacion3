<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script> 
<script> 
  document.addEventListener("DOMContentLoaded", function() { mermaid.initialize({ startOnLoad: true }); }); 
</script>

```
Universidad del Quindío
Programa de Ingeniería de Sistemas y Computación
Programación III - Procesos
Docente: Carlos Andrés Florez V.
```

# Procesos

En este documento se explican los conceptos básicos sobre los procesos en elixir y cómo manejarlos. Además, se incluyen ejemplos prácticos para ilustrar su uso.

## ¿Qué es un proceso?

En sistemas operativos, un proceso es un programa en ejecución que tiene su propio espacio de memoria y recursos asignados.

En **Elixir (y Erlang)**, aunque usamos la misma palabra, los procesos no son procesos del sistema operativo, sino **procesos ligeros gestionados por la máquina virtual BEAM**. 

Esto significa que:

- Son mucho más baratos de crear y destruir que los procesos del SO.
- Pueden escalar hasta miles o incluso millones de procesos concurrentes.
- Cada proceso tiene su propio estado y se comunica exclusivamente mediante paso de mensajes.

## Creación de procesos

Cuando se ejecuta un programa en Elixir, se crea automáticamente un proceso principal que es el encargado de iniciar la ejecución del programa. A partir de este proceso principal, se pueden crear otros procesos utilizando la función `spawn/1` o `spawn/3`.

La función `spawn/1` toma una función anónima como argumento y crea un nuevo proceso que ejecuta esa función. La función `spawn/3` permite especificar un módulo, una función y una lista de argumentos para crear el proceso. 

**Sin argumentos**

Aquí hay un ejemplo de cómo crear un proceso utilizando `spawn/1`:

```elixir
defmodule MiModulo do
  def mi_funcion do
    IO.puts("Hola desde el proceso!")
  end
end

spawn(fn -> MiModulo.mi_funcion() end)
``` 

No es obligatorio usar una función anónima, también se puede pasar directamente la función si no tiene argumentos:

```elixir
spawn(&MiModulo.mi_funcion/0) # Ejecuta una función que se llama mi_funcion y no recibe argumentos
```

**Con argumentos**

Si la función requiere argumentos, se puede utilizar `spawn/3` como se muestra a continuación:

```elixir
defmodule MiModulo do
  def mi_funcion_con_argumento(arg) do
    IO.puts("Hola desde el proceso con argumento: #{arg}")
  end
end

spawn(MiModulo, :mi_funcion_con_argumento, ["Elixir"])
```

Se pueden crear múltiples procesos de esta manera, y cada uno se ejecutará de forma **concurrente**. Sin embargo, es importante recordar que existe un **proceso principal**, encargado de iniciar la ejecución del programa y generar los demás procesos. Cuando este proceso principal finaliza, **todos los procesos hijos también terminan**, ya que dependen de él para mantenerse activos.

## ¿Qué es concurrencia?

La concurrencia es la **capacidad de un sistema para gestionar múltiples tareas o procesos al mismo tiempo**, compartiendo los recursos disponibles. Por ejemplo, en un sistema operativo, la concurrencia permite que varios programas se ejecuten *simultáneamente en apariencia*, alternando su uso de la CPU. Gracias a la concurrencia, los usuarios pueden realizar varias acciones de forma fluida —como escuchar música mientras navegan por internet— sin que una tarea bloquee o interfiera con otra.

Por su parte, el **paralelismo** se refiere a la **ejecución real y simultánea de múltiples tareas**, aprovechando la existencia de **varios procesadores o núcleos**. En este caso, cada tarea se ejecuta literalmente al mismo tiempo en diferentes unidades de procesamiento. Por ejemplo, en un computador con varios núcleos, un núcleo puede procesar datos mientras otro renderiza gráficos, logrando así una ejecución verdaderamente paralela.

> ⚠️ La diferencia clave entre concurrencia y paralelismo radica en que la **concurrencia** se enfoca en la gestión eficiente de múltiples tareas, mientras que el **paralelismo** se centra en la ejecución simultánea de esas tareas.

## Concurrencia en Elixir

En Elixir, la concurrencia se logra mediante la creación y gestión de procesos ligeros que **pueden ejecutarse de manera independiente y simultánea**. Esto permite aprovechar mejor los recursos del sistema y mejorar el rendimiento de las aplicaciones.

Si llamo múltiples veces a `spawn/1` o `spawn/3`, se crearán múltiples procesos que se ejecutarán de manera concurrente. Cada proceso tendrá su propio espacio de memoria y estado, lo que permite que se ejecuten de forma independiente sin interferir entre sí.

Cada proceso tiene un identificador único llamado PID (*Process Identifier*), que se utiliza para referenciar y comunicarse con ese proceso. Por ejemplo, si creo múltiples procesos utilizando `spawn/1`, puedo obtener sus PID de la siguiente manera:

```elixir
pid1 = spawn(MiModulo, :mi_funcion_con_argumento, ["Elixir"])
IO.puts("El PID del proceso es: #{inspect(pid1)}")

pid2 = spawn(MiModulo, :mi_funcion_con_argumento, ["Erlang"])
IO.puts("El PID del proceso es: #{inspect(pid2)}")
```

## Comunicación entre procesos

Los procesos en Elixir pueden comunicarse entre sí utilizando **mensajes**. Cada proceso tiene una cola de mensajes donde puede recibir mensajes de otros procesos. Para enviar un mensaje a otro proceso, se utiliza la función `send/2`, que toma el PID (identificador del proceso) del proceso receptor y el mensaje que se desea enviar. El proceso receptor puede recibir mensajes utilizando la construcción `receive`, que bloquea la ejecución del proceso hasta que llegue un mensaje.

### Diagrama de comunicación entre procesos

Este diagrama ilustra cómo dos procesos pueden comunicarse entre sí mediante el envío y recepción de mensajes:

<div class="mermaid" style="text-align: center;">
sequenceDiagram
    participant A as Proceso A PID 0.50
    participant B as Proceso B PID 0.51
    participant Console as Terminal/Console
    
    Note over A,B: Comunicación asíncrona
    
    A->>B: send(pidB, {:msg, "Hola"})
    Note right of B: Mensaje almacenado en mailbox<br/>[{:msg, "Hola"}]
    
    Note over B: Proceso B ejecuta receive
    activate B
    B->>B: receive do<br/>{:msg, txt} -> IO.puts(txt)<br/>end
    Note right of B: Coincide el patrón {:msg, txt}<br/>txt = "Hola"
    
    B->>Console: IO.puts("Hola")
    Console-->>B: ok
    Note right of Console: Imprime: Hola
    
    Note right of B: Mailbox ahora vacío: []<br/>receive completado
    deactivate B
    
    Note over B: Proceso B queda esperando próximo mensaje
</div>

El código que implementa este diagrama es el siguiente:

```elixir
# Definir task1 para recibir mensajes
task1_pid = spawn(fn ->
  receive do # Espera a recibir un mensaje
    {:mensaje, msg} ->
      IO.puts("Ha recibido este mensaje: #{msg}")
  end
end)

# Se enviar un mensaje a task1
send(task1_pid, {:mensaje, "Hola, desde la tarea 2"})

# Mostrar mensaje de completado. Se imprime cuando el proceso principal termina.
IO.puts("Todas las tareas han terminado")
```

La comunicación entre procesos **es asíncrona**, lo que significa que el proceso que envía el mensaje no espera a que el proceso receptor lo reciba. Esto permite una mayor concurrencia y eficiencia en la ejecución de los procesos. 

La **comunicación asíncrona** es especialmente útil en sistemas distribuidos, donde los procesos pueden estar ejecutándose en diferentes nodos de una red. Por ejemplo, cuando chateamos con alguien a través de una aplicación de mensajería, los mensajes se envían y reciben de manera asíncrona, lo que permite que ambos usuarios continúen utilizando la aplicación sin interrupciones.

## Módulo Task

El módulo `Task` en Elixir proporciona una forma sencilla de crear y manejar procesos concurrentes. Permite ejecutar funciones de manera asíncrona y obtener resultados cuando estén disponibles. Sus funciones más comunes son:

- `Task.async/1`: Crea un nuevo proceso que ejecuta una función de manera asíncrona y devuelve un struct `Task` que contiene el PID del proceso.
- `Task.await/2`: Espera a que el proceso asociado al struct `Task` termine y devuelve su resultado. Si el proceso no termina en el tiempo especificado, se lanza una excepción.

Aquí hay un ejemplo de cómo usar el módulo `Task`:

```elixir
# Crear un proceso asíncrono
task = Task.async(fn ->
  :timer.sleep(2000)  # Simula una tarea que toma tiempo
  42  # Retorna un valor
end)

# Hacer otras cosas mientras la tarea se ejecuta
IO.puts("Haciendo otras cosas...")

# Obtener el resultado de la tarea cuando esté listo. Esto bloquea el proceso principal hasta que la tarea termine.
result = Task.await(task)
IO.puts("El resultado de la tarea es: #{result}")
```

Si no se llama a `Task.await/1`, el proceso principal puede terminar antes de que la tarea haya completado su ejecución, lo que podría resultar en que el resultado de la tarea nunca se obtenga. Por lo tanto, es importante asegurarse de esperar el resultado de la tarea si se necesita.

### Diagrama de concurrencia con Task

Este diagrama ilustra cómo el proceso principal crea múltiples tareas que se ejecutan en paralelo y luego espera a que todas terminen para recolectar sus resultados:

<div class="mermaid" style="text-align: center;">
graph TD
    M[Proceso Principal<br/>spawn tasks concurrently]
    
    subgraph Tasks["Tareas Ejecutándose"]
        T1[Task 1<br/>PID 0.125.0<br/>Task.async fn ->]
        T2[Task 2<br/>PID 0.126.0<br/>Task.async fn ->]
        T3[Task 3<br/>PID 0.127.0<br/>Task.async fn ->]
        Tn[Task N<br/>PID 0.12X.0<br/>Task.async fn ->]
    end
    
    R[Recolección de Resultados<br/>Task.await_many tasks]
    
    Final[Proceso Principal<br/>Resultados Completos]
    
    M -.-> T1
    M -.-> T2
    M -.-> T3
    M -.-> Tn
    
    T1 --> R
    T2 --> R
    T3 --> R
    Tn --> R
    
    R --> Final
    
    style M fill:#e1f5fe
    style T1 fill:#fff3e0
    style T2 fill:#fff3e0
    style T3 fill:#fff3e0
    style Tn fill:#fff3e0
    style R fill:#f3e5f5
    style Final fill:#e8f5e8
</div>

A continuación, se presentan algunos ejemplos prácticos que ilustran el uso de procesos y concurrencia en Elixir utilizando tanto `spawn` como el módulo `Task`.

### Ejemplo 1

En este ejemplo, se crean dos funciones, `tarea1` y `tarea2`, que se ejecutan de manera concurrente utilizando `Task.async/1`. La función `tarea1` simula una tarea que toma tiempo utilizando `:timer.sleep/1`, mientras que la función `tarea2` simplemente imprime un mensaje. El proceso principal continúa ejecutándose mientras las tareas están en progreso y finalmente espera el resultado de `tarea1` utilizando `Task.await/1`.

```elixir
defmodule Ejemplo do
  # Simula una tarea que tarda en completarse
  def tarea1 do
    IO.puts("[Tarea 1] Iniciando proceso largo...")
    :timer.sleep(3000)  # Simula una operación que toma tiempo
    "[Tarea 1] Proceso completado exitosamente"
  end

  # Simula otra tarea más rápida
  def tarea2 do
    IO.puts("[Tarea 2] Ejecutándose...")
    :timer.sleep(1000)
    "[Tarea 2] Finalizó correctamente"
  end

  # Ejecuta ambas tareas de forma concurrente
  def ejecutar_tareas do
    IO.puts("Iniciando tareas concurrentes...\n")

    # Lanza ambas tareas en procesos separados
    task1 = Task.async(&tarea1/0)
    task2 = Task.async(&tarea2/0)

    IO.puts("El proceso principal sigue ejecutándose mientras las tareas trabajan...\n")

    # Espera los resultados
    result1 = Task.await(task1)
    result2 = Task.await(task2)

    IO.puts("\n--- Resultados ---")
    IO.puts(result1)
    IO.puts(result2)
  end
end

Ejemplo.ejecutar_tareas()
```

### Ejemplo 2

En este ejemplo creamos múltiples tareas en un bucle y las ejecutamos tanto de manera secuencial como concurrente para comparar los tiempos de ejecución y resultados.

```elixir
defmodule EjemploMultiplesTareas do
  # Simula una tarea que toma tiempo y devuelve un mensaje
  def tarea(n) do
    IO.puts("[Tarea #{n}] Iniciando...")
    :timer.sleep(1000 * n)  # Simula una operación costosa
    IO.puts("[Tarea #{n}] Finalizó después de #{n} segundos")
    "Resultado de la tarea #{n}: #{n * n}"
  end

  # Ejecuta las tareas una por una (de forma secuencial)
  def ejecutar_secuencialmente do
    IO.puts("\n=== Ejecución Secuencial ===")

    numeros = [1, 2, 3, 4, 5]

    # Ejecutar cada tarea una por una
    resultados = Enum.map(numeros, fn n -> tarea(n) end)

    IO.puts("\nResultados finales (secuencial):")
    IO.inspect(resultados)
  end

  # Ejecuta todas las tareas al mismo tiempo (de forma concurrente)
  def ejecutar_concurrentemente do
    IO.puts("\n=== Ejecución Concurrente ===")

    numeros = [1, 2, 3, 4, 5]

    # Lanzar todas las tareas en procesos separados
    tasks = Enum.map(numeros, fn n -> Task.async(fn -> tarea(n) end) end)

    # Esperar los resultados de todas las tareas. Evita bloquear el proceso principal.
    resultados = Enum.map(tasks, fn task -> Task.await(task) end)

    IO.puts("\nResultados finales (concurrente):")
    IO.inspect(resultados)
  end
end
```

### Ejemplo 3

En este ejemplo, se muestra cómo dos procesos pueden comunicarse entre sí utilizando `send/2` y `receive`. El proceso 1 espera recibir un mensaje del proceso 2, y una vez que lo recibe, envía una confirmación de vuelta al proceso 2.

```elixir
defmodule EjemploComunicacion do
  @moduledoc """
  Ejemplo de comunicación entre procesos en Elixir usando `send` y `receive`.
  Muestra cómo un proceso puede enviar un mensaje a otro y recibir una respuesta.
  """

  @doc """
  Proceso 1: espera un mensaje, lo muestra y envía una confirmación al remitente.
  """
  def proceso1 do
    receive do
      {:mensaje, msg, pid_remitente} ->
        IO.puts("[Proceso 1] Recibió el mensaje: #{msg}")
        :timer.sleep(500) # Simula un pequeño procesamiento
        IO.puts("[Proceso 1] Enviando confirmación al proceso 2...")
        send(pid_remitente, {:confirmacion, "Mensaje recibido correctamente"})
    after
      3000 ->
        IO.puts("[Proceso 1] No recibió ningún mensaje en el tiempo esperado")
    end
  end

  @doc """
  Proceso 2: envía un mensaje a proceso 1 y espera una confirmación.
  """
  def proceso2(pid_proceso1) do
    IO.puts("[Proceso 2] Enviando mensaje a Proceso 1...")
    send(pid_proceso1, {:mensaje, "¡Hola desde proceso 2!", self()})

    receive do
      {:confirmacion, texto} ->
        IO.puts("[Proceso 2] Recibió confirmación: #{texto}")
    after
      3000 ->
        IO.puts("[Proceso 2] No se recibió confirmación en el tiempo esperado")
    end
  end

  @doc """
  Inicia ambos procesos y coordina la comunicación entre ellos.
  """
  def iniciar do
    IO.puts("=== Iniciando comunicación entre procesos ===\n")

    # Iniciar proceso 1
    task1 = Task.async(fn -> proceso1() end)

    # Iniciar proceso 2, pasando el PID del proceso 1
    task2 = Task.async(fn -> proceso2(task1.pid) end)

    # Esperar a que ambos terminen
    Task.await(task1)
    Task.await(task2)

    IO.puts("\n=== Comunicación finalizada ===")
  end
end

# Ejecutar el ejemplo
EjemploComunicacion.iniciar()
```

Para este ejemplo, se usa el bloque `after` dentro de `receive` para manejar el caso en que no se recibe ningún mensaje en un tiempo determinado (3 segundos en este caso). Esto **evita que los procesos queden bloqueados indefinidamente** esperando un mensaje que podría no llegar.

Si creamos tareas que no deben quedar esperando para siempre, es una buena práctica usar `after` para definir un tiempo máximo de espera. Por otro lado, si un proceso puede recibir mensajes en cualquier momento y no queremos que termine, podemos usar un **bucle recursivo** para mantenerlo activo.

## Comparativa spawn vs Task

Tanto `spawn` como `Task` se utilizan para crear procesos en Elixir, pero tienen algunas diferencias clave:

| Característica              | `spawn`                          | `Task`                                       |
| --------------------------- | -------------------------------- | -------------------------------------------- |
| **Nivel de abstracción**    | Bajo nivel: solo crea procesos   | Alto nivel: pensado para tareas              |
| **Manejo de errores**       | El proceso muere en silencio     | Los errores se propagan al creador           |
| **Obtención de resultados** | Manual, con `send/receive`       | Directa, con `Task.await`                    |
| **Funciones extra**         | Ninguna                          | `async_stream`, integración con supervisores |
| **Uso recomendado**         | Casos avanzados con control fino | La mayoría de situaciones prácticas          |

---

## Aplicaciones distribuidas

En los ejemplos anteriores, **todos los procesos se ejecutaban en un mismo nodo** dentro de la máquina virtual BEAM. Sin embargo, Elixir también permite crear **aplicaciones distribuidas**, donde los procesos pueden ejecutarse en **nodos diferentes**, ya sea dentro de una misma máquina o en equipos distintos conectados por red.


Esta capacidad de distribución se logra mediante el módulo `Node`, que proporciona las herramientas necesarias para **gestionar y comunicar nodos** dentro del entorno distribuido de Elixir.

## Módulo Node

El módulo `Node` ofrece funciones para trabajar con **nodos distribuidos** y facilitar la comunicación entre ellos. Algunas de las más utilizadas son:

- `Node.start/1`: inicia un nodo con un nombre específico.
- `Node.connect/1`: establece una conexión con otro nodo en la red.
- `Node.list/0`: devuelve la lista de nodos actualmente conectados.
- `Node.self/0`: obtiene el nombre del nodo actual.

Gracias a estas funciones, es posible construir **sistemas distribuidos** en Elixir donde los procesos se comunican y colaboran de forma transparente, sin importar si se encuentran en el mismo equipo o en distintos dispositivos conectados a la red.

## Ejemplo de uso de Node

Vamos a crear dos nodos y hacer que se comuniquen entre sí. Para esto, abrimos dos terminales y hacemos lo siguiente:


### 1. Iniciar dos nodos

En una terminal, ejecutamos:

```bash
iex --sname nodo1 
```

En otra terminal, ejecutamos:

```bash
iex --sname nodo2
```

Es importante que los nombres de los nodos sean únicos en la red para evitar conflictos.

La bandera `--sname` permite asignar un nombre corto al nodo, que es útil para nodos en la misma máquina. Si los nodos están en diferentes máquinas, se puede usar `--name` para asignar un nombre completo con el formato `nombre@host`.

### 2. Creación del proceso que recibe mensajes

En la terminal donde está `nodo2`, ejecutamos el siguiente código para recibir el mensaje:

```elixir
pid = spawn(fn ->
  receive do
    {:mensaje, msg} -> IO.puts("Recibido en nodo2: #{msg}")
  end
end)
Process.register(pid, :proceso_en_nodo2)
```

El `nodo2` será un receptor de mensajes. El proceso creado se registra con el nombre `:proceso_en_nodo2` para que pueda ser referenciado desde otros nodos.

### 3. Enviar un mensaje desde otro nodo

En la terminal donde está `nodo1`, ejecutamos el siguiente código para conectarnos a `nodo2` y enviarle un mensaje:

```elixir
Node.connect(:nodo2@tu_maquina) # Reemplaza 'tu_maquina' con el nombre de tu máquina
send({:proceso_en_nodo2, :nodo2@tu_maquina}, {:mensaje, "Hola desde nodo1"})
``` 

>⚠️ **Importante:** Para saber el nombre de `tu_maquina`, puede usar `Node.self()` en la terminal de `nodo2`. 

### 4. Verificar la comunicación

En la terminal de `nodo2`, debería ver el mensaje recibido:

```bash
Recibido en nodo2: Hola desde nodo1
```

Para que esto funcione, ambos nodos deben estar en la misma red y ser capaces de comunicarse entre sí. No necesariamente deben estar en la misma máquina, pero sí deben poder resolver los nombres de los nodos entre sí.

>⚠️ **Nota:** Para finalizar los nodos, simplemente se puede usar `Ctrl + C` dos veces en cada terminal o cerrar la terminal directamente.

### 5. Usar scripts en lugar de escribir en la consola

En lugar de escribir los comandos directamente en la consola, podemos crear archivos `.exs` para cada nodo y ejecutarlos.

#### Código para nodo1 (`nodo1.exs`)

```elixir
# nodo1.exs
Node.start(:nodo1)
Node.set_cookie(:nodo1, :mi_cookie) # Se recomienda usar cookies para autenticar nodos

Node.connect(:nodo2@tu_maquina) # Reemplaza 'tu_maquina con el nombre de tu máquina
send({:proceso_en_nodo2, :nodo2@tu_maquina}, {:mensaje, "Hola desde nodo1"})
``` 

#### Código para nodo2 (`nodo2.exs`)

```elixir
# nodo2.exs
Node.start(:nodo2)
Node.set_cookie(:nodo2, :mi_cookie) # Usar la misma cookie para autenticar nodos

pid = spawn(fn ->
  receive do
    {:mensaje, msg} -> IO.puts("Recibido en nodo2: #{msg}")
  end
end)

Process.register(pid, :proceso_en_nodo2)
:timer.sleep(:infinity) # Mantener el nodo activo para recibir mensajes, si no lo escribimos, el proceso termina inmediatamente ya que no hay más código que ejecutar.
```

Luego, en cada terminal, ejecutamos:

```bash
elixir nodo2.exs
```

y en la otra terminal:

```bash
elixir nodo1.exs
```

De esta manera, podemos automatizar la creación y comunicación entre nodos sin necesidad de escribir los comandos manualmente en la consola.

---

## Más allá: OTP

En esta guía trabajamos con procesos "a mano" usando `spawn`, `send`, `receive` y `Task`. Sin embargo, en aplicaciones reales esto puede volverse complejo y propenso a errores.

En aplicaciones reales, Elixir recomienda usar **OTP** (Open Telecom Platform), que provee:

- **GenServer**: procesos con estado encapsulado y callbacks.
- **Supervisores**: reinician procesos automáticamente si fallan.
- **Árboles de supervisión**: estructuras jerárquicas de procesos tolerantes a fallos.

Esto es lo que permite a aplicaciones hechas en Elixir ser **altamente concurrentes y resilientes**. En futuras clases profundizaremos en OTP y sus componentes.

---

## Ejercicio 1

Se desea simular cuatro actividades independientes llamadas (A, B, C y D), los tiempos en milisegundos que tarda cada tarea son: 2500, 1500, 500 y 3500 respectivamente para las cuatro actividades. Se requiere que las actividades se ejecuten de manera secuencial y luego de manera concurrente. Imprima un mensaje indicando cuándo inicia y cuándo termina cada actividad, así como el tiempo total que tarda en ejecutarse cada enfoque (secuencial y concurrente).

## Ejercicio 2

Se desea crear una aplicación distribuida en Elixir que permita a los usuarios enviar mensajes de varios nodos clientes a un nodo servidor central. El nodo servidor recibe mensajes con el siguiente formato: 

- `{:mayusculas, msg}`: Convierte el mensaje a mayúsculas y lo devuelve.
- `{:minusculas, msg}`: Convierte el mensaje a minúsculas y lo devuelve.
- `{:palindroma, msg}`: Verifica si el mensaje es un palíndromo y devuelve true o false.
- `{:contar_vocales, msg}`: Cuenta el número de vocales en el mensaje y lo devuelve.

El nodo servidor debe manejar múltiples solicitudes de manera concurrente y devolver las respuestas a los nodos clientes correspondientes. Los nodos clientes deben poder enviar mensajes al nodo servidor y recibir las respuestas de manera asíncrona.

Además, hay un mensaje especial que finaliza la comunicación: `:fin`. Cuando el nodo servidor recibe este mensaje, le responde al nodo cliente con `:adios` y termina la comunicación con ese cliente.

---

## Para la próxima clase

- Leer sobre OTP y GenServer en la documentación oficial de Elixir: https://hexdocs.pm/elixir/GenServer.html
- Investigar qué es un Agente en Elixir y cómo se utiliza: https://hexdocs.pm/elixir/Agent.html
- Qué es un Supervisor y cómo ayuda a manejar fallos en procesos: https://hexdocs.pm/elixir/Supervisor.html