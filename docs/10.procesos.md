<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script> 
<script> 
  document.addEventListener("DOMContentLoaded", function() { mermaid.initialize({ startOnLoad: true }); }); 
</script>

```
Universidad del Quindío
Programa de Ingeniería de Sistemas y Computación
Programación III - Procesos
Docente: Carlos Andrés Florez V.
```

# Procesos

En este documento se explican los conceptos básicos sobre los procesos en elixir y cómo manejarlos. Además, se incluyen ejemplos prácticos para ilustrar su uso.

## ¿Qué es un proceso?

En los **sistemas operativos**, un **proceso** es un programa en ejecución que posee su propio espacio de memoria y los recursos necesarios para funcionar. Cada proceso es **independiente** y puede ejecutarse de forma **concurrente** con otros.

Por ejemplo, un sistema operativo es capaz de **gestionar la ejecución concurrente** de distintos programas, como un reproductor de música, un navegador web y un editor de texto, garantizando que cada uno disponga de los recursos necesarios sin interferir con los demás.

## Procesos en Elixir

En **Elixir (y Erlang)** también se utiliza el concepto de *proceso*, aunque no se refiere a procesos del sistema operativo, sino a **procesos ligeros gestionados por la máquina virtual BEAM**.

Esto implica que:

* Son mucho más **ligeros** que los procesos del sistema operativo.
* Pueden escalar hasta **miles o incluso millones** de procesos concurrentes.
* Están **completamente aislados**: no comparten memoria.
* Se **comunican mediante el envío de mensajes** (`send` y `receive`).
* Si uno falla, **no afecta a los demás**, lo que otorga alta **tolerancia a fallos**.

Gracias a estas características, Elixir resulta especialmente adecuado para construir **sistemas concurrentes y distribuidos**, como servidores web, aplicaciones de mensajería o sistemas que requieren alta disponibilidad.

## Creación de procesos en Elixir

Al ejecutar un programa en Elixir, se crea automáticamente un **proceso principal**, encargado de iniciar la ejecución del código. Todo el programa se ejecuta inicialmente dentro de este proceso, que actúa como punto de partida para el resto de la aplicación. Sin embargo, Elixir permite **crear procesos adicionales** que pueden ejecutar tareas de forma **concurrente** y **aislada**, sin interferir ni bloquear al proceso principal.

Esta capacidad de dividir el trabajo entre varios procesos permite aprovechar mejor los recursos del sistema y brindar una experiencia más fluida al usuario.

### Ejemplo básico de creación de procesos

A continuación, se presentan algunas formas de crear procesos en Elixir mediante las funciones `spawn/1` y `spawn/3`.

**Ejemplo con `spawn/1`:**

Aunque no es necesario definir un módulo para crear un proceso, es una buena práctica para organizar el código. Aquí hay un ejemplo simple:

```elixir
defmodule MiModulo do
  def mi_funcion do
    IO.puts("Hola desde el proceso hijo!")
  end
end

IO.puts("Iniciando proceso...")
spawn(fn -> MiModulo.mi_funcion() end)
``` 

Ejecute este código y verá que el mensaje del proceso hijo se imprime en la consola. El proceso principal continúa su ejecución sin esperar a que el proceso hijo termine.

**Ejemplo con `spawn/3`:**

Otra forma de crear procesos es utilizar `spawn/3` como se muestra a continuación:

```elixir
defmodule MiModulo do
  def mi_funcion(arg) do
    IO.puts("Hola desde el proceso hijo!")
    IO.puts("Argumento recibido: #{arg}")
  end
end

IO.puts("Iniciando proceso...")
spawn(MiModulo, :mi_funcion, ["Elixir"])
```

Hace lo mismo que el ejemplo anterior, solo cambia es la forma de llamar a la función. Esta forma es útil cuando se desea llamar a una función específica de un módulo con argumentos.

### Proceso principal y procesos hijos

Se pueden crear múltiples procesos de esta manera, y cada uno se ejecutará de forma **concurrente**. Sin embargo, es importante recordar que existe un **proceso principal**, encargado de iniciar la ejecución del programa y generar los demás procesos. Cuando este proceso principal finaliza, **todos los procesos hijos también terminan**, ya que dependen de él para mantenerse activos.

---

## ¿Qué es concurrencia?

La concurrencia es la **capacidad de un sistema para gestionar múltiples tareas o procesos al mismo tiempo**, compartiendo los recursos disponibles. Por ejemplo, en un sistema operativo, la concurrencia permite que varios programas se ejecuten *simultáneamente en apariencia*, alternando su uso de la CPU. Gracias a la concurrencia, los usuarios pueden realizar varias acciones de forma fluida —como escuchar música mientras navegan por internet— sin que una tarea bloquee o interfiera con otra.

Por su parte, el **paralelismo** se refiere a la **ejecución real y simultánea de múltiples tareas**, aprovechando la existencia de **varios procesadores o núcleos**. En este caso, cada tarea se ejecuta literalmente al mismo tiempo en diferentes unidades de procesamiento. Por ejemplo, en un computador con varios núcleos, un núcleo puede procesar datos mientras otro renderiza gráficos, logrando así una ejecución verdaderamente paralela.

> ⚠️ La diferencia clave entre concurrencia y paralelismo radica en que la **concurrencia** se enfoca en la gestión eficiente de múltiples tareas, mientras que el **paralelismo** se centra en la ejecución simultánea de esas tareas.

## Concurrencia en Elixir

En Elixir, la concurrencia se logra mediante la creación y gestión de procesos ligeros que **pueden ejecutarse de manera independiente y simultánea**. Esto permite aprovechar mejor los recursos del sistema y mejorar el rendimiento de las aplicaciones.

Si llamo múltiples veces a `spawn/1` o `spawn/3`, se crearán múltiples procesos que se ejecutarán de manera concurrente.

Cada proceso tiene un **identificador único llamado PID** (*Process Identifier*), que se utiliza para referenciar y comunicarse con ese proceso. Por ejemplo, si creo múltiples procesos puedo obtener sus PID de la siguiente manera:

```elixir
pid1 = spawn(MiModulo, :mi_funcion, ["Elixir"])
IO.puts("El PID del proceso es: #{inspect(pid1)}")

pid2 = spawn(MiModulo, :mi_funcion, ["Erlang"])
IO.puts("El PID del proceso es: #{inspect(pid2)}")
```

También se puede saber el PID del proceso actual utilizando `self/0`:

```elixir
defmodule MiModulo do
  def mi_funcion(numero) do
    IO.inspect(self(), label: "Ejecuto la tarea #{numero}") # Muestra el PID del proceso actual
  end
end

# Se muestra el PID del proceso principal
IO.inspect(self(), label: "Proceso principal")

spawn(fn -> MiModulo.mi_funcion(1) end)
spawn(fn -> MiModulo.mi_funcion(2) end)
```

Ejecute este código y observe cómo cada proceso tiene un PID diferente, lo que indica que son procesos independientes que se ejecutan de manera concurrente. Pruebe creando más procesos y observe sus PID únicos.

## Comunicación entre procesos

Los procesos en Elixir pueden comunicarse entre sí utilizando **mensajes**. Cada proceso tiene una cola de mensajes donde puede recibir mensajes de otros procesos. Para enviar un mensaje a otro proceso, se utiliza la función `send/2`, que toma el PID (identificador del proceso) del proceso receptor y el mensaje que se desea enviar. El proceso receptor puede recibir mensajes utilizando la construcción `receive`, que bloquea la ejecución del proceso hasta que llegue un mensaje.

### Diagrama de comunicación entre procesos

Este diagrama ilustra cómo dos procesos pueden comunicarse entre sí mediante el envío y recepción de mensajes:

<div class="mermaid" style="text-align: center;">
sequenceDiagram
    participant A as Proceso A PID 0.50
    participant B as Proceso B PID 0.51
    participant Console as Terminal/Console
    
    Note over A,B: Comunicación asíncrona
    
    A->>B: send(pidB, {:msg, "Hola"})
    Note right of B: Mensaje almacenado en mailbox<br/>[{:msg, "Hola"}]
    
    Note over B: Proceso B ejecuta receive
    activate B
    B->>B: receive do<br/>{:msg, txt} -> IO.puts(txt)<br/>end
    Note right of B: Coincide el patrón {:msg, txt}<br/>txt = "Hola"
    
    B->>Console: IO.puts("Hola")
    Console-->>B: ok
    Note right of Console: Imprime: Hola
    
    Note right of B: Mailbox ahora vacío: []<br/>receive completado
    deactivate B
    
    Note over B: Proceso B queda esperando próximo mensaje
</div>

La comunicación entre procesos **es asíncrona**, lo que significa que el proceso que envía el mensaje no espera a que el proceso receptor lo reciba. Esto permite una mayor concurrencia y eficiencia en la ejecución de los procesos. 

El código siguiente ilustra un ejemplo simple de comunicación entre procesos:

```elixir
# Definir task1 para recibir mensajes (No es necesario un módulo como en ejemplos anteriores, aunque se podría hacer)
task1_pid = spawn(fn ->
  receive do # Espera a recibir un mensaje
    {:mensaje, msg} -> # Si coincide el patrón, imprime el mensaje
      IO.puts("Mensaje recibido: #{msg}")
  end
end)

# Se enviar un mensaje a task1
send(task1_pid, {:mensaje, "Hola desde el proceso principal"})

# Mostrar mensaje de completado. Se imprime cuando el proceso principal termina.
IO.puts("Todas las tareas han terminado")
```

Ejecute este código y observe cómo el proceso principal envía un mensaje al proceso `task1`, que lo recibe e imprime en la consola.

La **comunicación asíncrona** es especialmente útil en sistemas distribuidos, donde los procesos pueden estar ejecutándose en diferentes nodos de una red. Por ejemplo, cuando chateamos con alguien a través de una aplicación de mensajería, los mensajes se envían y reciben de manera asíncrona, lo que permite que ambos usuarios continúen utilizando la aplicación sin interrupciones.

---

## Módulo Task

El módulo `Task` en Elixir proporciona una forma sencilla de crear y manejar procesos concurrentes. Permite ejecutar funciones de manera asíncrona y obtener resultados cuando estén disponibles. Sus funciones más comunes son:

- `Task.async/1`: Crea un nuevo proceso que ejecuta una función de manera asíncrona y devuelve un struct `Task` que contiene el PID del proceso.
- `Task.await/2`: Espera a que el proceso asociado al struct `Task` termine y devuelve su resultado. Si el proceso no termina en el tiempo especificado, se lanza una excepción.

Aquí hay un ejemplo de cómo usar el módulo `Task`:

```elixir
# Crear un proceso asíncrono
task = Task.async(fn ->
  :timer.sleep(2000)  # Simula una tarea que toma tiempo
  42  # Retorna un valor
end)

# Hacer otras cosas mientras la tarea se ejecuta
IO.puts("Haciendo otras cosas...")

# Obtener el resultado de la tarea cuando esté listo. Esto bloquea el proceso principal hasta que la tarea termine.
result = Task.await(task)
IO.puts("El resultado de la tarea es: #{result}")
```

Si no se llama a `Task.await/1`, el proceso principal puede terminar antes de que la tarea haya completado su ejecución, lo que podría resultar en que el resultado de la tarea nunca se obtenga. Por lo tanto, es importante asegurarse de esperar el resultado de la tarea si se necesita.

Ejecute este código y observe cómo el proceso principal continúa ejecutándose mientras la tarea está en progreso, y luego espera el resultado de la tarea antes de imprimirlo.

### Diagrama de concurrencia con Task

Este diagrama ilustra cómo el proceso principal puede crear múltiples tareas que se ejecutan en paralelo y luego espera a que todas terminen para recolectar sus resultados:

<div class="mermaid" style="text-align: center;">
graph TD
    M[Proceso Principal<br/>spawn tasks concurrently]
    
    subgraph Tasks["Tareas Ejecutándose"]
        T1[Task 1<br/>PID 0.125.0<br/>Task.async fn ->]
        T2[Task 2<br/>PID 0.126.0<br/>Task.async fn ->]
        T3[Task 3<br/>PID 0.127.0<br/>Task.async fn ->]
        Tn[Task N<br/>PID 0.12X.0<br/>Task.async fn ->]
    end
    
    R[Recolección de Resultados<br/>Task.await_many tasks]
    
    Final[Proceso Principal<br/>Resultados Completos]
    
    M -.-> T1
    M -.-> T2
    M -.-> T3
    M -.-> Tn
    
    T1 --> R
    T2 --> R
    T3 --> R
    Tn --> R
    
    R --> Final
    
    style M fill:#e1f5fe
    style T1 fill:#fff3e0
    style T2 fill:#fff3e0
    style T3 fill:#fff3e0
    style Tn fill:#fff3e0
    style R fill:#f3e5f5
    style Final fill:#e8f5e8
</div>

A continuación, se presentan algunos ejemplos prácticos que ilustran el uso de procesos y concurrencia en Elixir utilizando tanto `spawn` como el módulo `Task`.

### Ejemplo 1

En este ejemplo, se crean dos funciones, `tarea1` y `tarea2`, que se ejecutan de manera concurrente utilizando `Task.async/1`. La función `tarea1` simula una tarea que toma tiempo utilizando `:timer.sleep/1`, mientras que la función `tarea2` simplemente imprime un mensaje. El proceso principal continúa ejecutándose mientras las tareas están en progreso y finalmente espera el resultado de `tarea1` utilizando `Task.await/1`.

```elixir
defmodule Ejemplo do
  # Simula una tarea que tarda en completarse
  def tarea1 do
    IO.puts("[Tarea 1] Iniciando proceso largo...")
    :timer.sleep(3000)  # Simula una operación que toma tiempo
    "[Tarea 1] Proceso completado exitosamente"
  end

  # Simula otra tarea más rápida
  def tarea2 do
    IO.puts("[Tarea 2] Ejecutándose...")
    :timer.sleep(1000)
    "[Tarea 2] Finalizó correctamente"
  end

  # Ejecuta ambas tareas de forma concurrente
  def ejecutar_tareas do
    IO.puts("Iniciando tareas concurrentes...\n")

    # Lanza ambas tareas en procesos separados
    task1 = Task.async(&tarea1/0)
    task2 = Task.async(&tarea2/0)

    IO.puts("El proceso principal sigue ejecutándose mientras las tareas trabajan...\n")

    # Espera los resultados (bloquea hasta que cada tarea termine)
    result1 = Task.await(task1)
    result2 = Task.await(task2)

    IO.puts("\n--- Resultados ---")
    IO.puts(result1)
    IO.puts(result2)
  end
end

Ejemplo.ejecutar_tareas()
```

### Ejemplo 2

En este ejemplo creamos múltiples tareas en un bucle y las ejecutamos tanto de manera secuencial como concurrente para comparar los tiempos de ejecución y resultados.

```elixir
defmodule EjemploMultiplesTareas do
  # Simula una tarea que toma tiempo y devuelve un mensaje
  def tarea(n) do
    IO.puts("[Tarea #{n}] Iniciando...")
    :timer.sleep(1000 * n)  # Simula una operación costosa
    IO.puts("[Tarea #{n}] Finalizó después de #{n} segundos")
    "Resultado de la tarea #{n}: #{n * n}"
  end

  # Ejecuta las tareas una por una (de forma secuencial)
  def ejecutar_secuencialmente do
    IO.puts("\n=== Ejecución Secuencial ===")

    numeros = [1, 2, 3, 4, 5]

    # Ejecutar cada tarea una por una
    resultados = Enum.map(numeros, fn n -> tarea(n) end)

    IO.puts("\nResultados finales (secuencial):")
    IO.inspect(resultados)
  end

  # Ejecuta todas las tareas al mismo tiempo (de forma concurrente)
  def ejecutar_concurrentemente do
    IO.puts("\n=== Ejecución Concurrente ===")

    numeros = [1, 2, 3, 4, 5]

    # Lanzar todas las tareas en procesos separados
    tasks = Enum.map(numeros, fn n -> Task.async(fn -> tarea(n) end) end)

    # Esperar los resultados de todas las tareas. Evita bloquear el proceso principal.
    resultados = Enum.map(tasks, fn task -> Task.await(task) end)

    IO.puts("\nResultados finales (concurrente):")
    IO.inspect(resultados)
  end
end
```

### Ejemplo 3

En este ejemplo, se muestra cómo dos procesos pueden comunicarse entre sí utilizando el módulo `Task`, sin necesidad de usar `send` ni `receive` directamente. Aquí, el Proceso 2 envía un mensaje al Proceso 1 y espera una respuesta utilizando `Task.async` y `Task.await`.

```elixir
defmodule EjemploComunicacionTask do
  @moduledoc """
  Ejemplo de comunicación entre dos procesos en Elixir usando `Task`,
  conservando dos procesos independientes (Proceso 1 y Proceso 2) sin usar `send` ni `receive`.
  """

  # === Proceso 1 ===
  # Recibe un mensaje, lo procesa y retorna una confirmación.
  def proceso1(msg) do
    IO.puts("[Proceso 1] Recibió mensaje: #{msg}")
    :timer.sleep(500)
    IO.puts("[Proceso 1] Procesamiento completado.")
    "Confirmación desde Proceso 1: mensaje recibido correctamente."
  end

  # === Proceso 2 ===
  # Envía un mensaje a Proceso 1 y espera la respuesta.
  def proceso2 do
    IO.puts("[Proceso 2] Enviando mensaje a Proceso 1...")

    # Lanza proceso 1 como una tarea asíncrona
    task1 = Task.async(fn -> proceso1("¡Hola desde Proceso 2!") end)

    # Espera la respuesta del proceso 1 (bloqueante hasta 3 segundos)
    respuesta = Task.await(task1, 3000)

    IO.puts("[Proceso 2] Recibió respuesta: #{respuesta}")
    IO.puts("[Proceso 2] Finalizando ejecución.")
  end

  # === Proceso principal ===
  # Inicia ambos procesos de forma controlada.
  def iniciar do
    IO.puts("=== Iniciando comunicación entre procesos ===\n")

    # Lanzamos el proceso 2 (quien a su vez invoca al proceso 1)
    task2 = Task.async(fn -> proceso2() end)

    # Esperamos a que Proceso 2 termine completamente
    Task.await(task2)

    IO.puts("\n=== Comunicación finalizada ===")
  end
end

# Ejecutar el ejemplo
EjemploComunicacionTask.iniciar()
```

### Ejemplo 4: Uso de after en receive

Haga un nuevo script que cree dos procesos: uno que envíe un mensaje y otro que lo reciba e imprima y le envíe una confirmación de vuelta al proceso emisor. Para este ejemplo use `spawn`, `send`, `receive` y `after`. No use `Task`.

Investigue cómo usar `after` en la construcción `receive` para manejar casos en los que no se recibe ningún mensaje en un tiempo determinado.

El bloque `after` **evita que los procesos queden bloqueados indefinidamente** esperando un mensaje que podría no llegar.

Si creamos tareas que no deben quedar esperando para siempre, es una buena práctica usar `after` para definir un tiempo máximo de espera. Por otro lado, si un proceso puede recibir mensajes en cualquier momento y no queremos que termine, podemos usar un **bucle recursivo** para mantenerlo activo.

## Comparativa spawn vs Task

Tanto `spawn` como `Task` se utilizan para crear procesos en Elixir, pero tienen algunas diferencias clave:

| Característica              | `spawn`                          | `Task`                                       |
| --------------------------- | -------------------------------- | -------------------------------------------- |
| **Nivel de abstracción**    | Bajo nivel: solo crea procesos   | Alto nivel: pensado para tareas              |
| **Manejo de errores**       | El proceso muere en silencio     | Los errores se propagan al creador           |
| **Obtención de resultados** | Manual, con `send/receive`       | Directa, con `Task.await`                    |
| **Funciones extra**         | Ninguna                          | `async_stream`, integración con supervisores |
| **Uso recomendado**         | Casos avanzados con control fino | La mayoría de situaciones prácticas          |

---

## Para la próxima clase

- Investigar sobre aplicaciones distribuidas en Elixir y cómo los procesos pueden comunicarse a través de nodos.
- Leer sobre redes locales, direcciones IP y comunicación entre máquinas para entender mejor los sistemas distribuidos.