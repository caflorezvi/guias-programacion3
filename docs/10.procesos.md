<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script> 
<script> 
  document.addEventListener("DOMContentLoaded", function() { mermaid.initialize({ startOnLoad: true }); }); 
</script>

```
Universidad del Quindío
Programa de Ingeniería de Sistemas y Computación
Programación III - Procesos
Docente: Carlos Andrés Florez V.
```

# Procesos

En este documento se explican los conceptos básicos sobre los procesos en elixir y cómo manejarlos. Además, se incluyen ejemplos prácticos para ilustrar su uso.

## ¿Qué es un proceso?

En los **sistemas operativos**, un **proceso** es un programa en ejecución que posee su propio espacio de memoria y los recursos necesarios para funcionar. Cada proceso es **independiente** y puede ejecutarse de forma **concurrente** con otros.

Por ejemplo, un sistema operativo es capaz de **gestionar la ejecución concurrente** de distintos programas, como un reproductor de música, un navegador web y un editor de texto, garantizando que cada uno disponga de los recursos necesarios sin interferir con los demás.

## Procesos en Elixir

En **Elixir (y Erlang)** también se utiliza el concepto de *proceso*, aunque no se refiere a procesos del sistema operativo, sino a **procesos ligeros gestionados por la máquina virtual BEAM**.

Esto implica que:

* Son mucho más **ligeros** que los procesos del sistema operativo.
* Pueden escalar hasta **miles o incluso millones** de procesos concurrentes.
* Están **completamente aislados**: no comparten memoria.
* Se **comunican mediante el envío de mensajes** (`send` y `receive`).
* Si uno falla, **no afecta a los demás**, lo que otorga alta **tolerancia a fallos**.

Gracias a estas características, Elixir resulta especialmente adecuado para construir **sistemas concurrentes y distribuidos**, como servidores web, aplicaciones de mensajería o sistemas que requieren alta disponibilidad.

## Creación de procesos en Elixir

Al ejecutar un programa en Elixir, se crea automáticamente un **proceso principal**, encargado de iniciar la ejecución del código. Todo el programa se ejecuta inicialmente dentro de este proceso, que actúa como punto de partida para el resto de la aplicación. Sin embargo, Elixir permite **crear procesos adicionales** que pueden ejecutar tareas de forma **concurrente** y **aislada**, sin interferir ni bloquear al proceso principal.

Esta capacidad de dividir el trabajo entre varios procesos permite aprovechar mejor los recursos del sistema y brindar una experiencia más fluida al usuario.

A continuación, se presentan algunas formas de crear procesos en Elixir mediante las funciones `spawn/1` y `spawn/3`.

**Sin argumentos**

Aquí hay un ejemplo de cómo crear un proceso utilizando `spawn/1`:

```elixir
defmodule MiModulo do
  def mi_funcion do
    IO.puts("Hola desde el proceso!")
  end
end

spawn(fn -> MiModulo.mi_funcion() end)
``` 

No es obligatorio usar una función anónima, también se puede pasar directamente la función si no tiene argumentos:

```elixir
spawn(&MiModulo.mi_funcion/0) # Ejecuta una función que se llama mi_funcion y no recibe argumentos
```

**Con argumentos**

Si la función requiere argumentos, se puede utilizar `spawn/3` como se muestra a continuación:

```elixir
defmodule MiModulo do
  def mi_funcion_con_argumento(arg) do
    IO.puts("Hola desde el proceso con argumento: #{arg}")
  end
end

spawn(MiModulo, :mi_funcion_con_argumento, ["Elixir"])
```

Se pueden crear múltiples procesos de esta manera, y cada uno se ejecutará de forma **concurrente**. Sin embargo, es importante recordar que existe un **proceso principal**, encargado de iniciar la ejecución del programa y generar los demás procesos. Cuando este proceso principal finaliza, **todos los procesos hijos también terminan**, ya que dependen de él para mantenerse activos.

## ¿Qué es concurrencia?

La concurrencia es la **capacidad de un sistema para gestionar múltiples tareas o procesos al mismo tiempo**, compartiendo los recursos disponibles. Por ejemplo, en un sistema operativo, la concurrencia permite que varios programas se ejecuten *simultáneamente en apariencia*, alternando su uso de la CPU. Gracias a la concurrencia, los usuarios pueden realizar varias acciones de forma fluida —como escuchar música mientras navegan por internet— sin que una tarea bloquee o interfiera con otra.

Por su parte, el **paralelismo** se refiere a la **ejecución real y simultánea de múltiples tareas**, aprovechando la existencia de **varios procesadores o núcleos**. En este caso, cada tarea se ejecuta literalmente al mismo tiempo en diferentes unidades de procesamiento. Por ejemplo, en un computador con varios núcleos, un núcleo puede procesar datos mientras otro renderiza gráficos, logrando así una ejecución verdaderamente paralela.

> ⚠️ La diferencia clave entre concurrencia y paralelismo radica en que la **concurrencia** se enfoca en la gestión eficiente de múltiples tareas, mientras que el **paralelismo** se centra en la ejecución simultánea de esas tareas.

## Concurrencia en Elixir

En Elixir, la concurrencia se logra mediante la creación y gestión de procesos ligeros que **pueden ejecutarse de manera independiente y simultánea**. Esto permite aprovechar mejor los recursos del sistema y mejorar el rendimiento de las aplicaciones.

Si llamo múltiples veces a `spawn/1` o `spawn/3`, se crearán múltiples procesos que se ejecutarán de manera concurrente. Cada proceso tendrá su propio espacio de memoria y estado, lo que permite que se ejecuten de forma independiente sin interferir entre sí.

Cada proceso tiene un identificador único llamado PID (*Process Identifier*), que se utiliza para referenciar y comunicarse con ese proceso. Por ejemplo, si creo múltiples procesos utilizando `spawn/1`, puedo obtener sus PID de la siguiente manera:

```elixir
pid1 = spawn(MiModulo, :mi_funcion_con_argumento, ["Elixir"])
IO.puts("El PID del proceso es: #{inspect(pid1)}")

pid2 = spawn(MiModulo, :mi_funcion_con_argumento, ["Erlang"])
IO.puts("El PID del proceso es: #{inspect(pid2)}")
```

## Comunicación entre procesos

Los procesos en Elixir pueden comunicarse entre sí utilizando **mensajes**. Cada proceso tiene una cola de mensajes donde puede recibir mensajes de otros procesos. Para enviar un mensaje a otro proceso, se utiliza la función `send/2`, que toma el PID (identificador del proceso) del proceso receptor y el mensaje que se desea enviar. El proceso receptor puede recibir mensajes utilizando la construcción `receive`, que bloquea la ejecución del proceso hasta que llegue un mensaje.

### Diagrama de comunicación entre procesos

Este diagrama ilustra cómo dos procesos pueden comunicarse entre sí mediante el envío y recepción de mensajes:

<div class="mermaid" style="text-align: center;">
sequenceDiagram
    participant A as Proceso A PID 0.50
    participant B as Proceso B PID 0.51
    participant Console as Terminal/Console
    
    Note over A,B: Comunicación asíncrona
    
    A->>B: send(pidB, {:msg, "Hola"})
    Note right of B: Mensaje almacenado en mailbox<br/>[{:msg, "Hola"}]
    
    Note over B: Proceso B ejecuta receive
    activate B
    B->>B: receive do<br/>{:msg, txt} -> IO.puts(txt)<br/>end
    Note right of B: Coincide el patrón {:msg, txt}<br/>txt = "Hola"
    
    B->>Console: IO.puts("Hola")
    Console-->>B: ok
    Note right of Console: Imprime: Hola
    
    Note right of B: Mailbox ahora vacío: []<br/>receive completado
    deactivate B
    
    Note over B: Proceso B queda esperando próximo mensaje
</div>

El código que implementa este diagrama es el siguiente:

```elixir
# Definir task1 para recibir mensajes
task1_pid = spawn(fn ->
  receive do # Espera a recibir un mensaje
    {:mensaje, msg} ->
      IO.puts("Ha recibido este mensaje: #{msg}")
  end
end)

# Se enviar un mensaje a task1
send(task1_pid, {:mensaje, "Hola, desde la tarea 2"})

# Mostrar mensaje de completado. Se imprime cuando el proceso principal termina.
IO.puts("Todas las tareas han terminado")
```

La comunicación entre procesos **es asíncrona**, lo que significa que el proceso que envía el mensaje no espera a que el proceso receptor lo reciba. Esto permite una mayor concurrencia y eficiencia en la ejecución de los procesos. 

La **comunicación asíncrona** es especialmente útil en sistemas distribuidos, donde los procesos pueden estar ejecutándose en diferentes nodos de una red. Por ejemplo, cuando chateamos con alguien a través de una aplicación de mensajería, los mensajes se envían y reciben de manera asíncrona, lo que permite que ambos usuarios continúen utilizando la aplicación sin interrupciones.

## Módulo Task

El módulo `Task` en Elixir proporciona una forma sencilla de crear y manejar procesos concurrentes. Permite ejecutar funciones de manera asíncrona y obtener resultados cuando estén disponibles. Sus funciones más comunes son:

- `Task.async/1`: Crea un nuevo proceso que ejecuta una función de manera asíncrona y devuelve un struct `Task` que contiene el PID del proceso.
- `Task.await/2`: Espera a que el proceso asociado al struct `Task` termine y devuelve su resultado. Si el proceso no termina en el tiempo especificado, se lanza una excepción.

Aquí hay un ejemplo de cómo usar el módulo `Task`:

```elixir
# Crear un proceso asíncrono
task = Task.async(fn ->
  :timer.sleep(2000)  # Simula una tarea que toma tiempo
  42  # Retorna un valor
end)

# Hacer otras cosas mientras la tarea se ejecuta
IO.puts("Haciendo otras cosas...")

# Obtener el resultado de la tarea cuando esté listo. Esto bloquea el proceso principal hasta que la tarea termine.
result = Task.await(task)
IO.puts("El resultado de la tarea es: #{result}")
```

Si no se llama a `Task.await/1`, el proceso principal puede terminar antes de que la tarea haya completado su ejecución, lo que podría resultar en que el resultado de la tarea nunca se obtenga. Por lo tanto, es importante asegurarse de esperar el resultado de la tarea si se necesita.

### Diagrama de concurrencia con Task

Este diagrama ilustra cómo el proceso principal crea múltiples tareas que se ejecutan en paralelo y luego espera a que todas terminen para recolectar sus resultados:

<div class="mermaid" style="text-align: center;">
graph TD
    M[Proceso Principal<br/>spawn tasks concurrently]
    
    subgraph Tasks["Tareas Ejecutándose"]
        T1[Task 1<br/>PID 0.125.0<br/>Task.async fn ->]
        T2[Task 2<br/>PID 0.126.0<br/>Task.async fn ->]
        T3[Task 3<br/>PID 0.127.0<br/>Task.async fn ->]
        Tn[Task N<br/>PID 0.12X.0<br/>Task.async fn ->]
    end
    
    R[Recolección de Resultados<br/>Task.await_many tasks]
    
    Final[Proceso Principal<br/>Resultados Completos]
    
    M -.-> T1
    M -.-> T2
    M -.-> T3
    M -.-> Tn
    
    T1 --> R
    T2 --> R
    T3 --> R
    Tn --> R
    
    R --> Final
    
    style M fill:#e1f5fe
    style T1 fill:#fff3e0
    style T2 fill:#fff3e0
    style T3 fill:#fff3e0
    style Tn fill:#fff3e0
    style R fill:#f3e5f5
    style Final fill:#e8f5e8
</div>

A continuación, se presentan algunos ejemplos prácticos que ilustran el uso de procesos y concurrencia en Elixir utilizando tanto `spawn` como el módulo `Task`.

### Ejemplo 1

En este ejemplo, se crean dos funciones, `tarea1` y `tarea2`, que se ejecutan de manera concurrente utilizando `Task.async/1`. La función `tarea1` simula una tarea que toma tiempo utilizando `:timer.sleep/1`, mientras que la función `tarea2` simplemente imprime un mensaje. El proceso principal continúa ejecutándose mientras las tareas están en progreso y finalmente espera el resultado de `tarea1` utilizando `Task.await/1`.

```elixir
defmodule Ejemplo do
  # Simula una tarea que tarda en completarse
  def tarea1 do
    IO.puts("[Tarea 1] Iniciando proceso largo...")
    :timer.sleep(3000)  # Simula una operación que toma tiempo
    "[Tarea 1] Proceso completado exitosamente"
  end

  # Simula otra tarea más rápida
  def tarea2 do
    IO.puts("[Tarea 2] Ejecutándose...")
    :timer.sleep(1000)
    "[Tarea 2] Finalizó correctamente"
  end

  # Ejecuta ambas tareas de forma concurrente
  def ejecutar_tareas do
    IO.puts("Iniciando tareas concurrentes...\n")

    # Lanza ambas tareas en procesos separados
    task1 = Task.async(&tarea1/0)
    task2 = Task.async(&tarea2/0)

    IO.puts("El proceso principal sigue ejecutándose mientras las tareas trabajan...\n")

    # Espera los resultados
    result1 = Task.await(task1)
    result2 = Task.await(task2)

    IO.puts("\n--- Resultados ---")
    IO.puts(result1)
    IO.puts(result2)
  end
end

Ejemplo.ejecutar_tareas()
```

### Ejemplo 2

En este ejemplo creamos múltiples tareas en un bucle y las ejecutamos tanto de manera secuencial como concurrente para comparar los tiempos de ejecución y resultados.

```elixir
defmodule EjemploMultiplesTareas do
  # Simula una tarea que toma tiempo y devuelve un mensaje
  def tarea(n) do
    IO.puts("[Tarea #{n}] Iniciando...")
    :timer.sleep(1000 * n)  # Simula una operación costosa
    IO.puts("[Tarea #{n}] Finalizó después de #{n} segundos")
    "Resultado de la tarea #{n}: #{n * n}"
  end

  # Ejecuta las tareas una por una (de forma secuencial)
  def ejecutar_secuencialmente do
    IO.puts("\n=== Ejecución Secuencial ===")

    numeros = [1, 2, 3, 4, 5]

    # Ejecutar cada tarea una por una
    resultados = Enum.map(numeros, fn n -> tarea(n) end)

    IO.puts("\nResultados finales (secuencial):")
    IO.inspect(resultados)
  end

  # Ejecuta todas las tareas al mismo tiempo (de forma concurrente)
  def ejecutar_concurrentemente do
    IO.puts("\n=== Ejecución Concurrente ===")

    numeros = [1, 2, 3, 4, 5]

    # Lanzar todas las tareas en procesos separados
    tasks = Enum.map(numeros, fn n -> Task.async(fn -> tarea(n) end) end)

    # Esperar los resultados de todas las tareas. Evita bloquear el proceso principal.
    resultados = Enum.map(tasks, fn task -> Task.await(task) end)

    IO.puts("\nResultados finales (concurrente):")
    IO.inspect(resultados)
  end
end
```

### Ejemplo 3

En este ejemplo, se muestra cómo dos procesos pueden comunicarse entre sí utilizando `send/2` y `receive`. El proceso 1 espera recibir un mensaje del proceso 2, y una vez que lo recibe, envía una confirmación de vuelta al proceso 2.

```elixir
defmodule EjemploComunicacion do
  @moduledoc """
  Ejemplo de comunicación entre procesos en Elixir usando `send` y `receive`.
  Muestra cómo un proceso puede enviar un mensaje a otro y recibir una respuesta.
  """

  @doc """
  Proceso 1: espera un mensaje, lo muestra y envía una confirmación al remitente.
  """
  def proceso1 do
    receive do
      {:mensaje, msg, pid_remitente} ->
        IO.puts("[Proceso 1] Recibió el mensaje: #{msg}")
        :timer.sleep(500) # Simula un pequeño procesamiento
        IO.puts("[Proceso 1] Enviando confirmación al proceso 2...")
        send(pid_remitente, {:confirmacion, "Mensaje recibido correctamente"})
    after
      3000 ->
        IO.puts("[Proceso 1] No recibió ningún mensaje en el tiempo esperado")
    end
  end

  @doc """
  Proceso 2: envía un mensaje a proceso 1 y espera una confirmación.
  """
  def proceso2(pid_proceso1) do
    IO.puts("[Proceso 2] Enviando mensaje a Proceso 1...")
    send(pid_proceso1, {:mensaje, "¡Hola desde proceso 2!", self()})

    receive do
      {:confirmacion, texto} ->
        IO.puts("[Proceso 2] Recibió confirmación: #{texto}")
    after
      3000 ->
        IO.puts("[Proceso 2] No se recibió confirmación en el tiempo esperado")
    end
  end

  @doc """
  Inicia ambos procesos y coordina la comunicación entre ellos.
  """
  def iniciar do
    IO.puts("=== Iniciando comunicación entre procesos ===\n")

    # Iniciar proceso 1
    task1 = Task.async(fn -> proceso1() end)

    # Iniciar proceso 2, pasando el PID del proceso 1
    task2 = Task.async(fn -> proceso2(task1.pid) end)

    # Esperar a que ambos terminen
    Task.await(task1)
    Task.await(task2)

    IO.puts("\n=== Comunicación finalizada ===")
  end
end

# Ejecutar el ejemplo
EjemploComunicacion.iniciar()
```

Para este ejemplo, se usa el bloque `after` dentro de `receive` para manejar el caso en que no se recibe ningún mensaje en un tiempo determinado (3 segundos en este caso). Esto **evita que los procesos queden bloqueados indefinidamente** esperando un mensaje que podría no llegar.

Si creamos tareas que no deben quedar esperando para siempre, es una buena práctica usar `after` para definir un tiempo máximo de espera. Por otro lado, si un proceso puede recibir mensajes en cualquier momento y no queremos que termine, podemos usar un **bucle recursivo** para mantenerlo activo.

## Comparativa spawn vs Task

Tanto `spawn` como `Task` se utilizan para crear procesos en Elixir, pero tienen algunas diferencias clave:

| Característica              | `spawn`                          | `Task`                                       |
| --------------------------- | -------------------------------- | -------------------------------------------- |
| **Nivel de abstracción**    | Bajo nivel: solo crea procesos   | Alto nivel: pensado para tareas              |
| **Manejo de errores**       | El proceso muere en silencio     | Los errores se propagan al creador           |
| **Obtención de resultados** | Manual, con `send/receive`       | Directa, con `Task.await`                    |
| **Funciones extra**         | Ninguna                          | `async_stream`, integración con supervisores |
| **Uso recomendado**         | Casos avanzados con control fino | La mayoría de situaciones prácticas          |

---

## Aplicaciones distribuidas

En los ejemplos anteriores, **todos los procesos se ejecutaban en un mismo nodo** dentro de la máquina virtual BEAM. Sin embargo, Elixir también permite crear **aplicaciones distribuidas**, donde los procesos pueden ejecutarse en **nodos diferentes**, ya sea dentro de una misma máquina o en equipos distintos conectados por red.


Esta capacidad de distribución se logra mediante el módulo `Node`, que proporciona las herramientas necesarias para **gestionar y comunicar nodos** dentro del entorno distribuido de Elixir.

## Módulo Node

El módulo `Node` ofrece funciones para trabajar con **nodos distribuidos** y facilitar la comunicación entre ellos. Algunas de las más utilizadas son:

- `Node.start/1`: inicia un nodo con un nombre específico.
- `Node.connect/1`: establece una conexión con otro nodo en la red.
- `Node.list/0`: devuelve la lista de nodos actualmente conectados.
- `Node.self/0`: obtiene el nombre del nodo actual.

Gracias a estas funciones, es posible construir **sistemas distribuidos** en Elixir donde los procesos se comunican y colaboran de forma transparente, sin importar si se encuentran en el mismo equipo o en distintos dispositivos conectados a la red.

## Ejemplo de uso de Node

Vamos a crear dos nodos y hacer que se comuniquen entre sí. La idea es tener un nodo que envía un mensaje y otro que lo recibe. La diferencia respecto a los ejemplos anteriores es que ahora los procesos se pueden ejecutar de manera distribuida.

### Versión 1 (iex)

En esta versión, abrimos iex en dos terminales independientes y escribimos los comandos directamente en cada una. No es lo más práctico, pero es útil para entender cómo funciona la comunicación entre nodos.

#### 1. Iniciar dos nodos

En una terminal, ejecutamos:

```bash
iex --sname nodo1 
```

En otra terminal, ejecutamos:

```bash
iex --sname nodo2
```

Es importante que los nombres de los nodos sean únicos en la red para evitar conflictos.

La bandera `--sname` permite asignar un nombre corto al nodo, que es útil para nodos en la misma máquina. Si los nodos están en diferentes máquinas, se puede usar `--name` para asignar un nombre completo con el formato `nombre@host`.

#### 2. Creación del proceso que recibe mensajes

En la terminal donde está `nodo2`, ejecutamos el siguiente código para recibir el mensaje:

```elixir
# Se crea un proceso con un nombre propio
Process.register(self(), :proceso_en_nodo2)

IO.puts("Nodo iniciado correctamente: #{Node.self()}")
IO.puts("Esperando mensajes...")

# Esperar y recibir mensajes
receive do
  {:mensaje, msg} -> IO.puts("Recibido en nodo 2: #{msg}")
end
```

El `nodo2` será un receptor de mensajes. El proceso creado se registra con el nombre `:proceso_en_nodo2` para que pueda ser referenciado desde otros nodos.

#### 3. Enviar un mensaje desde otro nodo

En la terminal donde está `nodo1`, ejecutamos el siguiente código para conectarnos a `nodo2` y enviarle un mensaje:

```elixir
Node.connect(:"nodo2@tu_maquina") # Reemplaza 'tu_maquina' con el nombre de tu máquina
send({:proceso_en_nodo2, :"nodo2@tu_maquina"}, {:mensaje, "Hola desde nodo 1"})
``` 

Para saber el nombre de `tu_maquina`, fíjese en la consola del `nodo2`, donde dice: `Nodo iniciado correctamente: nodo2@tu_maquina`.

#### 4. Verificar la comunicación

En la terminal de `nodo2`, debería ver el mensaje recibido:

```
Recibido en nodo 2: Hola desde nodo 1
```

El `nodo2` solo recibe un mensaje y luego termina. Si desea enviar más mensajes, debe ejecutar nuevamente el bloque `receive` o crear un bucle para mantener el proceso activo.

Tenga en cuenta que, para que esto funcione, **ambos nodos deben estar en la misma red** y ser capaces de comunicarse entre sí. No necesariamente deben estar en la misma máquina, pero sí deben poder resolver los nombres de los nodos entre sí.

### Versión 2 (scripts)

En lugar de escribir los comandos directamente en la consola, podemos crear archivos `.exs` para cada nodo y ejecutarlos. Además, se mejora la recepción de mensajes para que el nodo receptor pueda seguir escuchando indefinidamente.

#### 1. Código para nodo1 (`nodo1.exs`)

Cree un archivo llamado `nodo1.exs` con el siguiente contenido:

```elixir
defmodule Cliente do
  def main do
    # Inicia el nodo en modo distribuido con un nombre corto
    {:ok, _} = Node.start(:nodo1@localhost, :shortnames)

    # Establece la cookie (debe coincidir con la del nodo2)
    Node.set_cookie(:mi_cookie)

    # Intentar conectarse al nodo2
    if Node.connect(:nodo2@localhost) do
      IO.puts("Conectado a nodo2@localhost correctamente")
    else
      IO.puts("No se pudo conectar a nodo2@localhost")
    end

    # Enviar mensaje al proceso remoto
    send({:proceso_en_nodo2, :nodo2@localhost}, {:mensaje, "Hola desde nodo1"})

    IO.puts("Mensaje enviado a nodo2")
  end
end

Cliente.main()
``` 

Se organiza el código dentro de un módulo `Cliente` con una función `main` para mayor claridad. No es obligatorio, pero es una buena práctica.

#### 2. Código para nodo2 (`nodo2.exs`)

Cree un archivo llamado `nodo2.exs` con el siguiente contenido:

```elixir
defmodule Servidor do
  def main do
    # Inicia el nodo en modo distribuido con un nombre corto
    {:ok, _} = Node.start(:nodo2@localhost, :shortnames)

    # Establece la cookie para la autenticación entre nodos
    Node.set_cookie(:mi_cookie)

    # Crear un proceso que escuche mensajes
    pid = spawn(fn -> loop() end)

    # Registrar el proceso con un nombre global en este nodo. Esto permite que otros nodos lo encuentren
    Process.register(pid, :proceso_en_nodo2)

    IO.puts("Nodo iniciado correctamente: #{Node.self()}")
    IO.puts("Esperando mensajes...")

    # Mantener el nodo activo
    :timer.sleep(:infinity)
  end

  # Función recursiva para recibir mensajes indefinidamente
  defp loop do
    receive do
      {:mensaje, msg} ->
        IO.puts("Recibido en nodo 2: #{msg}")
        loop()
    end
  end
end

Servidor.main()
```

Se define un módulo `Servidor` con una función `main` que inicia el nodo y crea un proceso que escucha mensajes de forma indefinida utilizando una función recursiva `loop`.

#### 3. Ejecutar los nodos

Luego, en cada terminal (independiente), ejecutamos:

```bash
elixir nodo2.exs
```

y en la otra terminal:

```bash
elixir nodo1.exs
```

#### 4. Verificar la comunicación

En la terminal donde se ejecuta `nodo2.exs`, debería ver el mensaje recibido:

```
Recibido en nodo 2: Hola desde nodo1
```

Y dicho nodo permanecerá activo, esperando más mensajes de manera indefinida.

#### 5. Mejoras

Use variables a nivel de módulo para definir el nombre del nodo y la cookie, evitando repetirlos en varias partes del código.

---

## Comunicación entre nodos

En Elixir (y Erlang), los nodos pueden comunicarse entre sí a través de la red, siempre que compartan la misma **cookie de autenticación** y estén registrados en el **sistema de distribución** (*epmd*) de la máquina virtual BEAM.

Cada nodo tiene un nombre que lo identifica de forma única en el clúster, y este nombre puede ser **corto** o **completo** (también llamados *shortnames* y *longnames*).

**Nombres cortos** (`:nodo1`, `:nodo2`)

Se utilizan cuando los nodos se ejecutan **en la misma máquina**. Son más simples y cómodos para entornos locales o de desarrollo.

**Nombres completos** (`:nodo1@host1`, `:nodo2@host2`)

Se utilizan cuando los nodos se ejecutan **en máquinas diferentes** conectadas por red. En este caso, la parte después del `@` (`host1`, `host2`) corresponde al **nombre del host** o la **dirección IP** de cada máquina, lo que permite a la BEAM ubicar y establecer la comunicación entre ellas.

---

## Ejercicio 1

Se desea simular cuatro actividades independientes llamadas (A, B, C y D), los tiempos en milisegundos que tarda cada tarea son: 2500, 1500, 500 y 3500 respectivamente para las cuatro actividades. Se requiere que las actividades se ejecuten de manera secuencial y luego de manera concurrente. Imprima un mensaje indicando cuándo inicia y cuándo termina cada actividad, así como el tiempo total que tarda en ejecutarse cada enfoque (secuencial y concurrente).

## Ejercicio 2

Se desea crear una aplicación distribuida en Elixir que permita a los usuarios enviar mensajes de varios nodos clientes a un nodo servidor central. El nodo servidor recibe mensajes con el siguiente formato: 

- `{:mayusculas, msg}`: Convierte el mensaje a mayúsculas y lo devuelve.
- `{:minusculas, msg}`: Convierte el mensaje a minúsculas y lo devuelve.
- `{:palindroma, msg}`: Verifica si el mensaje es un palíndromo y devuelve true o false.
- `{:contar_vocales, msg}`: Cuenta el número de vocales en el mensaje y lo devuelve.

El nodo servidor debe manejar múltiples solicitudes de manera concurrente y devolver las respuestas a los nodos clientes correspondientes. Los nodos clientes deben poder enviar mensajes al nodo servidor y recibir las respuestas de manera asíncrona.

Además, hay un mensaje especial que finaliza la comunicación: `:fin`. Cuando el nodo servidor recibe este mensaje, le responde al nodo cliente con `:adios` y termina la comunicación con ese cliente.

Pruebe la aplicación creando al menos dos nodos clientes (si puede en máquinas diferentes) que envíen diferentes tipos de mensajes al nodo servidor y muestren las respuestas recibidas.

---

## Más allá: OTP

En esta guía trabajamos con procesos "a mano" usando `spawn`, `send`, `receive` y `Task`. Sin embargo, en aplicaciones reales esto puede volverse complejo y propenso a errores.

En aplicaciones reales, Elixir recomienda usar **OTP** (Open Telecom Platform), que provee:

- **GenServer**: procesos con estado encapsulado y callbacks.
- **Supervisores**: reinician procesos automáticamente si fallan.
- **Árboles de supervisión**: estructuras jerárquicas de procesos tolerantes a fallos.

Esto es lo que permite a aplicaciones hechas en Elixir ser **altamente concurrentes y resilientes**. En futuras clases profundizaremos en OTP y sus componentes.


---

## Para la próxima clase

- Leer sobre OTP y GenServer en la documentación oficial de Elixir: https://hexdocs.pm/elixir/GenServer.html
- Investigar qué es un Agente en Elixir y cómo se utiliza: https://hexdocs.pm/elixir/Agent.html
- Qué es un Supervisor y cómo ayuda a manejar fallos en procesos: https://hexdocs.pm/elixir/Supervisor.html