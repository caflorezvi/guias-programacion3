<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script> 
<script> 
  document.addEventListener("DOMContentLoaded", function() { mermaid.initialize({ startOnLoad: true }); }); 
</script>

```
Universidad del Quindío
Programa de Ingeniería de Sistemas y Computación
Programación III - Procesos
Docente: Carlos Andrés Florez V.
```

# Procesos

En este documento se explican los conceptos básicos sobre los procesos en elixir y cómo manejarlos. Además, se incluyen ejemplos prácticos para ilustrar su uso.

## ¿Qué es un proceso?

En sistemas operativos, un proceso es un programa en ejecución que tiene su propio espacio de memoria y recursos asignados.

En **Elixir (y Erlang)**, aunque usamos la misma palabra, los procesos no son procesos del sistema operativo, sino **procesos ligeros gestionados por la máquina virtual BEAM**. 

Esto significa que:

- Son mucho más baratos de crear y destruir que los procesos del SO.
- Pueden escalar hasta miles o incluso millones de procesos concurrentes.
- Cada proceso tiene su propio estado y se comunica exclusivamente mediante paso de mensajes.

## Creación de procesos

En Elixir, los procesos se crean utilizando la función `spawn/1` o `spawn/3`. La función `spawn/1` toma una función anónima como argumento y crea un nuevo proceso que ejecuta esa función. La función `spawn/3` permite especificar un módulo, una función y una lista de argumentos para crear el proceso. 

**Sin argumentos**

Aquí hay un ejemplo de cómo crear un proceso utilizando `spawn/1`:

```elixir
defmodule MiModulo do
  def mi_funcion do
    IO.puts("Hola desde el proceso!")
  end
end

spawn(fn -> MiModulo.mi_funcion() end)
``` 

No es obligatorio usar una función anónima, también se puede pasar directamente la función si no tiene argumentos:

```elixir
spawn(&MiModulo.mi_funcion/0) # Ejecuta una función que se llama mi_funcion y no recibe argumentos
```

**Con argumentos**

Si la función requiere argumentos, se puede utilizar `spawn/3` como se muestra a continuación:

```elixir
defmodule MiModulo do
  def mi_funcion_con_argumento(arg) do
    IO.puts("Hola desde el proceso con argumento: #{arg}")
  end
end

spawn(MiModulo, :mi_funcion_con_argumento, ["Elixir"])
```

Se pueden crear múltiples procesos de esta manera, y cada uno se ejecutará de forma concurrente. Pero se debe tener en cuenta que hay un proceso principal que es el que inicia la ejecución del programa y crea los demás procesos. Si el proceso principal termina, todos los procesos hijos también terminarán. 

## ¿Qué es concurrencia?

La concurrencia es la capacidad de un sistema para ejecutar múltiples tareas o procesos al mismo tiempo. En Elixir, la concurrencia se logra mediante la creación y gestión de procesos ligeros que pueden ejecutarse de manera independiente y simultánea. Esto permite aprovechar mejor los recursos del sistema y mejorar el rendimiento de las aplicaciones.

Si llamo múltiples veces a `spawn/1` o `spawn/3`, se crearán múltiples procesos que se ejecutarán de manera concurrente. Cada proceso tendrá su propio espacio de memoria y estado, lo que permite que se ejecuten de forma independiente sin interferir entre sí.

Cada proceso tiene un identificador único llamado PID (Process Identifier), que se utiliza para referenciar y comunicarse con ese proceso. Por ejemplo, si creo múltiples procesos utilizando `spawn/1`, puedo obtener sus PID de la siguiente manera:

```elixir
pid1 = spawn(MiModulo, :mi_funcion_con_argumento, ["Elixir"])
IO.puts("El PID del proceso es: #{inspect(pid1)}")

pid2 = spawn(MiModulo, :mi_funcion_con_argumento, ["Erlang"])
IO.puts("El PID del proceso es: #{inspect(pid2)}")
```

## Comunicación entre procesos

Los procesos en Elixir pueden comunicarse entre sí utilizando **mensajes**. Cada proceso tiene una cola de mensajes donde puede recibir mensajes de otros procesos. Para enviar un mensaje a otro proceso, se utiliza la función `send/2`, que toma el PID (identificador del proceso) del proceso receptor y el mensaje que se desea enviar. El proceso receptor puede recibir mensajes utilizando la construcción `receive`, que bloquea la ejecución del proceso hasta que llegue un mensaje.

### Diagrama de comunicación entre procesos

Este diagrama ilustra cómo dos procesos pueden comunicarse entre sí mediante el envío y recepción de mensajes:

<div class="mermaid" style="text-align: center;">
sequenceDiagram
    participant A as Proceso A PID 0.50
    participant B as Proceso B PID 0.51
    participant Console as Terminal/Console
    
    Note over A,B: Comunicación asíncrona
    
    A->>B: send(pidB, {:msg, "Hola"})
    Note right of B: Mensaje almacenado en mailbox<br/>[{:msg, "Hola"}]
    
    Note over B: Proceso B ejecuta receive
    activate B
    B->>B: receive do<br/>{:msg, txt} -> IO.puts(txt)<br/>end
    Note right of B: Coincide el patrón {:msg, txt}<br/>txt = "Hola"
    
    B->>Console: IO.puts("Hola")
    Console-->>B: ok
    Note right of Console: Imprime: Hola
    
    Note right of B: Mailbox ahora vacío: []<br/>receive completado
    deactivate B
    
    Note over B: Proceso B queda esperando próximo mensaje
</div>

El código que implementa este diagrama es el siguiente:

```elixir
# Definir task1 para recibir mensajes
task1_pid = spawn(fn ->
  receive do
    {:mensaje, msg} ->
      IO.puts("Ha recibido este mensaje: #{msg}")
  end
end)

# Se enviar un mensaje a task1
send(task1_pid, {:mensaje, "Hola, desde la tarea 2"})

# Mostrar mensaje de completado. Se imprime cuando el proceso principal termina.
IO.puts("Todas las tareas han terminado")
```

La comunicación entre procesos es asíncrona, lo que significa que el proceso que envía el mensaje no espera a que el proceso receptor lo reciba. Esto permite una mayor concurrencia y eficiencia en la ejecución de los procesos. 

La comunicación asíncrona es especialmente útil en sistemas distribuidos, donde los procesos pueden estar ejecutándose en diferentes nodos de una red. Por ejemplo, cuando chateamos con alguien a través de una aplicación de mensajería, los mensajes se envían y reciben de manera asíncrona, lo que permite que ambos usuarios continúen utilizando la aplicación sin interrupciones.

## Módulo Task

El módulo `Task` en Elixir proporciona una forma sencilla de crear y manejar procesos concurrentes. Permite ejecutar funciones de manera asíncrona y obtener resultados cuando estén disponibles. Sus funciones más comunes son:

- `Task.async/1`: Crea un nuevo proceso que ejecuta una función de manera asíncrona y devuelve un struct `Task` que contiene el PID del proceso.
- `Task.await/2`: Espera a que el proceso asociado al struct `Task` termine y devuelve su resultado. Si el proceso no termina en el tiempo especificado, se lanza una excepción.

Aquí hay un ejemplo de cómo usar el módulo `Task`:

```elixir
# Crear un proceso asíncrono
task = Task.async(fn ->
  :timer.sleep(2000)  # Simula una tarea que toma tiempo
  42  # Retorna un valor
end)

# Hacer otras cosas mientras la tarea se ejecuta
IO.puts("Haciendo otras cosas...")

# Obtener el resultado de la tarea cuando esté listo. Esto bloquea el proceso principal hasta que la tarea termine.
result = Task.await(task)
IO.puts("El resultado de la tarea es: #{result}")
```

Si no se llama a `Task.await/1`, el proceso principal puede terminar antes de que la tarea haya completado su ejecución, lo que podría resultar en que el resultado de la tarea nunca se obtenga. Por lo tanto, es importante asegurarse de esperar el resultado de la tarea si se necesita.

### Diagrama de concurrencia con Task

Este diagrama ilustra cómo el proceso principal crea múltiples tareas que se ejecutan en paralelo y luego espera a que todas terminen para recolectar sus resultados:

<div class="mermaid" style="text-align: center;">
graph TD
    M[Proceso Principal<br/>spawn tasks concurrently]
    
    subgraph Tasks["Tareas Ejecutándose"]
        T1[Task 1<br/>PID 0.125.0<br/>Task.async fn ->]
        T2[Task 2<br/>PID 0.126.0<br/>Task.async fn ->]
        T3[Task 3<br/>PID 0.127.0<br/>Task.async fn ->]
        Tn[Task N<br/>PID 0.12X.0<br/>Task.async fn ->]
    end
    
    R[Recolección de Resultados<br/>Task.await_many tasks]
    
    Final[Proceso Principal<br/>Resultados Completos]
    
    M -.-> T1
    M -.-> T2
    M -.-> T3
    M -.-> Tn
    
    T1 --> R
    T2 --> R
    T3 --> R
    Tn --> R
    
    R --> Final
    
    style M fill:#e1f5fe
    style T1 fill:#fff3e0
    style T2 fill:#fff3e0
    style T3 fill:#fff3e0
    style Tn fill:#fff3e0
    style R fill:#f3e5f5
    style Final fill:#e8f5e8
</div>

A continuación, se presentan algunos ejemplos prácticos que ilustran el uso de procesos y concurrencia en Elixir utilizando tanto `spawn` como el módulo `Task`.

### Ejemplo 1

En este ejemplo, se crean dos funciones, tarea1 y tarea2, que se ejecutan de manera concurrente utilizando `Task.async/1`. La función `tarea1` simula una tarea que toma tiempo utilizando `:timer.sleep/1`, mientras que la función `tarea2` simplemente imprime un mensaje. El proceso principal continúa ejecutándose mientras las tareas están en progreso y finalmente espera el resultado de `tarea1` utilizando `Task.await/1`.

```elixir
defmodule Ejemplo do

    def tarea1 do
        :timer.sleep(2000)  # Simula una tarea que toma tiempo
        42  # Retorna un valor
    end
    
    def tarea2 do
        IO.puts("Tarea 2 ejecutándose...")
    end
    
    def ejecutar_tareas do
        task1 = Task.async(&tarea1/0) # Se ejecuta tarea1 en un proceso separado
        task2 = Task.async(&tarea2/0) # Se ejecuta tarea2 en otro proceso separado
    
        IO.puts("Haciendo otras cosas...") # El proceso principal puede hacer otras cosas mientras las tareas están en progreso
    
        result1 = Task.await(task1) # Espera a que la tarea 1 termine y obtiene su resultado
        IO.puts("El resultado de la tarea 1 es: #{result1}")
    
        Task.await(task2)  # Espera a que la tarea 2 termine (aunque no retorna nada)
    end

end

Ejemplo.ejecutar_tareas()
```

### Ejemplo 2

En este ejemplo creamos múltiples tareas en un bucle y las ejecutamos tanto de manera secuencial como concurrente para comparar los tiempos de ejecución y resultados.

```elixir
defmodule EjemploMultiplesTareas do

    def tarea(n) do
        :timer.sleep(1000 * n)  # Simula una tarea que toma tiempo
        n * n  # Retorna el cuadrado del número
    end

    def ejecutar_secuncialmente do
        numeros = [1, 2, 3, 4, 5]
        resultados = Enum.map(numeros, fn n -> tarea(n) end) # Ejecuta las tareas secuencialmente
        IO.puts("Los resultados de las tareas son: #{inspect(resultados)}")
    end

    def ejecutar_concurrentemente do
        numeros = [1, 2, 3, 4, 5]
        
        tasks = Enum.map(numeros, fn n ->
            Task.async(fn -> tarea(n) end) # Crea una tarea para cada número
        end)
    
        resultados = Enum.map(tasks, &Task.await/1) # Espera a que todas las tareas terminen y obtiene sus resultados
        IO.puts("Los resultados de las tareas son: #{inspect(resultados)}")
    end

end
```

### Ejemplo 3

En este ejemplo, se muestra cómo dos procesos pueden comunicarse entre sí utilizando `send/2` y `receive`. El proceso 1 espera recibir un mensaje del proceso 2, y una vez que lo recibe, envía una confirmación de vuelta al proceso 2.

```elixir
defmodule EjemploComunicacion do
  @moduledoc """
    Ejemplo de comunicación entre procesos en Elixir usando send y receive
  """

  @doc """
    Proceso 1 recibe un mensaje y envía una confirmación
  """
  def proceso1 do
    receive do
      {:mensaje, msg, pid} ->
        IO.puts "Proceso 1 recibió el mensaje: #{msg}"
        send(pid, :confirmacion)
    end
  end

  @doc """
    Proceso 2 envía un mensaje a proceso 1 y espera confirmación
  """
  def proceso2(pid) do
    send(pid, {:mensaje, "Hola desde proceso 2", self()})

    receive do
      :confirmacion ->
        IO.puts "Proceso 2 recibió confirmación de proceso 1"
    end
  end

  @doc """
    Iniciar procesos 1 y 2
  """
  def iniciar do
    # Iniciar proceso 1
    task1 = Task.async(fn -> proceso1() end)
    # Iniciar proceso 2 y enviar pid de proceso 1
    task2 = Task.async(fn -> proceso2(task1.pid) end)

    # Esperar a que ambos procesos terminen
    Task.await(task1)
    Task.await(task2)
  end
end

EjemploComunicacion.iniciar()
```

## Comparativa spawn vs Task

Tanto `spawn` como `Task` se utilizan para crear procesos en Elixir, pero tienen algunas diferencias clave:

| Característica              | `spawn`                          | `Task`                                       |
| --------------------------- | -------------------------------- | -------------------------------------------- |
| **Nivel de abstracción**    | Bajo nivel: solo crea procesos   | Alto nivel: pensado para tareas              |
| **Manejo de errores**       | El proceso muere en silencio     | Los errores se propagan al creador           |
| **Obtención de resultados** | Manual, con `send/receive`       | Directa, con `Task.await`                    |
| **Funciones extra**         | Ninguna                          | `async_stream`, integración con supervisores |
| **Uso recomendado**         | Casos avanzados con control fino | La mayoría de situaciones prácticas          |

## Módulo Node

El módulo `Node` en Elixir proporciona funciones para trabajar con nodos distribuidos en una red. Permite conectar y comunicar procesos entre diferentes nodos de la máquina virtual BEAM. Algunas de las funciones más comunes del módulo `Node` incluyen:

- `Node.start/1`: Inicia un nodo con un nombre específico.
- `Node.connect/1`: Conecta el nodo actual a otro nodo en la red.
- `Node.list/0`: Devuelve una lista de nodos conectados.
- `Node.self/0`: Devuelve el nombre del nodo actual.

Gracias a `Node`, es posible crear aplicaciones distribuidas en Elixir, donde los procesos pueden comunicarse y compartir datos entre diferentes nodos de manera transparente, los nodos pueden estar en la misma máquina o en diferentes máquinas conectadas a través de una red. 

## Ejemplo de uso de Node

Vamos a crear dos nodos y hacer que se comuniquen entre sí. Para esto, abrimos dos terminales y hacemos lo siguiente:


### 1. Iniciar dos nodos

En una terminal, ejecutamos:

```bash
iex --sname nodo1 
```

En otra terminal, ejecutamos:

```bash
iex --sname nodo2
```

Es importante que los nombres de los nodos sean únicos en la red para evitar conflictos.

La bandera `--sname` permite asignar un nombre corto al nodo, que es útil para nodos en la misma máquina. Si los nodos están en diferentes máquinas, se puede usar `--name` para asignar un nombre completo con el formato `nombre@host`.

### 2. Creación del proceso que recibe mensajes

En la terminal donde está `nodo2`, ejecutamos el siguiente código para recibir el mensaje:

```elixir
pid = spawn(fn ->
  receive do
    {:mensaje, msg} -> IO.puts("Recibido en nodo2: #{msg}")
  end
end)
Process.register(pid, :proceso_en_nodo2)
```

El `nodo2` será un receptor de mensajes. El proceso creado se registra con el nombre `:proceso_en_nodo2` para que pueda ser referenciado desde otros nodos.

### 3. Enviar un mensaje desde otro nodo

En la terminal donde está `nodo1`, ejecutamos el siguiente código para conectarnos a `nodo2` y enviarle un mensaje:

```elixir
Node.connect(:nodo2@tu_maquina) # Reemplaza 'tu_maquina' con el nombre de tu máquina
send({:proceso_en_nodo2, :nodo2@tu_maquina}, {:mensaje, "Hola desde nodo1"})
``` 

>⚠️ **Importante:** Para saber el nombre de `tu_maquina`, puede usar `Node.self()` en la terminal de `nodo2`. 

### 4. Verificar la comunicación

En la terminal de `nodo2`, debería ver el mensaje recibido:

```bash
Recibido en nodo2: Hola desde nodo1
```

Para que esto funcione, ambos nodos deben estar en la misma red y ser capaces de comunicarse entre sí. No necesariamente deben estar en la misma máquina, pero sí deben poder resolver los nombres de los nodos entre sí.

>⚠️ **Nota:** Para finalizar los nodos, simplemente se puede usar `Ctrl + C` dos veces en cada terminal o cerrar la terminal directamente.

### 5. Usar scripts en lugar de escribir en la consola

En lugar de escribir los comandos directamente en la consola, podemos crear archivos `.exs` para cada nodo y ejecutarlos.

#### Código para nodo1 (`nodo1.exs`)

```elixir
# nodo1.exs
Node.start(:nodo1)
Node.set_cookie(:nodo1, :mi_cookie) # Se recomienda usar cookies para autenticar nodos

Node.connect(:nodo2@tu_maquina) # Reemplaza 'tu_maquina con el nombre de tu máquina
send({:proceso_en_nodo2, :nodo2@tu_maquina}, {:mensaje, "Hola desde nodo1"})
``` 

#### Código para nodo2 (`nodo2.exs`)

```elixir
# nodo2.exs
Node.start(:nodo2)
Node.set_cookie(:nodo2, :mi_cookie) # Usar la misma cookie para autenticar nodos

pid = spawn(fn ->
  receive do
    {:mensaje, msg} -> IO.puts("Recibido en nodo2: #{msg}")
  end
end)

Process.register(pid, :proceso_en_nodo2)
:timer.sleep(:infinity) # Mantener el nodo activo para recibir mensajes, si no lo escribimos, el proceso termina inmediatamente ya que no hay más código que ejecutar.
```

Luego, en cada terminal, ejecutamos:

```bash
elixir nodo2.exs
```

y en la otra terminal:

```bash
elixir nodo1.exs
```

De esta manera, podemos automatizar la creación y comunicación entre nodos sin necesidad de escribir los comandos manualmente en la consola.

---

## Más allá: OTP

En esta guía trabajamos con procesos "a mano" usando `spawn`, `send`, `receive` y `Task`. Sin embargo, en aplicaciones reales esto puede volverse complejo y propenso a errores.

En aplicaciones reales, Elixir recomienda usar **OTP** (Open Telecom Platform), que provee:

- **GenServer**: procesos con estado encapsulado y callbacks.
- **Supervisores**: reinician procesos automáticamente si fallan.
- **Árboles de supervisión**: estructuras jerárquicas de procesos tolerantes a fallos.

Esto es lo que permite a aplicaciones hechas en Elixir ser **altamente concurrentes y resilientes**. En futuras clases profundizaremos en OTP y sus componentes.

---

## Ejercicio 1

Se desea simular cuatro actividades independientes llamadas (A, B, C y D), los tiempos en milisegundos que tarda cada tarea son: 2500, 1500, 500 y 3500 respectivamente para las cuatro actividades. Se requiere que las actividades se ejecuten de manera secuencial y luego de manera concurrente, para comparar los tiempos de ejecución. 

## Ejercicio 2

Se tiene un archivo con millones de números enteros, uno por línea. Se desea buscar un número específico en el archivo y contar cuántas veces aparece. Para optimizar el proceso, se decide dividir el archivo en partes iguales y asignar cada parte a un proceso diferente para que realice la búsqueda de manera concurrente. Al final, se suman los resultados de todos los procesos para obtener el conteo total.

## Ejercicio 3

Se desea crear una aplicación distribuida en Elixir que permita a los usuarios enviar mensajes de varios nodos clientes a un nodo servidor central. El nodo servidor recibe mensajes con el siguiente formato: 

- `{:mayusculas, msg}`: Convierte el mensaje a mayúsculas y lo devuelve.
- `{:minusculas, msg}`: Convierte el mensaje a minúsculas y lo devuelve.
- `{:palindroma, msg}`: Verifica si el mensaje es un palíndromo y devuelve true o false.
- `{:contar_vocales, msg}`: Cuenta el número de vocales en el mensaje y lo devuelve.

El nodo servidor debe manejar múltiples solicitudes de manera concurrente y devolver las respuestas a los nodos clientes correspondientes. Los nodos clientes deben poder enviar mensajes al nodo servidor y recibir las respuestas de manera asíncrona.

Además, hay un mensaje especial que finaliza la comunicación: `:fin`. Cuando el nodo servidor recibe este mensaje, le responde al nodo cliente con `:adios` y termina la comunicación con ese cliente.

---

## Para la próxima clase

- Leer sobre OTP y GenServer en la documentación oficial de Elixir: https://hexdocs.pm/elixir/GenServer.html
- Investigar qué es un Agente en Elixir y cómo se utiliza: https://hexdocs.pm/elixir/Agent.html
- Qué es un Supervisor y cómo ayuda a manejar fallos en procesos: https://hexdocs.pm/elixir/Supervisor.html