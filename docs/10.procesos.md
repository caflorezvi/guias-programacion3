<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script> 
<script> 
  document.addEventListener("DOMContentLoaded", function() { mermaid.initialize({ startOnLoad: true }); }); 
</script>

```
Universidad del Quindío
Programa de Ingeniería de Sistemas y Computación
Programación III - Procesos
Docente: Carlos Andrés Florez V.
```

# Procesos

En este documento se explican los conceptos básicos sobre los procesos en elixir y cómo manejarlos. Además, se incluyen ejemplos prácticos para ilustrar su uso.

## ¿Qué es un proceso?

En los **sistemas operativos**, un **proceso** es un programa en ejecución que posee su propio espacio de memoria y los recursos necesarios para funcionar. Cada proceso es **independiente** y puede ejecutarse de forma **concurrente** con otros.

Por ejemplo, un sistema operativo es capaz de **gestionar la ejecución concurrente** de distintos programas, como un reproductor de música, un navegador web y un editor de texto, garantizando que cada uno disponga de los recursos necesarios sin interferir con los demás.

## ¿Qué es concurrencia?

La concurrencia es la **capacidad de un sistema para gestionar múltiples tareas o procesos al mismo tiempo**, compartiendo los recursos disponibles. Por ejemplo, en un sistema operativo, la concurrencia permite que varios programas se ejecuten *simultáneamente en apariencia*, alternando su uso de la CPU.

Por su parte, el **paralelismo** se refiere a la **ejecución real y simultánea de múltiples tareas**, aprovechando la existencia de **varios procesadores o núcleos**. En este caso, cada tarea se ejecuta literalmente al mismo tiempo en diferentes unidades de procesamiento. Por ejemplo, en un computador con varios núcleos, un núcleo puede procesar datos mientras otro renderiza gráficos, logrando así una ejecución verdaderamente paralela.

> ⚠️ La diferencia clave entre concurrencia y paralelismo radica en que la **concurrencia** se enfoca en la gestión eficiente de múltiples tareas, mientras que el **paralelismo** se centra en la ejecución simultánea de esas tareas.

## Procesos en Elixir

En **Elixir (y Erlang)** también se utiliza el concepto de *proceso*, aunque no se refiere a procesos del sistema operativo, sino a **procesos ligeros gestionados por la máquina virtual BEAM**.

Esto implica que:

* Son mucho más **ligeros** que los procesos del sistema operativo.
* Pueden escalar hasta **miles o incluso millones** de procesos concurrentes.
* Están **completamente aislados**: no comparten memoria.
* Se **comunican mediante el envío de mensajes** (`send` y `receive`).
* Si uno falla, **no afecta a los demás**, lo que otorga alta **tolerancia a fallos**.

Gracias a estas características, Elixir resulta especialmente adecuado para construir **sistemas concurrentes y distribuidos**, como servidores web, aplicaciones de mensajería o sistemas que requieren alta disponibilidad.

## Creación de procesos en Elixir

Al ejecutar un programa en Elixir, se crea automáticamente un **proceso principal**, encargado de iniciar la ejecución del código. Todo el programa se ejecuta inicialmente dentro de este proceso, que actúa como punto de partida para el resto de la aplicación. Sin embargo, Elixir permite **crear procesos adicionales** que pueden ejecutar tareas de forma **concurrente** y **aislada**, sin interferir ni bloquear al proceso principal.

Esta capacidad de dividir el trabajo entre varios procesos permite aprovechar mejor los recursos del sistema y brindar una experiencia más fluida al usuario.

### Ejemplo básico de creación de procesos

A continuación, se presentan algunas formas de crear procesos en Elixir mediante las funciones `spawn/1` y `spawn/3`.

**Ejemplo con `spawn/1`:**

Aunque no es necesario definir un módulo para crear un proceso, es una buena práctica para organizar el código. Aquí hay un ejemplo simple:

```elixir
defmodule MiModulo do
  def mi_funcion do
    IO.puts("Hola desde el proceso hijo!")
  end
end

IO.puts("Iniciando proceso...")
spawn(fn -> MiModulo.mi_funcion() end) # Se crea un proceso
``` 

Ejecute este código y verá que el mensaje del proceso hijo se imprime en la consola. El proceso principal continúa su ejecución sin esperar a que el proceso hijo termine.

**Ejemplo con `spawn/3`:**

Otra forma de crear procesos es utilizar `spawn/3` como se muestra a continuación:

```elixir
defmodule MiModulo do
  def mi_funcion(arg) do
    IO.puts("Hola desde el proceso hijo!")
    IO.puts("Argumento recibido: #{arg}")
  end
end

IO.puts("Iniciando proceso...")
spawn(MiModulo, :mi_funcion, ["Elixir"]) # Se crea un proceso
```

Hace lo mismo que el ejemplo anterior, solo cambia es la forma de llamar a la función. Esta forma es útil cuando se desea llamar a una función específica de un módulo con argumentos.

### Proceso principal y procesos hijos

Como se mencionó anteriormente, existe un **proceso principal**, encargado de iniciar la ejecución del programa y de generar los demás procesos. Cuando este proceso principal finaliza, **todos los procesos hijos también terminan**, ya que dependen de él para mantenerse en ejecución.

En los ejemplos anteriores, dado que el **proceso hijo no realiza una tarea costosa**, no hay inconveniente, pues alcanza a completarse antes de que el proceso principal termine. Sin embargo, si el proceso hijo ejecuta una tarea que requiere más tiempo, es posible que no logre finalizarla antes de que el proceso principal concluya, lo que puede producir resultados inesperados.

Por ejemplo:

```elixir
defmodule MiModulo do
  def mi_funcion do
    :timer.sleep(2000)  # Simula una tarea que toma tiempo
    IO.puts("Hola desde el proceso hijo después de 2 segundos!")
  end
end

IO.puts("Iniciando proceso...")
spawn(fn -> MiModulo.mi_funcion() end) # Se crea un proceso
IO.puts("Proceso principal finalizado.")
```

Ejecute este código y observe el comportamiento.

En este caso, es probable que el mensaje del proceso hijo no se imprima, ya que el **proceso principal termina antes de que el proceso hijo complete su tarea**. Para evitar esto, se puede agregar una pausa en el proceso principal para darle tiempo al proceso hijo de completarse. Modifique el código anterior agregando `:timer.sleep(3000)` justo antes de imprimir "Proceso principal finalizado." y vuelva a ejecutar el código para ver la diferencia.

## Identificadores de procesos (PIDs)

Cada proceso tiene un **identificador único llamado PID** (*Process Identifier*), que se utiliza para referenciar y comunicarse con ese proceso. La función `spawn` devuelve el PID del proceso creado, lo que permite almacenarlo en una variable para futuras interacciones.

Por ejemplo, al crear varios procesos, se pueden obtener sus PIDs de la siguiente manera:

```elixir
pid1 = spawn(MiModulo, :mi_funcion, ["Elixir"])
IO.puts("El PID del proceso es: #{inspect(pid1)}")

pid2 = spawn(MiModulo, :mi_funcion, ["Erlang"])
IO.puts("El PID del proceso es: #{inspect(pid2)}")
```

Asimismo, se puede obtener el identificador del proceso actual (PID) mediante la función `self/0`:

```elixir
defmodule MiModulo do
  def mi_funcion(numero) do
    IO.inspect(self(), label: "Ejecuto la tarea #{numero}") # Muestra el PID del proceso actual
  end
end

# Se muestra el PID del proceso principal
IO.inspect(self(), label: "Proceso principal")

# Crear dos procesos hijos cada uno con su propio PID
spawn(fn -> MiModulo.mi_funcion(1) end)
spawn(fn -> MiModulo.mi_funcion(2) end)
```

Ejecute este código y observe cómo **cada proceso tiene un PID diferente**, lo que indica que son procesos **independientes** que se ejecutan de manera **concurrente**. Pruebe creando más procesos y observe sus PID únicos.

---

## Comunicación entre procesos

Los procesos en Elixir pueden comunicarse entre sí utilizando **mensajes**. Cada proceso tiene una **cola de mensajes** (*mailbox*) donde puede recibir mensajes de otros procesos. Para enviar un mensaje a otro proceso, se utiliza la función `send/2`, que toma el PID (identificador del proceso) del proceso receptor y el mensaje que se desea enviar. El proceso receptor puede recibir mensajes utilizando la construcción `receive`, que bloquea la ejecución del proceso hasta que llegue un mensaje.

### Diagrama de comunicación entre procesos

Este diagrama ilustra cómo dos procesos pueden comunicarse entre sí mediante el envío y recepción de mensajes:

<div class="mermaid" style="text-align: center;">
sequenceDiagram
    participant A as Proceso A PID 0.50
    participant B as Proceso B PID 0.51
    participant Console as Terminal/Console
    
    Note over A,B: Comunicación asíncrona
    
    A->>B: send(pidB, {:msg, "Hola"})
    Note right of B: Mensaje almacenado en mailbox<br/>[{:msg, "Hola"}]
    
    Note over B: Proceso B ejecuta receive
    activate B
    B->>B: receive do<br/>{:msg, txt} -> IO.puts(txt)<br/>end
    Note right of B: Coincide el patrón {:msg, txt}<br/>txt = "Hola"
    
    B->>Console: IO.puts("Hola")
    Console-->>B: ok
    Note right of Console: Imprime: Hola
    
    Note right of B: Mailbox ahora vacío: []<br/>receive completado
    deactivate B
    
    Note over B: Proceso B finaliza su ejecución
</div>

La comunicación entre procesos **es asíncrona**, lo que significa que el proceso que envía el mensaje no espera a que el proceso receptor lo reciba. Esto permite una mayor concurrencia y eficiencia en la ejecución de los procesos. 

### Ejemplo básico de comunicación entre procesos

El siguiente ejemplo implementa el código del diagrama anterior, en el que un proceso envía un mensaje a otro proceso que lo recibe e imprime en la consola:

```elixir
# Definir task1 para recibir mensajes
task1_pid = spawn(fn ->
  receive do # Espera a recibir un mensaje
    {:mensaje, msg} -> # Si coincide el patrón, imprime el mensaje
      IO.puts("Mensaje recibido: #{msg}")
  end
end)

# Se enviar un mensaje a task1, pero el proceso principal no espera a que se reciba
send(task1_pid, {:mensaje, "Hola desde el proceso principal"})

# Mostrar mensaje de completado. Se imprime cuando el proceso principal termina.
IO.puts("Todas las tareas han terminado")
```

Ejecute este código y observe cómo el proceso principal envía un mensaje al proceso `task1`, que lo recibe e imprime en la consola. En este ejemplo, el proceso hijo solo espera recibir un mensaje y luego termina su ejecución.

### Ejemplo de proceso receptor que recibe múltiples mensajes

Si se desea que un proceso reciba múltiples mensajes, se puede utilizar un **bucle recursivo** dentro del proceso receptor para seguir esperando mensajes indefinidamente. Aquí hay un ejemplo:

```elixir
# Se define un módulo Receiver con una función start que crea un proceso receptor
defmodule Receiver do
  def start do
    spawn(fn -> loop() end) # Crea un proceso que ejecuta la función loop
  end

  defp loop do
    receive do
      {:mensaje, msg} ->
        IO.puts("Mensaje recibido: #{msg}")
        loop() # vuelve a esperar otro mensaje
      :stop ->
        IO.puts("Proceso detenido")
        :ok # termina el proceso
    end
  end
end

# Crear el proceso receptor
pid = Receiver.start()

# Enviar múltiples mensajes al proceso receptor
send(pid, {:mensaje, "Hola 1"})
send(pid, {:mensaje, "Hola 2"})
send(pid, {:mensaje, "Hola 3"})
send(pid, :stop)
```

Ejecute este código y observe cómo el proceso receptor puede recibir múltiples mensajes y procesarlos uno tras otro. El proceso tiene su `mailbox` donde almacena los mensajes recibidos hasta que los procesa.

---

## Módulo Task

El módulo `Task` en Elixir proporciona una forma sencilla de crear y manejar procesos concurrentes. Permite ejecutar funciones de manera asíncrona y obtener resultados cuando estén disponibles. Sus funciones más comunes son:

- `Task.async/1`: Crea un nuevo proceso que ejecuta una función de manera asíncrona y devuelve un struct `Task` que contiene el PID del proceso.
- `Task.await/2`: Espera a que el proceso asociado al struct `Task` termine y devuelve su resultado. Si el proceso no termina en el tiempo especificado, se lanza una excepción.

Aquí hay un ejemplo de cómo usar el módulo `Task`:

```elixir
# Crear un proceso asíncrono
task = Task.async(fn ->
  :timer.sleep(2000)  # Simula una tarea que toma tiempo
  42  # Retorna un valor
end)

# Hacer otras cosas mientras la tarea se ejecuta
IO.puts("Haciendo otras cosas...")

# Obtener el resultado de la tarea cuando esté listo. Esto bloquea el proceso principal hasta que la tarea termine.
result = Task.await(task)
IO.puts("El resultado de la tarea es: #{result}")
```

Si no se llama a `Task.await/1`, el proceso principal puede terminar antes de que la tarea haya completado su ejecución, lo que podría resultar en que el resultado de la tarea nunca se obtenga. Por lo tanto, es **importante asegurarse de esperar** el resultado de la tarea si se necesita.

Ejecute este código y observe cómo el proceso principal continúa ejecutándose mientras la tarea está en progreso, y luego espera el resultado de la tarea antes de imprimirlo.

### Diagrama de concurrencia con Task

Este diagrama ilustra cómo el proceso principal puede crear múltiples tareas que se ejecutan en paralelo y luego espera a que todas terminen para recolectar sus resultados:

<div class="mermaid" style="text-align: center;">
graph TD
    M[Proceso Principal<br/>spawn tasks concurrently]
    
    subgraph Tasks["Tareas Ejecutándose"]
        T1[Task 1<br/>PID 0.125.0<br/>Task.async fn ->]
        T2[Task 2<br/>PID 0.126.0<br/>Task.async fn ->]
        T3[Task 3<br/>PID 0.127.0<br/>Task.async fn ->]
        Tn[Task N<br/>PID 0.12X.0<br/>Task.async fn ->]
    end
    
    R[Recolección de Resultados<br/>Task.await_many tasks]
    
    Final[Proceso Principal<br/>Resultados Completos]
    
    M -.-> T1
    M -.-> T2
    M -.-> T3
    M -.-> Tn
    
    T1 --> R
    T2 --> R
    T3 --> R
    Tn --> R
    
    R --> Final
    
    style M fill:#e1f5fe
    style T1 fill:#fff3e0
    style T2 fill:#fff3e0
    style T3 fill:#fff3e0
    style Tn fill:#fff3e0
    style R fill:#f3e5f5
    style Final fill:#e8f5e8
</div>

A continuación, se presentan algunos ejemplos prácticos que ilustran el uso de procesos y concurrencia en Elixir utilizando tanto `spawn` como el módulo `Task`.

### Ejemplo 1

En este ejemplo, se crean dos funciones, `tarea1` y `tarea2`, que se ejecutan de manera concurrente utilizando `Task.async/1`. Cada tarea simula una operación que toma tiempo utilizando `:timer.sleep/1`. El proceso principal continúa ejecutándose mientras las tareas están en progreso y luego espera a que ambas tareas terminen para obtener sus resultados.

```elixir
defmodule Ejemplo do
  # Simula una tarea que tarda en completarse
  def tarea1 do
    IO.puts("[Tarea 1] Iniciando proceso largo...")
    :timer.sleep(3000)  # Simula una operación que toma tiempo
    "[Tarea 1] Proceso completado exitosamente"
  end

  # Simula otra tarea más rápida
  def tarea2 do
    IO.puts("[Tarea 2] Ejecutándose...")
    :timer.sleep(1000)
    "[Tarea 2] Finalizó correctamente"
  end

  # Ejecuta ambas tareas de forma concurrente
  def ejecutar_tareas do
    IO.puts("Iniciando tareas concurrentes...\n")

    # Lanza ambas tareas en procesos separados
    task1 = Task.async(&tarea1/0)
    task2 = Task.async(&tarea2/0)

    IO.puts("El proceso principal sigue ejecutándose mientras las tareas trabajan...\n")

    # Espera los resultados (bloquea hasta que cada tarea termine)
    result1 = Task.await(task1)
    result2 = Task.await(task2)

    IO.puts("\n--- Resultados ---")
    IO.puts(result1)
    IO.puts(result2)
  end
end

Ejemplo.ejecutar_tareas()
```

### Ejemplo 2

En este ejemplo creamos múltiples tareas en un bucle y las ejecutamos tanto de manera secuencial como concurrente para comparar los tiempos de ejecución y resultados.

```elixir
defmodule EjemploMultiplesTareas do
  # Simula una tarea que toma tiempo y devuelve un mensaje
  def tarea(n) do
    IO.puts("[Tarea #{n}] Iniciando...")
    :timer.sleep(1000 * n)  # Simula una operación costosa
    IO.puts("[Tarea #{n}] Finalizó después de #{n} segundos")
    "Resultado de la tarea #{n}: #{n * n}"
  end

  # Ejecuta las tareas una por una (de forma secuencial)
  def ejecutar_secuencialmente do
    IO.puts("\n=== Ejecución Secuencial ===")

    numeros = [1, 2, 3, 4, 5]

    # Ejecutar cada tarea una por una
    resultados = Enum.map(numeros, fn n -> tarea(n) end)

    IO.puts("\nResultados finales (secuencial):")
    IO.inspect(resultados)
  end

  # Ejecuta todas las tareas al mismo tiempo (de forma concurrente)
  def ejecutar_concurrentemente do
    IO.puts("\n=== Ejecución Concurrente ===")

    numeros = [1, 2, 3, 4, 5]

    # Lanzar todas las tareas en procesos separados
    tasks = Enum.map(numeros, fn n -> Task.async(fn -> tarea(n) end) end)

    # Esperar los resultados de todas las tareas. Evita bloquear el proceso principal.
    resultados = Enum.map(tasks, fn task -> Task.await(task) end)

    IO.puts("\nResultados finales (concurrente):")
    IO.inspect(resultados)
  end
end
```

Analice el código anterior y estime el tiempo que tomaría cada enfoque. Luego, ejecute ambas funciones para observar la diferencia en los tiempos de ejecución y los resultados obtenidos.

### Ejemplo 3

En este ejemplo, se muestra cómo dos procesos pueden comunicarse entre sí utilizando el módulo `Task`, sin necesidad de usar `send` ni `receive` directamente. Aquí, el Proceso 2 envía un mensaje al Proceso 1 y espera una respuesta utilizando `Task.async` y `Task.await`.

```elixir
defmodule EjemploComunicacionTask do
  @moduledoc """
  Ejemplo de comunicación entre dos procesos en Elixir usando `Task`,
  conservando dos procesos independientes (Proceso 1 y Proceso 2) sin usar `send` ni `receive`.
  """

  # === Proceso 1 ===
  # Recibe un mensaje, lo procesa y retorna una confirmación.
  def proceso1(msg) do
    IO.puts("[Proceso 1] Recibió mensaje: #{msg}")
    :timer.sleep(500)
    IO.puts("[Proceso 1] Procesamiento completado.")
    "Confirmación desde Proceso 1: mensaje recibido correctamente."
  end

  # === Proceso 2 ===
  # Envía un mensaje a Proceso 1 y espera la respuesta.
  def proceso2 do
    IO.puts("[Proceso 2] Enviando mensaje a Proceso 1...")

    # Lanza proceso 1 como una tarea asíncrona
    task1 = Task.async(fn -> proceso1("¡Hola desde Proceso 2!") end)

    # Espera la respuesta del proceso 1 (bloqueante hasta 3 segundos)
    respuesta = Task.await(task1, 3000)

    IO.puts("[Proceso 2] Recibió respuesta: #{respuesta}")
    IO.puts("[Proceso 2] Finalizando ejecución.")
  end

  # === Proceso principal ===
  # Inicia ambos procesos de forma controlada.
  def iniciar do
    IO.puts("=== Iniciando comunicación entre procesos ===\n")

    # Lanzamos el proceso 2 (quien a su vez invoca al proceso 1)
    task2 = Task.async(fn -> proceso2() end)

    # Esperamos a que Proceso 2 termine completamente
    Task.await(task2)

    IO.puts("\n=== Comunicación finalizada ===")
  end
end

# Ejecutar el ejemplo
EjemploComunicacionTask.iniciar()
```

### Ejemplo 4: Uso de after en receive

Haga un nuevo script que cree dos procesos: uno que envíe un mensaje y otro que lo reciba e imprima y le envíe una confirmación de vuelta al proceso emisor. Para este ejemplo use `spawn`, `send`, `receive` y `after`. No use `Task`.

Investigue cómo usar `after` en la construcción `receive` para manejar casos en los que no se recibe ningún mensaje en un tiempo determinado. El bloque `after` **evita que los procesos queden bloqueados indefinidamente** esperando un mensaje que podría no llegar.

Si creamos tareas que no deben quedar esperando para siempre, es una buena práctica usar `after` para definir un tiempo máximo de espera. Por otro lado, si un proceso puede recibir mensajes en cualquier momento y no queremos que termine, podemos usar un **bucle recursivo** para mantenerlo activo.

## Comparativa spawn vs Task

Tanto `spawn` como `Task` se utilizan para crear procesos en Elixir, pero tienen algunas diferencias clave:

| Característica              | `spawn`                          | `Task`                                       |
| --------------------------- | -------------------------------- | -------------------------------------------- |
| **Nivel de abstracción**    | Bajo nivel: solo crea procesos   | Alto nivel: pensado para tareas              |
| **Manejo de errores**       | El proceso muere en silencio     | Los errores se propagan al creador           |
| **Obtención de resultados** | Manual, con `send/receive`       | Directa, con `Task.await`                    |
| **Funciones extra**         | Ninguna                          | `async_stream`, integración con supervisores |
| **Uso recomendado**         | Casos avanzados con control fino | La mayoría de situaciones prácticas          |

---

## Para la próxima clase

- Investigar sobre aplicaciones distribuidas en Elixir y cómo los procesos pueden comunicarse a través de nodos. Puede leer sobre el módulo `Node` en la documentación oficial de Elixir: [https://hexdocs.pm/elixir/Node.html](https://hexdocs.pm/elixir/Node.html).
- Leer sobre redes locales, direcciones IP y comunicación entre máquinas para entender mejor los sistemas distribuidos.