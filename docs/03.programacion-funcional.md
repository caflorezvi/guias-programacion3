```
Universidad del Quindío
Programa de Ingeniería de Sistemas y Computación
Programación III - Programación Funcional
Docente: Carlos Andrés Florez V.
```

# Programación funcional

La **programación funcional** es un paradigma de programación perteneciente al **paradigma declarativo**, en el cual el desarrollo del software se enfoca en expresar **qué** resultado se quiere obtener, en lugar de explicar paso a paso **cómo** lograrlo. Este enfoque se fundamenta en el uso de **funciones puras** y **datos inmutables**, lo que promueve un código más expresivo y predecible.

A diferencia de los paradigmas imperativos, la programación funcional evita la modificación de variables y estados globales. En su lugar, los programas se construyen mediante la transformación de datos a través de funciones, minimizando los efectos secundarios. Esto contribuye a facilitar la depuración, las pruebas y el mantenimiento del código.

La inmutabilidad y la ausencia de efectos secundarios hacen que la programación funcional sea especialmente adecuada para entornos **concurrentes y distribuidos**, en los que se deben evitar conflictos derivados del acceso simultáneo a recursos compartidos.

Entre los lenguajes funcionales más representativos se encuentran **Haskell**, **Lisp**, **Erlang** y **Elixir**. En este curso nos enfocaremos en **Elixir**, un lenguaje funcional que se ejecuta sobre la máquina virtual de Erlang (BEAM) y que destaca por su capacidad para desarrollar aplicaciones concurrentes, distribuidas y de alto rendimiento.

## Principios de la Programación Funcional

A continuación, se presentan los principios fundamentales de la programación funcional, ilustrados con ejemplos en Elixir:

### 1. Inmutabilidad

Los datos no cambian una vez que se crean. En lugar de modificar estructuras existentes, se crean nuevas versiones con los cambios aplicados. Esto reduce errores relacionados con efectos secundarios y hace el código más predecible.

**Ejemplo 1**:

```elixir
a = 10
a = a + 5  # Aquí no se modifica 'a', sino que se crea una nueva variable 'a' con el nuevo valor.
IO.puts(a) # Imprime 15
```

Cuando se asigna un nuevo valor a `a`, en realidad se está creando una nueva variable `a` que apunta al nuevo valor (15), mientras que la variable original `a` (con valor 10) ya no está accesible. Nunca se modifica el valor original.

**Ejemplo 2**:

```elixir
lista_original = [1, 2, 3]
nueva_lista = lista_original ++ [4]  # Se crea una nueva lista
IO.inspect(lista_original)   # Imprime [1, 2, 3]
IO.inspect(nueva_lista)      # Imprime [1, 2, 3, 4]
```

En este ejemplo, `lista_original` permanece sin cambios, y `nueva_lista` es una nueva lista que incluye el elemento adicional.

La inmutabilidad es especialmente útil en **entornos concurrentes**, ya que evita problemas de sincronización y condiciones de carrera. Esto lo estudiaremos más a fondo en las próximas clases.

### 2. Funciones Puras

Una función es pura si:

- Siempre devuelve el mismo resultado para los mismos argumentos
- No tiene efectos secundarios (no modifica variables externas)
- En Elixir todas las funciones son **puras por defecto**.
  
Esto facilita la depuración y las pruebas unitarias. Por ejemplo:

```elixir
def suma(x, y) do
  x + y
end
```

Toda función en Elixir comienza con `def`, seguida del nombre de la función y sus parámetros entre paréntesis. El cuerpo de la función se encuentra entre `do` y `end`. 

Esta función siempre devolverá el mismo resultado para los mismos valores de `x` e `y`, y no afecta ninguna variable externa.

En Elixir, la **última expresión evaluada** en el cuerpo de la función es el valor que se devuelve automáticamente, por lo que no es necesario usar una palabra clave `return`.

### 3. Expresiones Lambda

Son funciones anónimas que pueden almacenarse en variables o pasarse como argumentos.

**Ejemplo**:

```elixir
suma = fn (x, y) -> x + y end
IO.puts(suma.(3, 4))  # Imprime 7
```

Una expresión lambda se define con `fn`, seguida de los parámetros entre paréntesis, el operador `->`, y el cuerpo de la función en una sola línea terminada con `end`. Para llamar a una función anónima, se utiliza el operador `.` seguido de los argumentos entre paréntesis.

Hay otra forma de definir funciones anónimas usando el operador `&`:

```elixir
suma = &(&1 + &2)
IO.puts(suma.(3, 4))  # Imprime 7
```

En este caso, `&1` y `&2` representan los primeros y segundos argumentos respectivamente.

### 4. Funciones de Orden Superior

Las funciones pueden recibir otras funciones como parámetros o devolver funciones como resultado.

Ejemplo:

```elixir
def aplicar_funcion(func, valor) do
  func.(valor)
end

IO.puts(aplicar_funcion(fn x -> x * 2 end, 5))  # Imprime 10
```

Las funciones son **ciudadanos de primera clase**, lo que significa que pueden ser tratadas como cualquier otro valor (asignadas a variables, pasadas como argumentos, etc.). Observe que en el ejemplo anterior, la función anónima `fn x -> x * 2 end` se pasa como argumento a la función `aplicar_funcion`. Esta función luego la invoca con el valor `5`, resultando en `10`.

### 5. Evaluación Perezosa (Lazy Evaluation)

Los valores y expresiones solo se calculan cuando realmente se necesitan. Permite trabajar con estructuras potencialmente infinitas y optimiza el rendimiento. Es especialmente útil en el manejo de archivos grandes. Más adelante veremos ejemplos prácticos de este concepto.

### 6. Composición de Funciones

En lugar de usar estructuras de control tradicionales, se combinan funciones pequeñas para crear funciones más complejas. En Elixir, esto se puede lograr utilizando el **operador de tubería o pipe** (`|>`), que permite encadenar funciones de manera clara y concisa.

Ejemplo:

```elixir
def doble(x), do: x * 2
def cuadrado(x), do: x * x

resultado = 3 |> doble() |> cuadrado()
IO.puts(resultado)  # Imprime 36
```

El número `3` se pasa primero a la función `doble`, y luego el resultado de `doble(3)` se pasa a la función `cuadrado`. Internamente, esto es equivalente a `cuadrado(doble(3))`, pero la sintaxis con tuberías es más legible y clara.

También observe que para funciones de una sola línea, Elixir permite usar la sintaxis `do:` para definirlas de manera más concisa.

> ⚠️ **Importante:** Se profundizará en estos conceptos en las próximas clases, ya que son la base de la programación funcional.

---

## Actividad

Pruebe los ejemplos anteriores en Visual Studio Code (VS Code) o en el intérprete interactivo (IEx) y haga modificaciones para entender mejor cómo funcionan.

---

## Para la próxima clase
- Investigar qué es un módulo en Elixir.
- Investigar qué tipos de datos existen en Elixir.
- Investigar qué operadores se utilizan con más frecuencia en Elixir.