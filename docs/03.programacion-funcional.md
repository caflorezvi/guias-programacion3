```
Universidad del Quindío
Programa de Ingeniería de Sistemas y Computación
Programación III - Programación Funcional
Docente: Carlos Andrés Florez V.
```

# Programación funcional

La **programación funcional** es un paradigma de programación perteneciente al **paradigma declarativo**, en el cual el desarrollo del software se enfoca en expresar **qué** resultado se quiere obtener, en lugar de explicar paso a paso **cómo** lograrlo. Este enfoque se fundamenta en el uso de **funciones puras** y **datos inmutables**, lo que promueve un código más expresivo y predecible.

A diferencia de los paradigmas imperativos, la programación funcional evita la modificación de variables y estados globales. En su lugar, los programas se construyen mediante la transformación de datos a través de funciones, minimizando los efectos secundarios. Esto contribuye a facilitar la depuración, las pruebas y el mantenimiento del código.

La inmutabilidad y la ausencia de efectos secundarios hacen que la programación funcional sea especialmente adecuada para entornos **concurrentes y distribuidos**, en los que se deben evitar conflictos derivados del acceso simultáneo a recursos compartidos.

Entre los lenguajes funcionales más representativos se encuentran **Haskell**, **Lisp**, **Erlang** y **Elixir**. En este curso nos enfocaremos en **Elixir**, un lenguaje funcional que se ejecuta sobre la máquina virtual de Erlang (BEAM) y que destaca por su capacidad para desarrollar aplicaciones concurrentes, distribuidas y de alto rendimiento.

## Principios de la Programación Funcional

A continuación, se presentan los principios fundamentales de la programación funcional, ilustrados con ejemplos en Elixir:

### 1. Inmutabilidad

La inmutabilidad es uno de los pilares fundamentales de la programación funcional. Un dato inmutable es aquel que no puede ser modificado una vez que ha sido creado. En lugar de modificar estructuras existentes, se crean nuevas versiones con los cambios aplicados. Esto reduce errores relacionados con efectos secundarios y hace el código más predecible.

**Ejemplo 1**:

```elixir
a = 10
a = a + 5  # Aquí no se modifica 'a', sino que se crea una nueva variable 'a' con el nuevo valor.
IO.puts(a) # Imprime 15
```

Cuando se asigna un nuevo valor a `a`, en realidad se está creando una nueva variable `a` que apunta al nuevo valor (15), mientras que la variable original `a` (con valor 10) ya no está accesible. Nunca se modifica el valor original.

**Ejemplo 2**:

```elixir
lista_original = [1, 2, 3]
nueva_lista = lista_original ++ [4]  # Se crea una nueva lista
IO.inspect(lista_original)   # Imprime [1, 2, 3]
IO.inspect(nueva_lista)      # Imprime [1, 2, 3, 4]
```

En este ejemplo, `lista_original` permanece sin cambios, y `nueva_lista` es una nueva lista que incluye el elemento adicional.

#### ¿Pero no es esto ineficiente?

Crear nuevos datos constantemente podría parecer un desperdicio de memoria. Sin embargo, los lenguajes funcionales como Elixir son muy inteligentes al respecto y utilizan una técnica llamada **"persistencia de datos"** o **"uso compartido de estructura"**.

Cuando se crea una "nueva" versión de una estructura de datos, Elixir reutiliza internamente la mayor parte de la memoria de la estructura original que no cambió. Esto hace que las operaciones de inmutabilidad sean sorprendentemente rápidas.

#### Beneficios Clave de la Inmutabilidad:
-   **Código Predecible**: Las variables no cambian de valor inesperadamente.
-   **Concurrencia Segura**: Elimina las *race conditions* (dos procesos modificando el mismo dato a la vez), ya que los datos nunca se modifican.
-   **Depuración Sencilla**: Rastrear el origen de un valor es más simple.

La inmutabilidad es especialmente útil en **entornos concurrentes**, ya que evita problemas de sincronización y condiciones de carrera. Esto lo estudiaremos más a fondo en las próximas clases.

### 2. Funciones Puras y Efectos Secundarios

#### Funciones Puras

Una función pura es el ideal en la programación funcional. Cumple dos reglas estrictas:

1.  **Para la misma entrada, siempre devuelve la misma salida.** Su resultado solo depende de sus argumentos.
2.  **No tiene "efectos secundarios" (side effects).** No modifica nada fuera de su propio ámbito.

```elixir
def suma(x, y) do
  x + y
end
```
Las funciones puras son como operaciones matemáticas: `2 + 3` siempre será `5`.

**Nota sobre la sintaxis:**

En Elixir:

- Toda función en Elixir se define con `def` (o `defp` para funciones privadas).
- El cuerpo de la función está delimitado por `do` y `end`.
- Elixir tiene un **retorno implícito**: el valor de la última expresión evaluada en la función es el valor que esta devuelve. No se usa la palabra clave `return`.

Para funciones de una sola línea, Elixir permite una sintaxis más concisa con `do:`. El siguiente código es un ejemplo:   

```elixir
def suma(x, y), do: x + y
```

#### Efectos Secundarios (Side Effects)

Un efecto secundario es cualquier interacción que una función tiene con el "mundo exterior".

**Ejemplos de acciones impuras (con efectos secundarios):**
-   Escribir en la consola (`IO.puts`).
-   Leer o escribir un archivo (`File.read`).
-   Enviar mensajes a otros procesos.
-   Generar números aleatorios. Dado que el resultado varía en cada llamada, no es una función pura.
-   Obtener la hora actual del sistema.

Un programa útil **debe** tener efectos secundarios. El objetivo de la FP no es eliminarlos, sino **aislarlos**. La estrategia es construir el núcleo de la lógica con funciones puras y empujar las acciones impuras a los "bordes" del programa.

### 3. Funciones como Ciudadanos de Primera Clase

En Elixir, las funciones son valores, como los números o las cadenas. Esto significa que pueden ser asignadas a variables, pasadas como argumentos a otras funciones y devueltas como resultado.

#### Funciones Anónimas (Lambdas)

Son funciones que no tienen un nombre, creadas sobre la marcha. Son muy útiles para pasarlas como argumento a otras funciones.

Hay dos sintaxis principales:

**Ejemplo 1: La sintaxis `fn ... end`:**

```elixir
suma = fn (x, y) -> x + y end
IO.puts(suma.(3, 4))  # Imprime 7
```

Aquí, `fn` inicia la definición, `(a, b)` son los parámetros, `->` separa la firma del cuerpo, y `a + b` es la expresión que se evalúa y retorna.

**Ejemplo 2: La sintaxis `&` (operador de captura):**

Es una forma más corta para funciones simples. `&1`, `&2`, etc., representan el primer, segundo, etc., argumento.

```elixir
suma = &(&1 + &2)
IO.puts(suma.(3, 4))  # Imprime 7
```

> ⚠️ **Nota:** Ambas formas son válidas y pueden usarse según la preferencia y la complejidad de la función. Se recomienda practicar con ambas para entender sus ventajas.

#### Funciones de Orden Superior (Higher-Order Functions)

Son funciones que toman otras funciones como argumentos o que devuelven funciones. 

**Ejemplo 1: Tomando una función como argumento**

En este ejemplo, `aplicar_funcion` recibe una función `func` y un valor `valor`, y aplica `func` a `valor`.

```elixir
def aplicar_funcion(func, valor) do
  func.(valor)
end

IO.puts(aplicar_funcion(fn x -> x * 2 end, 5))  # Imprime 10
```

**Ejemplo 2: Devolviendo una función**

Podemos crear funciones que "fabrican" otras funciones.
```elixir
# Devolvemos una función anónima que "recuerda" el valor de `factor`
def crear(factor) do
  fn numero -> numero * factor end
end

# Usamos `crear` para hacer funciones que multiplican por 2 y por 3
duplicar = crear(2)
triplicar = crear(3)

# Usamos las funciones devueltas para multiplicar números
duplicar.(5)  # => 10
triplicar.(5) # => 15
```

### 4. Composición de Funciones

La programación funcional fomenta la creación de funciones pequeñas y reutilizables. La lógica compleja se construye "componiendo" o encadenando estas funciones.

**Ejemplo 1:**

```elixir
def doble(x), do: x * 2
def cuadrado(x), do: x * x

resultado = 3 |> doble() |> cuadrado()
IO.puts(resultado)  # Imprime 36
```

El número `3` se pasa primero a la función `doble`, y luego el resultado de `doble(3)` se pasa a la función `cuadrado`. Internamente, esto es equivalente a `cuadrado(doble(3))`, pero la sintaxis con tuberías (`|>`) es más legible y clara.

**Ejemplo 2:**

La forma anidada, común en otros lenguajes, es difícil de leer:
```elixir
String.truncate(String.upcase(String.trim("  hola mundo  ")), 10)
```

Elixir resuelve esto con el **operador tubería `|>`**, que pasa el resultado de una expresión como el primer argumento de la siguiente función.

```elixir
resultado_compuesto =
  "  hola mundo  "
  |> String.trim()      # El resultado de trim(...) pasa a la siguiente línea
  |> String.upcase()    # El resultado de upcase(...) pasa a la siguiente línea
  |> String.truncate(10)

# => "HOLA MUNDO"
```
El flujo de datos es lineal y mucho más fácil de seguir.

> ⚠️ **Importante:** Se profundizará en estos conceptos a lo largo de todo el libro, ya que son la base de la programación funcional.

### 5. Evaluación Perezosa (Lazy Evaluation)

Los valores y expresiones solo se calculan cuando realmente se necesitan. Permite trabajar con estructuras potencialmente infinitas y optimiza el rendimiento. Es especialmente útil en el manejo de archivos grandes. Más adelante veremos ejemplos prácticos de este concepto.

---

## Actividad

### Ejercicio 1:

Pruebe cada uno de los ejemplos presentados en este capítulo tanto en Visual Studio Code como en el intérprete interactivo (IEx). Haga modificaciones para experimentar y entender mejor cómo funcionan.

### Ejercicio 2:

Analice las siguientes descripciones de funciones y determine si son puras o impuras. Justifique su respuesta explicando si tienen efectos secundarios.

1.  Una función que recibe dos números y devuelve su suma.
2.  Una función que recibe un nombre de archivo, lee su contenido y devuelve el número de líneas.
3.  Una función que toma un texto, lo escribe en la consola y no devuelve nada.
4.  Una función que recibe una fecha y devuelve el día de la semana correspondiente.
5.  Una función que concatena dos listas y devuelve la nueva lista resultante.

---

## Para la próxima clase
- Investigar qué es un módulo en Elixir.
- Investigar qué tipos de datos existen en Elixir.
- Investigar qué operadores se utilizan con más frecuencia en Elixir.