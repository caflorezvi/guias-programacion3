<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

```
Universidad del QuindÃ­o
Programa de IngenierÃ­a de Sistemas y ComputaciÃ³n
ProgramaciÃ³n III - Recursividad
Docente: Carlos AndrÃ©s Florez V.
```

# Recursividad

La recursividad es una tÃ©cnica de programaciÃ³n en la que **una funciÃ³n se llama a sÃ­ misma** para resolver un problema. Es un concepto fundamental en programaciÃ³n funcional y una herramienta poderosa para trabajar con estructuras de datos como listas, Ã¡rboles y grafos.

## Â¿Por quÃ© Recursividad en la ProgramaciÃ³n Funcional?

En los **lenguajes funcionales** como Elixir, la recursividad es la forma **natural y preferida** de iterar sobre datos porque:

1. **No hay variables mutables**: No podemos usar contadores como `i++` en un `for` loop
2. **Inmutabilidad**: Los datos no cambian, creamos nuevas versiones
3. **Declarativa**: Expresa "quÃ©" hacer, no "cÃ³mo" hacerlo paso a paso
4. **Pattern matching**: Se integra perfectamente con el estilo funcional
5. **Tail Call Optimization**: Elixir optimiza la recursividad de cola automÃ¡ticamente

Considere la recursividad como una **alternativa elegante a los bucles tradicionales** (`for`, `while`) que se encuentran en lenguajes imperativos.

---

## Conceptos clave

- **Caso base**: La condiciÃ³n que **detiene** la recursiÃ³n. Sin caso base, la funciÃ³n se llamarÃ­a indefinidamente causando un desbordamiento de pila (*stack overflow*).

- **Caso recursivo**: La invocaciÃ³n de la funciÃ³n dentro de sÃ­ misma, generalmente con un argumento modificado que **se acerca al caso base**.

- **Progreso hacia el caso base**: Cada llamada recursiva debe acercarnos al caso base, o nunca terminaremos.

---

## La Pila de Llamadas (Call Stack)

Cada vez que una funciÃ³n se llama (recursiva o no), se crea un **marco de pila** (*stack frame*) que contiene:

- **Variables locales** de la funciÃ³n
- **ParÃ¡metros** recibidos
- **DirecciÃ³n de retorno** (dÃ³nde continuar cuando termine)

Cuando una funciÃ³n recursiva se llama a sÃ­ misma, se **apilan mÃºltiples marcos** en la pila. Cada llamada espera a que la siguiente termine para continuar. Cuando la funciÃ³n llega al caso base, las llamadas empiezan a resolverse en orden inverso, devolviendo los resultados a las funciones anteriores. Todo este proceso lo maneja automÃ¡ticamente el entorno de ejecuciÃ³n de Elixir.

>âš ï¸ **Importante:** La pila de llamadas tiene un **tamaÃ±o limitado**. Recursiones muy profundas pueden causar *stack overflow*.

---

## Estado de las Variables

En Elixir, las variables son **inmutables**. Esto significa que:

1. **Cada llamada recursiva tiene su propio contexto** con sus propias variables.
2. Los cambios en una llamada **no afectan** a las llamadas anteriores.
3. Para mantener un valor entre llamadas, debe **pasarse como argumento** en cada invocaciÃ³n.

---

## Ejemplos ClÃ¡sicos de Recursividad

A continuaciÃ³n, se presentan ejemplos tÃ­picos de funciones recursivas y su implementaciÃ³n en Elixir.

### 1. Factorial

El factorial de un nÃºmero se calcula como el producto de todos los enteros positivos desde 1 hasta ese nÃºmero.

$$
n! = n \cdot (n-1) \cdot (n-2) \cdot \cdots \cdot 2 \cdot 1
$$

Su definiciÃ³n formal evidencia su naturaleza recursiva:

$$
n! =
\begin{cases}
1, & \text{si } n = 0, \\
n \cdot (n-1)!, & \text{si } n > 0.
\end{cases}
$$

**ImplementaciÃ³n en Elixir:**

```elixir
defmodule Matematicas do
  # Caso base: el factorial de 0 es 1
  def factorial(0), do: 1
  
  # Caso recursivo: n! = n Ã— (n-1)!
  def factorial(n) when n > 0, do: n * factorial(n - 1)
  
  # Manejo de errores
  def factorial(n) when n < 0 do
    {:error, "El factorial no estÃ¡ definido para nÃºmeros negativos"}
  end
end
```

En este ejemplo, la funciÃ³n `factorial/1` tiene tres clÃ¡usulas:

1. El caso base: `factorial(0)` devuelve 1.
2. La llamada recursiva: `factorial(n - 1)` se llama con un argumento reducido.
3. Manejo de errores para nÃºmeros negativos.

**Traza de ejecuciÃ³n para `factorial(5)`:**

```
factorial(5)
â”‚
â”œâ”€â–º 5 * factorial(4)
â”‚       â”‚
â”‚       â”œâ”€â–º 4 * factorial(3)
â”‚       â”‚       â”‚
â”‚       â”‚       â”œâ”€â–º 3 * factorial(2)
â”‚       â”‚       â”‚       â”‚
â”‚       â”‚       â”‚       â”œâ”€â–º 2 * factorial(1)
â”‚       â”‚       â”‚       â”‚       â”‚
â”‚       â”‚       â”‚       â”‚       â””â”€â–º 1 * factorial(0)
â”‚       â”‚       â”‚       â”‚               â”‚
â”‚       â”‚       â”‚       â”‚               â””â”€â–º 1 (caso base)
â”‚       â”‚       â”‚       â”‚
â”‚       â”‚       â”‚       â””â”€â–º 2 * 1 = 2
â”‚       â”‚       â”‚
â”‚       â”‚       â””â”€â–º 3 * 2 = 6
â”‚       â”‚
â”‚       â””â”€â–º 4 * 6 = 24
â”‚
â””â”€â–º 5 * 24 = 120
```

**AnÃ¡lisis:**
- **Llamadas:** 6 (`factorial(5)` hasta `factorial(0)`)
- **Operaciones pendientes:** Se acumulan en la pila

### 2. Fibonacci

La secuencia de Fibonacci es una serie de nÃºmeros en la que cada nÃºmero es la suma de los dos anteriores. La definiciÃ³n formal de la secuencia es:

$$
F(n) = \begin{cases}
0 & \text{si } n = 0 \\
1 & \text{si } n = 1 \\
F(n-1) + F(n-2) & \text{si } n > 1
\end{cases}
$$

**ImplementaciÃ³n en Elixir:**

```elixir
defmodule Matematicas do
  def fibonacci(0), do: 0
  def fibonacci(1), do: 1
  def fibonacci(n) when n > 1, do: fibonacci(n - 1) + fibonacci(n - 2)
end
```

Tenemos tres clÃ¡usulas en la funciÃ³n `fibonacci/1`:

1. El caso base: `fibonacci(0)` devuelve 0.
2. El caso base: `fibonacci(1)` devuelve 1.
3. La llamada recursiva: `fibonacci(n - 1) + fibonacci(n - 2)` se llama con argumentos reducidos.

**Traza de ejecuciÃ³n para `fibonacci(5)`:**

```
fibonacci(5)
    â”‚
    â”œâ”€â–º fibonacci(4)
    â”‚       â”œâ”€â–º fibonacci(3)
    â”‚       â”‚       â”œâ”€â–º fibonacci(2)
    â”‚       â”‚       â”‚       â”œâ”€â–º fibonacci(1) = 1
    â”‚       â”‚       â”‚       â””â”€â–º fibonacci(0) = 0
    â”‚       â”‚       â””â”€â–º fibonacci(1) = 1
    â”‚       â””â”€â–º fibonacci(2)  â† Â¡Recalculado!
    â”‚               â”œâ”€â–º fibonacci(1) = 1
    â”‚               â””â”€â–º fibonacci(0) = 0
    â””â”€â–º fibonacci(3)  â† Â¡Recalculado!
            â”œâ”€â–º fibonacci(2)  â† Â¡Recalculado!
            â”‚       â”œâ”€â–º fibonacci(1) = 1
            â”‚       â””â”€â–º fibonacci(0) = 0
            â””â”€â–º fibonacci(1) = 1

Resultado: 5
```

Aunque esta implementaciÃ³n es simple y directa, no es la mÃ¡s eficiente debido a la recomputaciÃ³n de valores. MÃ¡s adelante, exploraremos una versiÃ³n optimizada usando recursividad de cola.

Por ejemplo, `fibonacci(40)`: ~102 millones de llamadas y `fibonacci(50)`: mÃ¡s de mil millones de llamadas. Su tiempo de ejecuciÃ³n crece exponencialmente. 

### 3. Potencia

La potencia de un nÃºmero se calcula como el producto de ese nÃºmero por sÃ­ mismo un cierto nÃºmero de veces. La definiciÃ³n formal es:

$$
a^n = \begin{cases}
1 & \text{si } n = 0 \\
a \cdot a^{n-1} & \text{si } n > 0
\end{cases}
$$

**ImplementaciÃ³n en Elixir:**

```elixir
defmodule Matematicas do
  def potencia(_, 0), do: 1 # Caso base
  def potencia(a, n) when n > 0, do: a * potencia(a, n - 1) # Caso recursivo
end
```

La funciÃ³n `potencia/2` tiene dos clÃ¡usulas:

1. El caso base: `potencia(_, 0)` devuelve 1. Ignora la base.
2. La llamada recursiva: `potencia(a, n - 1)` se llama con un argumento reducido.

**Traza para `potencia(2, 4)`:**

```
potencia(2, 4)
â””â”€â–º 2 * potencia(2, 3)
        â””â”€â–º 2 * potencia(2, 2)
                â””â”€â–º 2 * potencia(2, 1)
                        â””â”€â–º 2 * potencia(2, 0)
                                â””â”€â–º 1

Resultado: 2 * 2 * 2 * 2 * 1 = 16
```

### 4. MultiplicaciÃ³n (mediante sumas)

La multiplicaciÃ³n de dos nÃºmeros se puede definir de manera recursiva como la suma repetida de uno de los nÃºmeros. La definiciÃ³n formal es:

$$
mult(a, b) = \begin{cases}
0 & \text{si } b = 0 \\
a + mult(a, b-1) & \text{si } b > 0
\end{cases}
$$

**ImplementaciÃ³n en Elixir:**

```elixir
defmodule Matematicas do
  def multiplicar(_, 0), do: 0
  def multiplicar(a, b) when b > 0, do: a + multiplicar(a, b - 1)
end
```

**Traza para `multiplicar(3, 4)`:**

```
multiplicar(3, 4)
â””â”€â–º 3 + multiplicar(3, 3)
        â””â”€â–º 3 + multiplicar(3, 2)
                â””â”€â–º 3 + multiplicar(3, 1)
                        â””â”€â–º 3 + multiplicar(3, 0)
                                â””â”€â–º 0

Resultado: 3 + 3 + 3 + 3 + 0 = 12
```

---

## Recursividad con Cadenas

La recursividad tambiÃ©n se puede utilizar para manipular cadenas de texto ya que las cadenas son secuencias de caracteres.

### Invertir una cadena

Por ejemplo, podemos implementar una funciÃ³n que invierta una cadena de la siguiente manera:

```elixir
defmodule Cadenas do
  # Caso base: cadena vacÃ­a
  def invertir(""), do: ""
  
  # Caso recursivo
  def invertir(cadena) do
    # Separar Ãºltimo carÃ¡cter del resto
    ultimo = String.last(cadena)
    resto = String.slice(cadena, 0..-2//1) # Obtener todo menos el Ãºltimo carÃ¡cter
    
    # Ãšltimo + invertir(resto)
    ultimo <> invertir(resto)
  end
end
```

**Traza para `invertir("hola")`:**

```
invertir("hola")
â””â”€â–º "a" <> invertir("hol")
            â””â”€â–º "l" <> invertir("ho")
                        â””â”€â–º "o" <> invertir("h")
                                    â””â”€â–º "h" <> invertir("")
                                                â””â”€â–º ""

Resultado: "a" <> "l" <> "o" <> "h" <> "" = "aloh"
```

>**âš ï¸ Nota:** El mÃ³dulo `String` ya cuenta con la funciÃ³n `String.reverse/1` que invierte una cadena de texto de manera eficiente, pero es Ãºtil entender cÃ³mo funciona la recursiÃ³n en este contexto.

### Contar vocales

En este ejemplo, implementamos una funciÃ³n que cuenta el nÃºmero de vocales en una cadena:

```elixir
defmodule Cadenas do
  def contar_vocales(""), do: 0
  
  def contar_vocales(cadena) do
    primer_caracter = String.first(cadena)
    resto = String.slice(cadena, 1..-1//1) # Obtener todo menos el primer carÃ¡cter
    
    if es_vocal?(primer_caracter) do
      1 + contar_vocales(resto)
    else
      contar_vocales(resto)
    end
  end
  
  defp es_vocal?(c), do: c in ["a", "e", "i", "o", "u", "A", "E", "I", "O", "U"]
end
```

**Traza para `contar_vocales("Mundo")`:**

```
contar_vocales("Mundo")
â””â”€â–º contar_vocales("undo")    (M no es vocal)
    â””â”€â–º 1 + contar_vocales("ndo")    (u es vocal)
            â””â”€â–º contar_vocales("do")    (n no es vocal)
                â””â”€â–º 1 + contar_vocales("o")    (d no es vocal)
                        â””â”€â–º 1 + contar_vocales("")    (o es vocal)
                                â””â”€â–º 0
Resultado: 0 + 1 + 0 + 1 + 0 = 2
```

---

## Recursividad con Listas

La recursividad es una tÃ©cnica comÃºn para procesar listas en Elixir. Podemos utilizarla para implementar funciones que operen sobre listas de manera elegante y concisa. Aunque Elixir ya proporciona muchas funciones para trabajar con listas a travÃ©s del mÃ³dulo `Enum`, entender cÃ³mo implementar estas funciones recursivamente es fundamental para dominar la programaciÃ³n funcional.

Las listas son estructuras naturalmente recursivas en Elixir. Recuerde que las listas se representan como `[head | tail]`, donde `head` es el primer elemento de la lista y `tail` es el resto de la lista. Al descomponer la lista de esta manera, `tail` siempre serÃ¡ una lista (incluso si estÃ¡ vacÃ­a), lo que facilita la recursiÃ³n.

### Ejemplo 1: Sumar elementos

Por ejemplo, podemos definir una funciÃ³n que sume todos los elementos de una lista.

```elixir
defmodule Listas do
  def sumar([]), do: 0 # Caso base: la suma de una lista vacÃ­a es 0
  def sumar([head | tail]), do: head + sumar(tail) # Descomponer la lista en cabeza y cola. Se suma el head y se llama recursivamente con el resto de la lista (tail)
end
```

**Traza para `sumar([1, 2, 3])`:**

```
sumar([1, 2, 3])
â””â”€â–º 1 + sumar([2, 3])
        â””â”€â–º 2 + sumar([3])
                â””â”€â–º 3 + sumar([])
                        â””â”€â–º 0

Resultado: 1 + 2 + 3 + 0 = 6
```

### Ejemplo 2: Contar elementos pares

En este otro ejemplo, se cuentan los nÃºmeros de una lista que son pares, se utiliza guardas para verificar si el nÃºmero es par:

```elixir
defmodule Listas do
  def contar_pares([]), do: 0
  def contar_pares([head | tail]) when rem(head, 2) == 0, do: 1 + contar_pares(tail) # Solo se cuenta si el residuo es 0
  def contar_pares([_head | tail]), do: contar_pares(tail) # No se cuenta si es impar, pero se sigue recorriendo la lista
end
```

**Traza para `contar_pares([1, 2, 3, 4, 5])`:**

```
contar_pares([1, 2, 3, 4, 5])
â””â”€â–º contar_pares([2, 3, 4, 5])    (1 es impar, no cuenta)
    â””â”€â–º 1 + contar_pares([3, 4, 5])    (2 es par, cuenta)
            â””â”€â–º contar_pares([4, 5])    (3 es impar, no cuenta)
                â””â”€â–º 1 + contar_pares([5])    (4 es par, cuenta)
                        â””â”€â–º contar_pares([])    (5 es impar, no cuenta)
                            â””â”€â–º 0

Resultado: 1 + 1 + 0 = 2
```

### Ejemplo 3: Encontrar el mÃ¡ximo

En este caso se encuentra el valor mÃ¡ximo en una lista de nÃºmeros, se utiliza un enfoque recursivo para comparar los elementos de la lista.

```elixir
defmodule Listas do
  def maximo([head | tail]), do: maximo(tail, head) # Se inicia la bÃºsqueda con el primer elemento como el mayor

  defp maximo([], mayor), do: mayor # Caso base: si la lista estÃ¡ vacÃ­a, se devuelve el mayor encontrado
  defp maximo([head | tail], mayor) when head > mayor, do: maximo(tail, head) # Si el head es mayor, se actualiza el mayor
  defp maximo([_head | tail], mayor), do: maximo(tail, mayor) # Si no, se sigue con el mismo mayor y se sigue recorriendo la lista
end
```

Este es un ejemplo de cÃ³mo se require un parÃ¡metro adicional para mantener el estado del mayor valor encontrado hasta el momento y evitar el uso de variables globales.

**Traza para `maximo([3, 1, 4, 1, 5, 9])`:**

```
maximo([3, 1, 4, 1, 5, 9])
â””â”€â–º maximo([1, 4, 1, 5, 9], 3)    (3 es el mayor inicial)
    â””â”€â–º maximo([4, 1, 5, 9], 3)    (1 no es mayor)
        â””â”€â–º maximo([1, 5, 9], 4)    (4 es mayor)
            â””â”€â–º maximo([5, 9], 4)    (1 no es mayor)
                â””â”€â–º maximo([9], 5)    (5 es mayor)
                    â””â”€â–º maximo([], 9)    (9 es mayor)
                        â””â”€â–º 9 
Resultado: 9
```

### Ejemplo 4: Filtrar elementos

En este ejemplo, se filtran los elementos de una lista que son mayores a un cierto valor lÃ­mite.

```elixir
defmodule Listas do
  # Caso base: si la lista estÃ¡ vacÃ­a, se devuelve una lista vacÃ­a
  def filtrar_mayores([], _limite), do: [] 
  
  # Caso recursivo: si el head es mayor que el lÃ­mite, se incluye en el resultado
  def filtrar_mayores([head | tail], limite) when head > limite do
    [head | filtrar_mayores(tail, limite)]
  end
  
  # Caso recursivo: si el head no es mayor, se omite y se sigue con el tail
  def filtrar_mayores([_head | tail], limite) do
    filtrar_mayores(tail, limite)
  end
end
```

**Traza para `filtrar_mayores([1, 5, 3, 8, 2], 3)`:**

```
filtrar_mayores([1, 5, 3, 8, 2], 3)
â””â”€â–º filtrar_mayores([5, 3, 8, 2], 3)    (1 no es mayor)
    â””â”€â–º [5 | filtrar_mayores([3, 8, 2], 3)]    (5 es mayor)
        â””â”€â–º filtrar_mayores([8, 2], 3)    (3 no es mayor)
            â””â”€â–º [8 | filtrar_mayores([2], 3)]    (8 es mayor)
                â””â”€â–º filtrar_mayores([], 3)    (2 no es mayor)
                    â””â”€â–º []
Resultado: [5, 8]
```

### Ejemplo 5: Mapear (transformar cada elemento)

Por Ãºltimo, se muestra cÃ³mo implementar una funciÃ³n `map` que aplica una funciÃ³n dada a cada elemento de una lista.

```elixir
defmodule Listas do
  # Caso base: si la lista estÃ¡ vacÃ­a, se devuelve una lista vacÃ­a
  def map([], _funcion), do: []
  
  # Caso recursivo: se aplica la funciÃ³n al head y se sigue con el tail
  def map([head | tail], funcion) do
    [funcion.(head) | map(tail, funcion)]
  end
end
```

**Traza para `map([1, 2, 3], fn x -> x * 2 end)`:**

```
map([1, 2, 3], fn x -> x * 2 end)
â””â”€â–º [2 | map([2, 3], fn x -> x * 2 end)]
    â””â”€â–º [4 | map([3], fn x -> x * 2 end)]
        â””â”€â–º [6 | map([], fn x -> x * 2 end)]
            â””â”€â–º []
Resultado: [2, 4, 6]
```

---

# Recursividad de Cola (Tail Recursion)

La **recursividad de cola** (tail recursion) es un tipo de recursiÃ³n en la que la llamada recursiva es la **Ãºltima instrucciÃ³n** que realiza la funciÃ³n. Esto permite que el compilador o intÃ©rprete haga una optimizaciÃ³n especial llamada tail call optimization (TCO). Gracias a esta optimizaciÃ³n, no se crean nuevos espacios en la pila para cada llamada, sino que se reutiliza el mismo marco de pila. De esta forma se evita que la pila crezca demasiado y se produzca un desbordamiento en casos de recursiÃ³n muy profunda.

Lenguajes como **Elixir** y **Erlang** aplican esta optimizaciÃ³n de forma automÃ¡tica. Otros lenguajes, como **Python** o **Java**, no la implementan, por lo que es importante tener en cuenta las limitaciones de cada lenguaje.

## Â¿Por quÃ© es importante?

### RecursiÃ³n Normal (NO tail-recursive)

```elixir
def factorial(0), do: 1
def factorial(n), do: n * factorial(n - 1)
                      â†‘
                  OperaciÃ³n pendiente despuÃ©s de la llamada
```

**Problema:** Cada llamada debe esperar el resultado de la siguiente para hacer la multiplicaciÃ³n. Se acumulan marcos en la pila.

```
Pila crece â†’

factorial(5)     |  Espera resultado  |
factorial(4)     |  Espera resultado  |
factorial(3)     |  Espera resultado  |
factorial(2)     |  Espera resultado  |
factorial(1)     |  Espera resultado  |
factorial(0) â†’ 1 |  Retorna           |

â† Pila se resuelve
```

### RecursiÃ³n de Cola (tail-recursive)

```elixir
def factorial(n, acum \\ 1)
def factorial(0, acum), do: acum
def factorial(n, acum), do: factorial(n - 1, n * acum)
                           â†‘
                        Ãšltima operaciÃ³n: NO hay nada pendiente
```

**Ventaja:** El compilador puede **optimizar** y reutilizar el mismo marco de pila.

```
factorial(5, 1)   â†’ factorial(4, 5)   (reusa marco)
factorial(4, 5)   â†’ factorial(3, 20)  (reusa marco)
factorial(3, 20)  â†’ factorial(2, 60)  (reusa marco)
factorial(2, 60)  â†’ factorial(1, 120) (reusa marco)
factorial(1, 120) â†’ factorial(0, 120) (reusa marco)
factorial(0, 120) â†’ 120
```

---

## Ejemplos de Tail Recursion

A continuaciÃ³n, se presentan ejemplos de recursividad de cola para las funciones que ya hemos visto.

### 1. Factorial con cola

Usando recursividad de cola, podemos implementar la funciÃ³n factorial de la siguiente manera:

```elixir
defmodule Matematicas do
  # FunciÃ³n pÃºblica: inicia el acumulador
  def factorial(n), do: factorial_tail(n, 1)
  
  # FunciÃ³n privada: tail-recursive
  defp factorial_tail(0, acum), do: acum
  defp factorial_tail(n, acum) when n > 0 do
    factorial_tail(n - 1, n * acum)
  end
end
```

Observe que se ha utilizado un parÃ¡metro `acum` para mantener los cÃ¡lculos intermedios, luego, en el caso base, simplemente devolvemos el valor acumulado. No hay operaciones pendientes despuÃ©s de la llamada recursiva, lo que permite la **optimizaciÃ³n de cola**.

**Traza para `factorial(5)`:**

```
factorial(5, 1)   â†’ factorial(4, 5)
factorial(4, 5)   â†’ factorial(3, 20)
factorial(3, 20)  â†’ factorial(2, 60)
factorial(2, 60)  â†’ factorial(1, 120)
factorial(1, 120) â†’ factorial(0, 120)
factorial(0, 120) â†’ 120
```

Lo interesante de la recursividad de cola es que **no se acumulan llamadas en la pila**, ya que cada llamada puede reutilizar el espacio de la llamada anterior. Esto hace que la recursividad de cola sea mÃ¡s eficiente en tÃ©rminos de uso de memoria.

### 2. Fibonacci eficiente

El algoritmo de Fibonacci que ya vimos tiene un problema, es muy ineficiente para valores grandes de n. Sin embargo, se puede implementar utilizando recursividad de cola de la siguiente manera:

```elixir
defmodule Matematicas do
  def fibonacci(n), do: fibonacci(n, 0, 1) # Se inician los dos primeros nÃºmeros de la secuencia

  defp fibonacci(0, a, _b), do: a # Caso base: si n es 0, se devuelve el primer nÃºmero
  defp fibonacci(n, a, b), do: fibonacci(n - 1, b, a + b) # Se avanza en la secuencia, actualizando los dos Ãºltimos nÃºmeros
end
```

**Traza para `fibonacci(5)`:**

```
fibonacci(5, 0, 1)   â†’ n=5, a=0, b=1
fibonacci(4, 1, 1)   â†’ n=4, a=1, b=1
fibonacci(3, 1, 2)   â†’ n=3, a=1, b=2
fibonacci(2, 2, 3)   â†’ n=2, a=2, b=3
fibonacci(1, 3, 5)   â†’ n=1, a=3, b=5
fibonacci(0, 5, 8)   â†’ n=0, retorna 5
```

En esta implementaciÃ³n no se recalculan valores intermedios, por lo que es mÃ¡s eficiente. AdemÃ¡s, no se acumulan llamadas en la pila.

### 3. Suma de lista con cola

Un ejemplo de recursividad de cola es la funciÃ³n que suma los elementos de una lista acumulando el resultado en un parÃ¡metro adicional:

```elixir
defmodule Listas do
  def sumar(lista), do: sumar(lista, 0)

  defp sumar([], acumulado), do: acumulado
  defp sumar([head | tail], acumulado), do: sumar(tail, head + acumulado)
end
```

**Traza para `sumar([1, 2, 3])`:**

```
sumar([1, 2, 3], 0)   â†’ sumar([2, 3], 1)
sumar([2, 3], 1)      â†’ sumar([3], 3)
sumar([3], 3)         â†’ sumar([], 6)
sumar([], 6)          â†’ 6
``` 

Las sumas intermedias se acumulan en el parÃ¡metro `acumulado`, y no hay operaciones pendientes despuÃ©s de la llamada recursiva.

### 4. Invertir lista (tail-recursive)

Para invertir una lista utilizando recursividad de cola, podemos hacer lo siguiente:

```elixir
defmodule Listas do
  def invertir(lista), do: invertir_tail(lista, [])
  
  defp invertir_tail([], acum), do: acum
  defp invertir_tail([head | tail], acum) do
    invertir_tail(tail, [head | acum])
  end
end
```

**Traza para `invertir([1, 2, 3])`:**

```
invertir_tail([1, 2, 3], [])
invertir_tail([2, 3], [1])
invertir_tail([3], [2, 1])
invertir_tail([], [3, 2, 1])
=> [3, 2, 1]
```

Observe que el resultado se construye en el acumulador `acum`, y no hay operaciones pendientes despuÃ©s de la llamada recursiva.


---

## Ejercicios PrÃ¡cticos

### Nivel BÃ¡sico

1. **Potencia con cola**: Implemente `potencia(base, exp)` usando tail recursion.

2. **MultiplicaciÃ³n con cola**: Implemente `multiplicar(a, b)` usando tail recursion (sumas repetidas).

3. **Invertir cadena**: Implemente `invertir(cadena)` usando tail recursion.

### Nivel Intermedio

4. **DivisiÃ³n entera**: Implemente `dividir(dividendo, divisor)` que retorne `{cociente, residuo}` o `{:error, "DivisiÃ³n por cero"}`. Use restas sucesivas.

5. **Contar ocurrencias**: Implemente `contar(lista, elemento)` que cuente cuÃ¡ntas veces aparece un elemento en una lista.

6. **PalÃ­ndromo**: Implemente `palindromo?(cadena)` que determine si una cadena es palÃ­ndromo.

7. **Contar palabras**: Implemente `contar_palabras(cadena)` que cuente el nÃºmero de palabras en una cadena (separadas por espacios).

### Nivel Avanzado

8. **NÃºmero perfecto**: Implemente `perfecto?(n)` que determine si un nÃºmero es perfecto (igual a la suma de sus divisores propios). Ejemplo: 6 es perfecto porque 1 + 2 + 3 = 6.

9. **Posiciones pares**: Implemente `posiciones_pares(lista)` que retorne una cadena con los elementos en posiciones pares. Ejemplo: `[1, 2, 3, 4, 5]` â†’ `"135"`.

10. **Contar dÃ­gitos**: Implemente `contar_digitos(n)` que cuente los dÃ­gitos de un nÃºmero **sin** convertirlo a string. Use divisiones enteras.

11. **Sumar primos**: Implemente `sumar_primos(lista)` que sume solo los nÃºmeros primos de una lista. Debe incluir una funciÃ³n auxiliar `primo?(n)` recursiva.

12. **MCD (MÃ¡ximo ComÃºn Divisor)**: Implemente el algoritmo de Euclides recursivamente.
    ```
    mcd(a, 0) = a
    mcd(a, b) = mcd(b, rem(a, b))
    ```

### DesafÃ­o

13. **Validador de contraseÃ±a**: Implemente una funciÃ³n que pida al usuario una contraseÃ±a recursivamente hasta que cumpla:
    - Al menos 8 caracteres
    - Al menos una mayÃºscula
    - Al menos un dÃ­gito
    - Al menos un carÃ¡cter especial (`!@#$%&`)
    
    Debe indicar quÃ© criterios no se cumplen y retornar `:ok` cuando sea vÃ¡lida.

14. **Torres de Hanoi**: Implemente el clÃ¡sico problema recursivamente. Investigue este problema, en quÃ© consiste y cÃ³mo se resuelve.

---

## Buenas PrÃ¡cticas

Al implementar funciones recursivas en Elixir, es importante seguir ciertas buenas prÃ¡cticas para asegurar que el cÃ³digo sea eficiente, legible y mantenible.

### 1. Siempre defina el caso base

Lo mÃ¡s importante en una funciÃ³n recursiva es definir un caso base claro para evitar llamadas infinitas.

```elixir
# Malo: falta caso base
def cuenta_regresiva(n) do
  IO.puts(n)
  cuenta_regresiva(n - 1)
end
# Â¡Stack overflow!

# Bueno: con caso base
def cuenta_regresiva(0), do: IO.puts("Â¡Despegue!")
def cuenta_regresiva(n) when n > 0 do
  IO.puts(n)
  cuenta_regresiva(n - 1)
end
```

### 2. Use tail recursion para listas grandes

Se recomienda usar recursividad de cola para evitar desbordamientos de pila con listas grandes.

```elixir
# Malo: puede causar stack overflow con listas grandes
def suma_simple([]), do: 0
def suma_simple([h | t]), do: h + suma_simple(t)

# Bueno: tail-recursive
def suma(lista), do: suma_tail(lista, 0)
defp suma_tail([], acum), do: acum
defp suma_tail([h | t], acum), do: suma_tail(t, h + acum)
```

### 3. Use guards para validaciÃ³n

Una buena prÃ¡ctica es usar guardas para validar entradas y evitar errores en tiempo de ejecuciÃ³n.

```elixir
# Bueno: valida entrada
def factorial(n) when n >= 0 and is_integer(n) do
  factorial_tail(n, 1)
end

def factorial(_) do
  {:error, "Debe ser un entero no negativo"}
end
```

### 4. Considere usar Enum cuando sea apropiado

Claramente, Elixir ofrece muchas funciones en el mÃ³dulo `Enum` que son optimizadas y legibles. Use recursiÃ³n manual solo cuando sea necesario.

```elixir
# RecursiÃ³n manual
def sumar_cuadrados([]), do: 0
def sumar_cuadrados([h | t]), do: h * h + sumar_cuadrados(t)

# Mejor: usando Enum (mÃ¡s legible)
def sumar_cuadrados(lista) do
  lista
  |> Enum.map(&(&1 * &1))
  |> Enum.sum()
end
```

Tenga en cuenta, que aunque `Enum` es muy Ãºtil, entender la recursiÃ³n es fundamental para dominar la programaciÃ³n funcional.

---

## RecursiÃ³n en la Naturaleza

La recursiÃ³n no es exclusiva de la programaciÃ³n; es un **patrÃ³n universal** que aparece en:

### Ejemplos naturales

1. **Ãrboles**: Tronco â†’ ramas â†’ ramas mÃ¡s pequeÃ±as â†’ hojas
2. **RÃ­os**: RÃ­o principal â†’ afluentes â†’ tributarios
3. **Pulmones**: TrÃ¡quea â†’ bronquios â†’ bronquiolos
4. **Fractales**: Patrones que se repiten a diferentes escalas
5. **DNA**: Estructura recursiva de informaciÃ³n genÃ©tica
6. **Costas**: Irregularidades que se repiten a diferentes escalas

### Autosimilaridad

El principio de **autosimilaridad** significa que una estructura compleja estÃ¡ compuesta de versiones mÃ¡s pequeÃ±as de sÃ­ misma:

```
Ãrbol:
    ğŸŒ³
   /â”‚\
  / â”‚ \
 ğŸŒ³ ğŸŒ³ ğŸŒ³  â† Cada rama es un Ã¡rbol mÃ¡s pequeÃ±o
```

La recursiÃ³n captura este patrÃ³n: **resolver lo complejo repitiendo lo simple**.

---

## Para la prÃ³xima clase

### Investigar

1. **RecursiÃ³n vs bucles en lenguajes funcionales**
   - Por quÃ© Elixir prefiere recursiÃ³n
   - Ventajas de inmutabilidad
   - Limitaciones de bucles tradicionales

2. **Problemas con recursiÃ³n profunda**
   - Stack overflow
   - CuÃ¡ndo ocurre
   - CÃ³mo evitarlo

3. **Stream y evaluaciÃ³n perezosa**
   - QuÃ© es lazy evaluation
   - CÃ³mo Stream difiere de Enum
   - Ventajas para datos grandes