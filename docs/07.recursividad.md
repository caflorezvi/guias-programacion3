<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

```
Universidad del Quindío
Programa de Ingeniería de Sistemas y Computación
Programación III - Recursividad
Docente: Carlos Andrés Florez V.
```

# Recursividad

La recursividad es una técnica de programación en la que **una función se llama a sí misma** para resolver un problema. En Elixir, la recursividad es una herramienta poderosa y se utiliza con frecuencia para trabajar con estructuras de datos como listas y árboles.

Considere la recursividad como una **alternativa a los bucles tradicionales** (como `for` o `while`) que se encuentran en otros lenguajes de programación. En los **lenguajes funcionales**, como Elixir, la recursividad es la forma preferida de iterar sobre datos. Por lo tanto, es fundamental entender cómo funciona y cómo implementarla correctamente.

## ¿Por qué Recursividad en la Programación Funcional?

En los **lenguajes funcionales** como Elixir, la recursividad es la forma **natural y preferida** de iterar sobre datos porque:

1. **No hay variables mutables**: No podemos usar contadores como `i++` en un `for` loop
2. **Inmutabilidad**: Los datos no cambian, creamos nuevas versiones
3. **Declarativa**: Expresa "qué" hacer, no "cómo" hacerlo paso a paso
4. **Pattern matching**: Se integra perfectamente con el estilo funcional
5. **Tail Call Optimization**: Elixir optimiza la recursividad de cola automáticamente

Considere la recursividad como una **alternativa elegante a los bucles tradicionales** (`for`, `while`) que se encuentran en lenguajes imperativos.

## Conceptos clave

La recursividad se basa en estos conceptos fundamentales:

- **Caso base**: La condición que **detiene** la recursión. Sin caso base, la función se llamaría indefinidamente causando un desbordamiento de pila (*stack overflow*).

- **Caso recursivo**: La invocación de la función dentro de sí misma, generalmente con un argumento modificado que **se acerca al caso base**.

- **Progreso hacia el caso base**: Cada llamada recursiva debe acercarnos al caso base, o nunca terminaremos.

## La Pila de Llamadas (Call Stack)

Cada vez que una función se llama (recursiva o no), se crea un **marco de pila** (*stack frame*) que contiene:

- **Variables locales** de la función (las definidas dentro de la función)
- **Parámetros** recibidos
- **Dirección de retorno** (dónde continuar cuando termine)

Cuando una función recursiva se llama a sí misma, se **apilan múltiples marcos** en la pila. Cada llamada espera a que la siguiente termine para continuar. Cuando la función llega al caso base, las llamadas empiezan a resolverse en orden inverso, devolviendo los resultados a las funciones anteriores. Todo este proceso lo maneja automáticamente el entorno de ejecución de Elixir.

>⚠️ **Importante:** La pila de llamadas tiene un **tamaño limitado**. Recursiones muy profundas pueden causar *stack overflow*.

## Estado de las Variables

Dado que cada llamada recursiva crea un nuevo marco en la pila, es crucial entender cómo se manejan las variables:

1. **Cada llamada recursiva tiene su propio contexto** con sus propias variables.
2. Los cambios en una llamada **no afectan** a las llamadas anteriores.
3. Para mantener un valor entre llamadas, debe **pasarse como argumento** en cada invocación.

---

## Ejemplos Clásicos de Recursividad

A continuación, se presentan ejemplos típicos de funciones recursivas y su implementación en Elixir.


### 1. Factorial

El factorial de un número se calcula como el producto de todos los enteros positivos desde 1 hasta ese número.

$$
n! = n \cdot (n-1) \cdot (n-2) \cdot \cdots \cdot 2 \cdot 1
$$

Su definición formal evidencia su naturaleza recursiva:

$$
n! =
\begin{cases}
1, & \text{si } n = 0, \\
n \cdot (n-1)!, & \text{si } n > 0.
\end{cases}
$$

**Implementación en Elixir:**

```elixir
defmodule Matematicas do
  # Caso base: el factorial de 0 es 1
  def factorial(0), do: 1
  
  # Caso recursivo: n! = n × (n-1)!
  def factorial(n) when n > 0, do: n * factorial(n - 1)
  
  # Manejo de errores
  def factorial(n) when n < 0 do
    {:error, "El factorial no está definido para números negativos"}
  end
end
```

En este ejemplo, la función `factorial/1` tiene tres cláusulas:

1. El caso base: `factorial(0)` devuelve 1.
2. La llamada recursiva: `factorial(n - 1)` se llama con un argumento reducido.
3. Manejo de errores para números negativos.

**Traza de ejecución para `factorial(5)`:**

```
factorial(5)
├──► 5 * factorial(4)
│    ├──► 4 * factorial(3)
│    │    ├──► 3 * factorial(2)
│    │    │    ├──► 2 * factorial(1)
│    │    │    │    ├──► 1 * factorial(0)
│    │    │    │    │    └──► 1 (caso base)
│    │    │    │    └──► 1 * 1 = 1
│    │    │    └──► 2 * 1 = 2
│    │    └──► 3 * 2 = 6
│    └──► 4 * 6 = 24
└──► 5 * 24 = 120
```

**Análisis:**
- **Llamadas:** 6 (`factorial(5)` hasta `factorial(0)`)
- **Operaciones pendientes:** Se acumulan en la pila
### 2. Fibonacci

La secuencia de Fibonacci es una serie de números en la que cada número es la suma de los dos anteriores. La definición formal de la secuencia es:

$$
F(n) = \begin{cases}
0 & \text{si } n = 0 \\
1 & \text{si } n = 1 \\
F(n-1) + F(n-2) & \text{si } n > 1
\end{cases}
$$

**Implementación en Elixir:**

```elixir
defmodule Matematicas do
  def fibonacci(0), do: 0
  def fibonacci(1), do: 1
  def fibonacci(n) when n > 1, do: fibonacci(n - 1) + fibonacci(n - 2)
end
```

Tenemos tres cláusulas en la función `fibonacci/1`:

1. El caso base: `fibonacci(0)` devuelve 0.
2. El caso base: `fibonacci(1)` devuelve 1.
3. La llamada recursiva: `fibonacci(n - 1) + fibonacci(n - 2)` se llama con argumentos reducidos.

**Traza de ejecución para `fibonacci(5)`:**

```
fibonacci(5)
├──► fibonacci(4)
│    ├──► fibonacci(3)
│    │    ├──► fibonacci(2)
│    │    │    ├──► fibonacci(1) ──► 1
│    │    │    ├──► fibonacci(0) ──► 0
│    │    │    └──► 1 + 0 = 1
│    │    ├──► fibonacci(1) ──► 1
│    │    └──► 1 + 1 = 2
│    ├──► fibonacci(2)
│    │    ├──► fibonacci(1) ──► 1
│    │    ├──► fibonacci(0) ──► 0
│    │    └──► 1 + 0 = 1
│    └──► 2 + 1 = 3
├──► fibonacci(3)
│    ├──► fibonacci(2)
│    │    ├──► fibonacci(1) ──► 1
│    │    ├──► fibonacci(0) ──► 0
│    │    └──► 1 + 0 = 1
│    ├──► fibonacci(1) ──► 1
│    └──► 1 + 1 = 2
└──► 3 + 2 = 5
```

Aunque esta implementación es simple y directa, no es la más eficiente debido a la recomputación de valores (observe cómo `fibonacci(2)` se calcula varias veces). Más adelante, exploraremos una versión optimizada usando recursividad de cola.

Por ejemplo, `fibonacci(40)` realiza aproximadamente 102 millones de llamadas y `fibonacci(50)` más de mil millones. Su tiempo de ejecución crece exponencialmente. 

### 3. Potencia

La potencia de un número se calcula como el producto de ese número por sí mismo un cierto número de veces. La definición formal es:

$$
a^n = \begin{cases}
1 & \text{si } n = 0 \\
a \cdot a^{n-1} & \text{si } n > 0
\end{cases}
$$

**Implementación en Elixir:**

```elixir
defmodule Matematicas do
  def potencia(_, 0), do: 1 # Caso base
  def potencia(a, n) when n > 0, do: a * potencia(a, n - 1) # Caso recursivo
end
```

La función `potencia/2` tiene dos cláusulas:

1. El caso base: `potencia(_, 0)` devuelve 1. Ignora la base.
2. La llamada recursiva: `potencia(a, n - 1)` se llama con un argumento reducido.

**Traza para `potencia(2, 4)`:**

```
potencia(2, 4)
├──► 2 * potencia(2, 3)
│    ├──► 2 * potencia(2, 2)
│    │    ├──► 2 * potencia(2, 1)
│    │    │    ├──► 2 * potencia(2, 0)
│    │    │    │    └──► 1 (caso base)
│    │    │    └──► 2 * 1 = 2
│    │    └──► 2 * 2 = 4
│    └──► 2 * 4 = 8
└──► 2 * 8 = 16
```

### 4. Multiplicación (mediante sumas)

La multiplicación de dos números se puede definir de manera recursiva como la suma repetida de uno de los números. La definición formal es:

$$
mult(a, b) = \begin{cases}
0 & \text{si } b = 0 \\
a + mult(a, b-1) & \text{si } b > 0
\end{cases}
$$

**Implementación en Elixir:**

```elixir
defmodule Matematicas do
  def multiplicar(_, 0), do: 0
  def multiplicar(a, b) when b > 0, do: a + multiplicar(a, b - 1)
end
```

**Traza para `multiplicar(3, 4)`:**

```
multiplicar(3, 4)
├──► 3 + multiplicar(3, 3)
│    ├──► 3 + multiplicar(3, 2)
│    │    ├──► 3 + multiplicar(3, 1)
│    │    │    ├──► 3 + multiplicar(3, 0)
│    │    │    │    └──► 0 (caso base)
│    │    │    └──► 3 + 0 = 3
│    │    └──► 3 + 3 = 6
│    └──► 3 + 6 = 9
└──► 3 + 9 = 12
```

---

## Recursividad con Cadenas

La recursividad también se puede utilizar para manipular cadenas de texto ya que las cadenas son secuencias de caracteres.

### 1. Invertir una cadena

Por ejemplo, podemos implementar una función que invierta una cadena de la siguiente manera:

```elixir
defmodule Cadenas do
  # Caso base: cadena vacía
  def invertir(""), do: ""
  
  # Caso recursivo
  def invertir(cadena) do
    # Separar último carácter del resto
    ultimo = String.last(cadena)
    resto = String.slice(cadena, 0..-2//1) # Obtener todo menos el último carácter
    
    # Último + invertir(resto)
    ultimo <> invertir(resto)
  end
end
```

**Traza para `invertir("hola")`:**

```
invertir("hola")
├──► "a" <> invertir("hol")
│    ├──► "l" <> invertir("ho")
│    │    ├──► "o" <> invertir("h")
│    │    │    ├──► "h" <> invertir("")
│    │    │    │    └──► "" (caso base)
│    │    │    └──► "h" <> "" = "h"
│    │    └──► "o" <> "h" = "oh"
│    └──► "l" <> "oh" = "loh"
└──► "a" <> "loh" = "aloh"
```

>**⚠️ Nota:** El módulo `String` ya cuenta con la función `String.reverse/1` que invierte una cadena de texto de manera eficiente, pero es útil entender cómo funciona la recursión en este contexto.

### 2. Contar vocales

En este ejemplo, implementamos una función que cuenta el número de vocales en una cadena:

```elixir
defmodule Cadenas do
  def contar_vocales(""), do: 0
  
  def contar_vocales(cadena) do
    primer_caracter = String.first(cadena)
    resto = String.slice(cadena, 1..-1//1) # Obtener todo menos el primer carácter
    
    if es_vocal?(primer_caracter) do
      1 + contar_vocales(resto)
    else
      contar_vocales(resto)
    end
  end
  
  defp es_vocal?(c), do: c in ["a", "e", "i", "o", "u", "A", "E", "I", "O", "U"]
end
```

**Traza para `contar_vocales("Mundo")`:**

```
contar_vocales("Mundo")
├──► contar_vocales("undo")                     (M no es vocal)
│    ├──► 1 + contar_vocales("ndo")             (u es vocal)
│    │    ├──► contar_vocales("do")             (n no es vocal)
│    │    │    ├──► contar_vocales("o")         (d no es vocal)
│    │    │    │    ├──► 1 + contar_vocales("") (o es vocal)
│    │    │    │    │    └──► 0 (caso base)
│    │    │    │    └──► 1 + 0 = 1
│    │    │    └──► 1
│    │    └──► 1
│    └──► 1 + 1 = 2
└──► 2
```

---

## Recursividad con Listas

La recursividad es una técnica común para procesar listas en Elixir. Podemos utilizarla para implementar funciones que operen sobre listas de manera elegante y concisa. Aunque Elixir ya proporciona muchas funciones para trabajar con listas a través del módulo `Enum`, entender cómo implementar estas funciones recursivamente es fundamental para dominar la programación funcional.

Las listas son estructuras naturalmente recursivas en Elixir. Recuerde que las listas se representan como `[head | tail]`, donde `head` es el primer elemento de la lista y `tail` es el resto de la lista. Al descomponer la lista de esta manera, `tail` siempre será una lista (incluso si está vacía), lo que facilita la recursión.

### 1. Sumar elementos

Por ejemplo, podemos definir una función que sume todos los elementos de una lista.

```elixir
defmodule Listas do
  def sumar([]), do: 0 # Caso base: la suma de una lista vacía es 0
  def sumar([head | tail]), do: head + sumar(tail) # Descomponer la lista en cabeza y cola. Se suma el head y se llama recursivamente con el resto de la lista (tail)
end
```

**Traza para `sumar([1, 2, 3])`:**

```
sumar([1, 2, 3])
├──► 1 + sumar([2, 3])
│    ├──► 2 + sumar([3])
│    │    ├──► 3 + sumar([])
│    │    │    └──► 0 (caso base)
│    │    └──► 3 + 0 = 3
│    └──► 2 + 3 = 5
└──► 1 + 5 = 6
```

### 2. Contar elementos pares

En este otro ejemplo, se cuentan los números de una lista que son pares, se utiliza guardas para verificar si el número es par:

```elixir
defmodule Listas do
  def contar_pares([]), do: 0
  def contar_pares([head | tail]) when rem(head, 2) == 0, do: 1 + contar_pares(tail) # Solo se cuenta si el residuo es 0
  def contar_pares([_head | tail]), do: contar_pares(tail) # No se cuenta si es impar, pero se sigue recorriendo la lista
end
```

**Traza para `contar_pares([1, 2, 3, 4, 5])`:**

```
contar_pares([1, 2, 3, 4, 5])
├──► contar_pares([2, 3, 4, 5])                 (1 es impar)
│    ├──► 1 + contar_pares([3, 4, 5])           (2 es par)
│    │    ├──► contar_pares([4, 5])             (3 es impar)
│    │    │    ├──► 1 + contar_pares([5])       (4 es par)
│    │    │    │    ├──► contar_pares([])       (5 es impar)
│    │    │    │    │    └──► 0 (caso base)
│    │    │    │    └──► 1 + 0 = 1
│    │    │    └──► 1
│    │    └──► 1 + 1 = 2
│    └──► 2
└──► 2
```

### 3. Encontrar el máximo

En este caso se encuentra el valor máximo en una lista de números, se utiliza un enfoque recursivo para comparar los elementos de la lista.

```elixir
defmodule Listas do
  def maximo([head | tail]), do: maximo(tail, head) # Se inicia la búsqueda con el primer elemento como el mayor

  defp maximo([], mayor), do: mayor # Caso base: si la lista está vacía, se devuelve el mayor encontrado
  defp maximo([head | tail], mayor) when head > mayor, do: maximo(tail, head) # Si el head es mayor, se actualiza el mayor
  defp maximo([_head | tail], mayor), do: maximo(tail, mayor) # Si no, se sigue con el mismo mayor y se sigue recorriendo la lista
end
```

Este es un ejemplo de cómo se requiere un parámetro adicional para mantener el estado del mayor valor encontrado hasta el momento y evitar el uso de variables globales.

**Traza para `maximo([3, 1, 4, 1, 5, 9])`:**

```
maximo([3, 1, 4, 1, 5, 9])
→ maximo([1, 4, 1, 5, 9], 3)    (3 es el mayor inicial)
→ maximo([4, 1, 5, 9], 3)       (1 no es mayor)
→ maximo([1, 5, 9], 4)          (4 es mayor)
→ maximo([5, 9], 4)             (1 no es mayor)
→ maximo([9], 5)                (5 es mayor)
→ maximo([], 9)                 (9 es mayor)
→ 9 (caso base)
```

### 4. Filtrar elementos

En este ejemplo, se filtran los elementos de una lista que son mayores a un cierto valor límite.

```elixir
defmodule Listas do
  # Caso base: si la lista está vacía, se devuelve una lista vacía
  def filtrar_mayores([], _limite), do: [] 
  
  # Caso recursivo: si el head es mayor que el límite, se incluye en el resultado
  def filtrar_mayores([head | tail], limite) when head > limite do
    [head | filtrar_mayores(tail, limite)]
  end
  
  # Caso recursivo: si el head no es mayor, se omite y se sigue con el tail
  def filtrar_mayores([_head | tail], limite) do
    filtrar_mayores(tail, limite)
  end
end
```

**Traza para `filtrar_mayores([1, 5, 3, 8, 2], 3)`:**

```
filtrar_mayores([1, 5, 3, 8, 2], 3)
├──► filtrar_mayores([5, 3, 8, 2], 3)                   (1 no es mayor)
│    ├──► [5 | filtrar_mayores([3, 8, 2], 3)]           (5 es mayor)
│    │    ├──► filtrar_mayores([8, 2], 3)               (3 no es mayor)
│    │    │    ├──► [8 | filtrar_mayores([2], 3)]       (8 es mayor)
│    │    │    │    ├──► filtrar_mayores([], 3)         (2 no es mayor)
│    │    │    │    │    └──► [] (caso base)
│    │    │    │    └──► [8 | []] = [8]
│    │    │    └──► [8]
│    │    └──► [5 | [8]] = [5, 8]
│    └──► [5, 8]
└──► [5, 8]
```

### 5. Mapear (transformar cada elemento)

Por último, se muestra cómo implementar una función `map` que aplica una función dada a cada elemento de una lista.

```elixir
defmodule Listas do
  # Caso base: si la lista está vacía, se devuelve una lista vacía
  def map([], _funcion), do: []
  
  # Caso recursivo: se aplica la función al head y se sigue con el tail
  def map([head | tail], funcion) do
    [funcion.(head) | map(tail, funcion)]
  end
end
```

**Traza para `map([1, 2, 3], fn x -> x * 2 end)`:**

```
map([1, 2, 3], fn x -> x * 2 end)
├──► [2 | map([2, 3], fn x -> x * 2 end)]
│    ├──► [4 | map([3], fn x -> x * 2 end)]
│    │    ├──► [6 | map([], fn x -> x * 2 end)]
│    │    │    └──► [] (caso base)
│    │    └──► [6 | []] = [6]
│    └──► [4 | [6]] = [4, 6]
└──► [2 | [4, 6]] = [2, 4, 6]
```

---

# Recursividad de Cola (Tail Recursion)

La **recursividad de cola** (*tail recursion*) es un tipo de recursión en la que la llamada recursiva es la **última instrucción** que realiza la función. Esto permite que el compilador o intérprete haga una optimización especial llamada *tail call optimization* (TCO). Gracias a esta optimización, no se crean nuevos espacios en la pila para cada llamada, sino que se reutiliza el mismo marco de pila. De esta forma se evita que la pila crezca demasiado y se produzca un desbordamiento en casos de recursión muy profunda.

Lenguajes como **Elixir** y **Erlang** aplican esta optimización de forma automática. Otros lenguajes, como **Python** o **Java**, no la implementan, por lo que es importante tener en cuenta las limitaciones de cada lenguaje.

## ¿Por qué es importante?

Considere el siguiente ejemplo de una función factorial implementada de dos maneras: una con recursión normal y otra con recursión de cola.

### Recursión Normal (NO tail-recursive)

```elixir
def factorial(0), do: 1
def factorial(n), do: n * factorial(n - 1)
                      ↑
                  Operación pendiente después de la llamada
```

**Problema:** Cada llamada debe esperar el resultado de la siguiente para hacer la multiplicación. Se acumulan marcos en la pila.

```
Pila crece →

factorial(5)     |  Espera resultado  |
factorial(4)     |  Espera resultado  |
factorial(3)     |  Espera resultado  |
factorial(2)     |  Espera resultado  |
factorial(1)     |  Espera resultado  |
factorial(0) → 1 |  Retorna           |

← Pila se resuelve
```

Se necesita más memoria para almacenar todas las llamadas pendientes.

### Recursión de Cola (tail-recursive)

```elixir
def factorial(n, acum \\ 1)
def factorial(0, acum), do: acum
def factorial(n, acum), do: factorial(n - 1, n * acum)
                           ↑
                        Última operación: NO hay nada pendiente
```

**Ventaja:** El compilador puede **optimizar** y reutilizar el mismo marco de pila.

```
factorial(5, 1)   → factorial(4, 5)   (reusa marco)
factorial(4, 5)   → factorial(3, 20)  (reusa marco)
factorial(3, 20)  → factorial(2, 60)  (reusa marco)
factorial(2, 60)  → factorial(1, 120) (reusa marco)
factorial(1, 120) → factorial(0, 120) (reusa marco)
factorial(0, 120) → 120
```

Se utiliza un espacio constante en la pila, independientemente de la profundidad de la recursión.

---

## Ejemplos de Tail Recursion

A continuación, se presentan ejemplos de recursividad de cola para las funciones que ya hemos visto.

### 1. Factorial

Usando recursividad de cola, podemos implementar la función factorial de la siguiente manera:

```elixir
defmodule Matematicas do
  # Función pública: inicia el acumulador
  def factorial(n), do: factorial_tail(n, 1)
  
  # Función privada: tail-recursive
  defp factorial_tail(0, acum), do: acum
  defp factorial_tail(n, acum) when n > 0 do
    factorial_tail(n - 1, n * acum)
  end
end
```

Observe que se ha utilizado un parámetro `acum` para mantener los cálculos intermedios, luego, en el caso base, simplemente devolvemos el valor acumulado. No hay operaciones pendientes después de la llamada recursiva, lo que permite la **optimización de cola**.

**Traza para `factorial(5)`:**

```
factorial(5, 1)
→ factorial(4, 5)
→ factorial(3, 20)
→ factorial(2, 60)
→ factorial(1, 120)
→ factorial(0, 120)
→ 120 (caso base)
```

Lo interesante de la recursividad de cola es que **no se acumulan llamadas en la pila**, ya que cada llamada puede reutilizar el espacio de la llamada anterior. Esto hace que la recursividad de cola sea más eficiente en términos de uso de memoria.

### 2. Fibonacci eficiente

El algoritmo de Fibonacci que ya vimos tiene un problema, es muy ineficiente para valores grandes de n. Sin embargo, se puede implementar utilizando recursividad de cola de la siguiente manera:

```elixir
defmodule Matematicas do
  def fibonacci(n), do: fibonacci(n, 0, 1) # Se inician los dos primeros números de la secuencia

  defp fibonacci(0, a, _b), do: a # Caso base: si n es 0, se devuelve el primer número
  defp fibonacci(n, a, b), do: fibonacci(n - 1, b, a + b) # Se avanza en la secuencia, actualizando los dos últimos números
end
```

**Traza para `fibonacci(5)`:**

```
fibonacci(5, 0, 1)
→ fibonacci(4, 1, 1)
→ fibonacci(3, 1, 2)
→ fibonacci(2, 2, 3)
→ fibonacci(1, 3, 5)
→ fibonacci(0, 5, 8)
→ 5 (caso base)
```

En esta implementación no se recalculan valores intermedios, por lo que es más eficiente. Además, no se acumulan llamadas en la pila.

### 3. Suma de lista

Un ejemplo de recursividad de cola es la función que suma los elementos de una lista acumulando el resultado en un parámetro adicional:

```elixir
defmodule Listas do
  def sumar(lista), do: sumar(lista, 0)

  defp sumar([], acumulado), do: acumulado
  defp sumar([head | tail], acumulado), do: sumar(tail, head + acumulado)
end
```

**Traza para `sumar([1, 2, 3], 0)`:**

```
sumar([1, 2, 3], 0)
→ sumar([2, 3], 1)
→ sumar([3], 3)
→ sumar([], 6)
→ 6 (caso base)
``` 

Las sumas intermedias se acumulan en el parámetro `acumulado`, y no hay operaciones pendientes después de la llamada recursiva.

### 4. Invertir lista

Para invertir una lista utilizando recursividad de cola, podemos hacer lo siguiente:

```elixir
defmodule Listas do
  def invertir(lista), do: invertir_tail(lista, [])
  
  defp invertir_tail([], acum), do: acum
  defp invertir_tail([head | tail], acum) do
    invertir_tail(tail, [head | acum])
  end
end
```

**Traza para `invertir([1, 2, 3])`:**

```
invertir_tail([1, 2, 3], [])
→ invertir_tail([2, 3], [1])
→ invertir_tail([3], [2, 1])
→ invertir_tail([], [3, 2, 1])
→ [3, 2, 1] (caso base)
```

Observe que el resultado se construye en el acumulador `acum`, y no hay operaciones pendientes después de la llamada recursiva.


---

## Ejercicios prácticos

Escriba un método recursivo en elixir para cada uno de los siguientes casos:

1. Aplique recursividad de cola para los ejercicios que no la tengan. 
2. División entera entre dos números mediante restas sucesivas. Devuelva una tupla, `{cociente, residuo}` o `{:error, "División por cero"}`.
3. Sumar todos los números primos de una lista. Debe programar una función auxiliar que determine si un número es primo o no recursivamente.
4. Contar cuántas veces está un elemento dentro de una lista.
5. Determinar si una cadena de caracteres es palíndroma o no.
6. Contar el número de vocales en una cadena de caracteres.
7. Indicar si un número es perfecto. Un número es perfecto si es igual a la suma de sus divisores propios (excluyendo el mismo número). Por ejemplo, 6 es perfecto porque sus divisores propios son 1, 2 y 3, y 1 + 2 + 3 = 6.
8. Retornar en una cadena los números ubicados en las posiciones pares de una lista. Por ejemplo, para la lista `[1, 2, 3, 4, 5]`, la función debería retornar `"135"`. 
9. Contar el número de dígitos de un número. Se asume que el número es positivo. No puede convertir el número a `string`.
10. Implemente una función que le pida al usuario una contraseña y verifique si una contraseña cumple con los siguientes criterios, si no los cumple, debe indicarle al usuario qué criterio no se cumple y pedirle que ingrese una nueva contraseña hasta que se ingrese una contraseña segura y retorne `:ok`. Criterios:
    - Tiene al menos 6 caracteres.
    - Contiene al menos una letra mayúscula.
    - Contiene al menos un dígito.
    - Contiene al menos uno de estos caracteres especiales: `!@#$%&`.
    
---

## Consideraciones finales

La recursividad es una técnica poderosa, pero debe usarse con cuidado. Asegúrese de siempre definir un caso base y considera el uso de la recursión de cola (tail recursion) para evitar desbordamientos de pila en casos de recursión profunda.

---

## Recursión en la Naturaleza

La recursión no es exclusiva de la programación; es un **patrón universal** que aparece en:

1. **Árboles**: Tronco → ramas → ramas más pequeñas → hojas
2. **Ríos**: Río principal → afluentes → arroyos
3. **Pulmones**: Tráquea → bronquios → bronquiolos
4. **Fractales**: Patrones que se repiten a diferentes escalas
5. **DNA**: Estructura recursiva de información genética
6. **Costas**: Irregularidades que se repiten a diferentes escalas

### Autosimilaridad

El principio de **autosimilaridad** significa que una estructura compleja está compuesta de versiones más pequeñas de sí misma, lo que facilita su análisis y comprensión. La recursión captura este patrón: **resolver lo complejo repitiendo lo simple**.

---

## Para la próxima clase

- Investigar por qué la recursividad de cola es más eficiente en términos de uso de memoria que la recursividad normal.
- Por qué los lenguajes funcionales tienden a utilizar la recursión en lugar de bucles.
- Qué problemas pueden surgir al utilizar la recursión en lugar de bucles.
- Qué es `Stream` en Elixir y la evaluación perezosa (*lazy evaluation*).
