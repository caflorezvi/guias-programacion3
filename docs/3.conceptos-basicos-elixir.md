```
Universidad del Quindío
Programa de Ingeniería de Sistemas y Computación
Programación III - Conceptos básicos de Elixir
Docente: Carlos Andrés Florez V.
```

# Conceptos básicos de Elixir

Para comprender los conceptos básicos de Elixir, es importante familiarizarse con su sintaxis y características principales. A continuación, se presentan algunos de los conceptos fundamentales que se abordarán en esta guía:

- Sintaxis básica.
- Módulo `IO`.
- Uso básico de funciones y módulos.
- Operador pipe `|>`.
- Documentación y buenas prácticas.

Estos temas se explorarán a través de ejemplos prácticos y ejercicios para reforzar el aprendizaje.

---

## Ejercicio 1

La biblioteca municipal de tu ciudad ha implementado un nuevo sistema digital. El bibliotecario desea que, al iniciar el sistema, se muestre un mensaje de bienvenida a los usuarios.

El mensaje debe ser: `Bienvenidos al sistema de la Biblioteca Central`.

> ⚠️ **Importante:** Haga un análisis del problema y siga los pasos del pensamiento computacional para resolverlo. Recuerde que el pensamiento computacional implica hacer una abstracción del problema, descomponer el problema en partes más pequeñas y manejables, identificar patrones, y codificar la solución.

1. **Abstracción**: El problema requiere mostrar un mensaje en pantalla. Necesitamos identificar cómo se muestra un mensaje en Elixir.
2. **Descomposición**: Dividimos el problema en partes más pequeñas:
   - Mostrar el mensaje de bienvenida.
3. **Identificación de patrones**: En Elixir, usamos el módulo `IO` para interactuar con la entrada/salida. La función `IO.puts/1` se utiliza para mostrar mensajes en pantalla. 
4. **Codificación**: Escribimos el código en Elixir para implementar la solución.

Cree un nuevo archivo llamado `biblioteca.exs` dentro de Visual Studio Code y escriba el siguiente código:

### Versión 1

```elixir
IO.puts("Bienvenidos al sistema de la Biblioteca Central")
```

Consideraciones:

- Esta forma está bien para ciertas pruebas de un concepto, sin embargo, lo ideal, por organización y reutilización, es que todas las funcionalidades estén agrupadas en **módulos**.
- Elixir, al igual que otros lenguajes (por ejemplo, Python o JavaScript), no cuenta con una función principal `main()`. Por ahora —y antes de trabajar con proyectos mediante *mix*-, se definirá un módulo específico para el ejemplo. Este módulo incluirá una función `main()`, que será la encargada de ejecutar el programa.

### Versión 2

Cree un archivo llamado `biblioteca.exs` y escriba el siguiente código:

```elixir
defmodule Biblioteca do
  def main do
    IO.puts("Bienvenidos al sistema de la Biblioteca Central")
  end
end

Biblioteca.main()
```

El módulo `Biblioteca` contiene la función `main`, que es la que se invoca para mostrar el mensaje de bienvenida. Esto permite una mejor organización del código. Tenga en cuenta que es **necesario invocar** la función `main()` para que el **programa se ejecute**, por lo que se debe incluir la llamada a `Biblioteca.main()` al **final del archivo**.

> ⚠️ **Importante:** En Elixir (y en la mayoría de lenguajes funcionales), no hay una palabra clave `return` como en Java o C. El valor de la última expresión evaluada en la función es el valor que esta devuelve.

### Versión 3

Modifique el archivo `biblioteca.exs` o cree uno nuevo y escriba el siguiente código:

```elixir
defmodule Biblioteca do
  def main do
    mensaje = saludar()
    imprimir_mensaje(mensaje)
  end

  defp saludar do
    "Bienvenidos al sistema de la Biblioteca Central"
  end

  defp imprimir_mensaje(mensaje) do
    IO.puts(mensaje)
  end
end

Biblioteca.main()
```

En este caso, la función `saludar` se define como privada (usando `defp`), lo que significa que solo puede ser llamada desde dentro del módulo `Biblioteca`. Además, se ha separado la lógica de impresión en una función diferente (`imprimir_mensaje`). Esto permite una mejor organización del código y facilita la reutilización de funciones en otros contextos. 

La función `main` actúa como el punto de entrada del módulo y se encarga de llamar a las funciones privadas `saludar` e `imprimir_mensaje` respectivamente.

### Versión 4

Ahora se requiere modificar el programa para que el mensaje de bienvenida sea más dinámico y pueda personalizarse. Para ello, se debe modificar la función `saludar` para que reciba un parámetro con el nombre del usuario.

```elixir
defmodule Biblioteca do
  def main do
    mensaje = saludar("Carlos")
    imprimir_mensaje(mensaje)
  end

  defp saludar(nombre) do
    "Hola #{nombre}, Bienvenido al sistema de la Biblioteca Central"
  end

  defp imprimir_mensaje(mensaje) do
    IO.puts(mensaje)
  end
end

Biblioteca.main()
```

La función `saludar` ahora acepta un parámetro `nombre`, que se utiliza para personalizar el mensaje de bienvenida. Esto permite que el programa sea más flexible y pueda adaptarse a diferentes usuarios. Observe que el nombre del usuario se pasa como argumento al llamar a la función `saludar` desde `main` y se **interpola** en el mensaje de bienvenida.

### Versión 5

Ahora, se requiere que el nombre del usuario se solicite de forma interactiva en lugar de estar codificado. Para ello, se puede utilizar la función `IO.gets/1` para leer la entrada del usuario.


```elixir
defmodule Biblioteca do
  def main do
    nombre = leer_nombre()
    mensaje = saludar(nombre)
    imprimir_mensaje(mensaje)
  end

  defp saludar(nombre) do
    "Hola #{nombre}, Bienvenido al sistema de la Biblioteca Central"
  end

  defp imprimir_mensaje(mensaje) do
    IO.puts(mensaje)
  end

  defp leer_nombre do
    IO.gets("Por favor, ingrese su nombre: ")
  end
end

Biblioteca.main()
```

La función `IO.gets/1` se utiliza para **mostrar un mensaje al usuario y esperar su entrada**. La entrada se almacena en la variable `nombre`, que luego se pasa a la función `saludar` para finalmente imprimir el mensaje de bienvenida.

Al ejecutar el programa puede observar que después del nombre ingresado, hay un salto de línea adicional. Esto se debe a que `IO.gets/1` incluye el carácter de nueva línea (`\n`) en la entrada capturada. Para solucionar esto, se puede utilizar la función `String.trim/1` para eliminar los espacios en blanco y el salto de línea al final de la cadena.

Por lo tanto, la función `leer_nombre` se modifica para incluir `String.trim/1` en la cadena de entrada:

```elixir
defmodule Biblioteca do
  def main do
    nombre = leer_nombre()
    mensaje = saludar(nombre)
    imprimir_mensaje(mensaje)
  end

  defp saludar(nombre) do
    "Hola #{nombre}, Bienvenido al sistema de la Biblioteca Central"
  end

  defp imprimir_mensaje(mensaje) do
    IO.puts(mensaje)
  end

  defp leer_nombre do
    nombre = IO.gets("Por favor, ingrese su nombre: ")
    String.trim(nombre)
  end
end

Biblioteca.main()
```

Al ejecutar esta versión del programa todo funciona correctamente y se eliminan los espacios en blanco y saltos de línea adicionales. La función `String.trim/1` garantiza que el nombre ingresado por el usuario se procese correctamente antes de ser utilizado en el saludo.

### Versión 6 (final)

Para finalizar, podemos simplificar aún más el código utilizando el operador pipe `|>` en la función `main` y `leer_nombre`, así:

```elixir
defmodule Biblioteca do
  def main do
    leer_nombre()
    |> saludar()
    |> imprimir_mensaje()
  end

  defp saludar(nombre) do
    "Hola #{nombre}, Bienvenido al sistema de la Biblioteca Central"
  end

  defp imprimir_mensaje(mensaje) do
    IO.puts(mensaje)
  end

  defp leer_nombre do
    IO.gets("Por favor, ingrese su nombre: ")
    |> String.trim()
  end
end

Biblioteca.main()
```

La función `leer_nombre` ahora está usando el operador pipe `|>` para **encadenar** la llamada a `String.trim/1`, básicamente la salida de `IO.gets/1` se pasa directamente a `String.trim/1` y este último se encarga de eliminar cualquier espacio en blanco o salto de línea al principio y al final de la cadena.

Así mismo, la función `main` se ha simplificado utilizando el operador pipe `|>`, lo que hace que el flujo de datos sea más claro y fácil de seguir.

El **uso del operador pipe `|>` es muy común en Elixir** y se utiliza para encadenar funciones. En futuros ejercicios, se puede aprovechar esta característica para simplificar aún más el código y hacerlo más legible.

> ⚠️ **Importante:** El operador pipe `|>` toma el retorno de una función y lo pasa como el primer argumento a la siguiente función.

---

## Ejercicio 2

Una empresa de envíos ha desarrollado un sistema para registrar paquetes. El encargado desea que, al iniciar el sistema, se solicite al usuario su nombre, el nombre del destinatario y la dirección de entrega.
Con esa información, el sistema debe mostrar un único mensaje concatenado que confirme el registro, por ejemplo:

`"El paquete a nombre de Carlos será enviado a Ana en la dirección Calle 123, Bogotá."`

---

## Ejercicio 3

Se desea crear un script en Elixir que permita validar si una cadena de texto ingresada por el usuario es palíndroma. Un palíndromo es una palabra o frase que se lee igual hacia adelante y hacia atrás, ignorando espacios. Para este ejercicio puede usar el módulo `String` y las siguientes funciones: 

- `String.replace/3` para eliminar los espacios en blanco
- `String.downcase/1` para ignorar mayúsculas y minúsculas.
- `String.reverse/1` para invertir la cadena.

### Versión 1

Cree un archivo llamado `palindroma.exs` y escriba el siguiente código:

```elixir
defmodule Palindroma do

  def main do
    leer_cadena("Ingrese una cadena: ")
    |> es_palindroma?()
    |> generar_mensaje()
    |> imprimir()
  end

  defp es_palindroma?(cadena_texto) do
    cadena_minuscula = String.downcase(cadena_texto) # Convierte a minúsculas toda la cadena
    cadena_sin_espacios = String.replace(cadena_minuscula, " ", "") # Elimina espacios en blanco
    String.reverse(cadena_sin_espacios) == cadena_sin_espacios # Compara la cadena original con la invertida, retorna true o false
  end

  defp imprimir(mensaje) do
    IO.puts(mensaje)
  end

  defp leer_cadena(texto) do
    IO.gets(texto)
    |> String.trim()
  end

  defp generar_mensaje(es_palindroma) do
    if es_palindroma do
      "La cadena es palíndroma"
    else
      "La cadena no es palíndroma"
    end
  end

end

Palindroma.main() # Invoca la función principal para ejecutar el programa
```

Ejecute el programa y verifique su funcionamiento.

Aunque este código funciona correctamente, se puede mejorar usando encadenamiento de funciones con el operador pipe `|>`, el **encadenamiento de funciones** es una característica importante de la **programación funcional**.

> ⚠️ **Importante:** Por buenas prácticas, una función que retorna un valor booleano (`true` o `false`) debe tener un signo de interrogación al final de su nombre, como `es_palindroma?/1`.

### Versión 2

Modifique la función `es_palindroma?/1` para que utilice el operador pipe `|>` y tenga un enfoque más funcional, así:

```elixir
defp es_palindroma?(cadena) do
  cadena
  |> String.replace(" ", "") # Elimina espacios en blanco
  |> String.downcase() # Convierte toda la cadena a minúsculas
  |> then(fn cadena -> cadena == String.reverse(cadena) end ) # Compara la cadena original con la invertida, retorna true o false
end
```

Observe que la función `es_palindroma?/1` utiliza la función `then/2` para comparar la cadena original con la invertida. La función `then/2` permite **encadenar operaciones**, pasando el resultado de una función a otra. En este caso, se pasa la cadena procesada a una función anónima que realiza la comparación y retorna `true` o `false`.

Analice el código anterior y ejecute el programa para verificar su funcionamiento. Haga su propia versión del programa y pruébelo con diferentes cadenas de texto.

---

## Documentación y buenas prácticas

En Elixir, existe documentación de línea, de módulo y de función. Es importante documentar el código para facilitar su comprensión y mantenimiento. Algunas buenas prácticas para la documentación en Elixir son:

- Utilizar comentarios claros y concisos para explicar el propósito de funciones y módulos.
- Incluir ejemplos de uso en la documentación de funciones.

Para **comentarios de línea** se utiliza el símbolo `#` al inicio de la línea. Por ejemplo:

```elixir
def sumar(a, b) do
  a + b # Se suman los valores y se retorna el resultado
end
```

Para **comentarios de módulo** se utiliza la anotación `@moduledoc` para documentar el propósito del módulo, se puede incluir el autor, fecha de creación, versión, etc. Por ejemplo:

```elixir
defmodule Calculadora do
  @moduledoc """
  Este módulo realiza operaciones matemáticas.
  - autor: Carlos Andrés Florez V.
  - fecha: Agosto del 2025
  """

  def sumar(a, b) do
    a + b
  end
end
```

Para **comentarios de función** se utiliza la anotación `@doc` para documentar el propósito de la función. Por ejemplo:

```elixir
defmodule Calculadora do
  @moduledoc """
  Este módulo realiza operaciones matemáticas.
  """

  @doc """
  Suma dos números.
    ## Ejemplo
        iex> Calculadora.sumar(2, 3)
        5
  """
  def sumar(a, b) do
    a + b
  end
end
```

Aplique estas buenas prácticas de documentación en los ejercicios realizados anteriormente.

Finalmente, **para nombrar funciones y módulos en Elixir, se recomienda seguir las siguientes convenciones**:

- Utilizar **nombres en minúsculas y separados por guiones bajos** para funciones y variables.
- Utilizar **nombres en CamelCase** para módulos.
- Los nombres deben ser **descriptivos y reflejar la funcionalidad del código**.
- Evitar **abreviaturas y siglas poco conocidas**.
- Utilizar **nombres en inglés** para funciones y módulos.
- Mantener la **coherencia en la nomenclatura** a lo largo del proyecto.
- Documentar adecuadamente las funciones y módulos.

---

## Para la próxima clase
- Revisar la [documentación oficial](https://elixirschool.com/es/lessons/basics/documentation)  de Elixir para familiarizarse con las convenciones de documentación.
- Practicar la creación de módulos y funciones con documentación adecuada.
- Investigar qué funciones tiene el módulo `String`.
- Investigar qué es una función anónima en Elixir.
