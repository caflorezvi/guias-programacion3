```
Universidad del Quindío
Programa de Ingeniería de Sistemas y Computación
Programación III - Aplicaciones Distribuidas y Concurrentes
Docente: Carlos Andrés Florez V.
```

# Aplicaciones distribuidas

En los ejemplos vistos en las clases anteriores, **todos los procesos se ejecutaban en un mismo nodo** dentro de la máquina virtual BEAM. Sin embargo, Elixir también permite crear **aplicaciones distribuidas**, donde los procesos pueden ejecutarse en **nodos diferentes**, ya sea dentro de una misma máquina o en equipos distintos conectados por red.

Esta capacidad de distribución se logra mediante el módulo `Node`, que proporciona las herramientas necesarias para **gestionar y comunicar nodos** dentro del entorno distribuido de Elixir.

## Módulo Node

El módulo `Node` ofrece funciones para trabajar con **nodos distribuidos** y facilitar la comunicación entre ellos. Algunas de las más utilizadas son:

- `Node.start/1`: inicia un nodo con un nombre específico.
- `Node.connect/1`: establece una conexión con otro nodo en la red.
- `Node.list/0`: devuelve la lista de nodos actualmente conectados.
- `Node.self/0`: obtiene el nombre del nodo actual.

Gracias a estas funciones, es posible construir **sistemas distribuidos** en Elixir donde los procesos se comunican y colaboran de forma transparente, sin importar si se encuentran en el mismo equipo o en distintos dispositivos conectados a la red.

## Ejemplo de uso de Node

Vamos a crear dos nodos y hacer que se comuniquen entre sí. La idea es tener un nodo que envía un mensaje y otro que lo recibe. La diferencia respecto a los ejemplos anteriores es que ahora los procesos se pueden ejecutar de manera distribuida.

### Versión 1 (iex)

En esta versión, abrimos iex en dos terminales independientes y escribimos los comandos directamente en cada una. No es lo más práctico, pero es útil para entender cómo funciona la comunicación entre nodos.

#### 1. Iniciar dos nodos

En una terminal, ejecutamos:

```bash
iex --sname nodo1 
```

En otra terminal, ejecutamos:

```bash
iex --sname nodo2
```

Es importante que los nombres de los nodos sean únicos en la red para evitar conflictos.

La bandera `--sname` permite asignar un nombre corto al nodo, que es útil para nodos en la misma máquina. Si los nodos están en diferentes máquinas, se puede usar `--name` para asignar un nombre completo con el formato `nombre@host`.

#### 2. Creación del proceso que recibe mensajes

En la terminal donde está `nodo2`, ejecutamos el siguiente código para recibir el mensaje:

```elixir
# Se crea un proceso con un nombre propio
Process.register(self(), :proceso_en_nodo2)

IO.puts("Nodo iniciado correctamente: #{Node.self()}")
IO.puts("Esperando mensajes...")

# Esperar y recibir mensajes
receive do
  {:mensaje, msg} -> IO.puts("Recibido en nodo 2: #{msg}")
end
```

El `nodo2` será un receptor de mensajes. El proceso creado se registra con el nombre `:proceso_en_nodo2` para que pueda ser referenciado desde otros nodos.

#### 3. Enviar un mensaje desde otro nodo

En la terminal donde está `nodo1`, ejecutamos el siguiente código para conectarnos a `nodo2` y enviarle un mensaje:

```elixir
Node.connect(:"nodo2@tu_maquina") # Reemplaza 'tu_maquina' con el nombre de tu máquina
send({:proceso_en_nodo2, :"nodo2@tu_maquina"}, {:mensaje, "Hola desde nodo 1"})
``` 

La comunicación entre nodos se establece usando el nombre completo del nodo receptor. Siguiendo el formato `nombre@host`, donde `host` es el nombre de la máquina donde se está ejecutando el nodo receptor.

Para saber el nombre de `tu_maquina`, fíjese en la consola del `nodo2`, donde dice: `Nodo iniciado correctamente: nodo2@tu_maquina`.

#### 4. Verificar la comunicación

En la terminal de `nodo2`, debería ver el mensaje recibido:

```
Recibido en nodo 2: Hola desde nodo 1
```

El `nodo2` solo recibe un mensaje y luego termina. Si desea enviar más mensajes, debe ejecutar nuevamente el bloque `receive` o crear un bucle para mantener el proceso activo.

Tenga en cuenta que, para que esto funcione, **ambos nodos deben estar en la misma red** y ser capaces de comunicarse entre sí. No necesariamente deben estar en la misma máquina, pero sí deben poder resolver los nombres de los nodos entre sí.

### Versión 2 (scripts)

En lugar de escribir los comandos directamente en la consola, podemos crear archivos `.exs` para cada nodo y ejecutarlos. Además, se mejora la recepción de mensajes para que el nodo receptor pueda seguir escuchando indefinidamente.

#### 1. Código para nodo1 (`nodo1.exs`)

Cree un archivo llamado `nodo1.exs` con el siguiente contenido:

```elixir
defmodule Cliente do
  def main do
    # Inicia el nodo en modo distribuido con un nombre corto
    {:ok, _} = Node.start(:nodo1@localhost, :shortnames)

    # Establece la cookie (debe coincidir con la del nodo2)
    Node.set_cookie(:mi_cookie)

    # Intentar conectarse al nodo2
    if Node.connect(:nodo2@localhost) do
      IO.puts("Conectado a nodo2@localhost correctamente")
    else
      IO.puts("No se pudo conectar a nodo2@localhost")
    end

    # Enviar mensaje al proceso remoto
    send({:proceso_en_nodo2, :nodo2@localhost}, {:mensaje, "Hola desde nodo1"})

    IO.puts("Mensaje enviado a nodo2")
  end
end

Cliente.main()
``` 

Se organiza el código dentro de un módulo `Cliente` con una función `main` para mayor claridad. No es obligatorio, pero es una buena práctica.

#### 2. Código para nodo2 (`nodo2.exs`)

Cree un archivo llamado `nodo2.exs` con el siguiente contenido:

```elixir
defmodule Servidor do
  def main do
    # Inicia el nodo en modo distribuido con un nombre corto
    {:ok, _} = Node.start(:nodo2@localhost, :shortnames)

    # Establece la cookie para la autenticación entre nodos
    Node.set_cookie(:mi_cookie)

    # Crear un proceso que escuche mensajes
    pid = spawn(fn -> loop() end)

    # Registrar el proceso con un nombre global en este nodo. Esto permite que otros nodos lo encuentren
    Process.register(pid, :proceso_en_nodo2)

    IO.puts("Nodo iniciado correctamente: #{Node.self()}")
    IO.puts("Esperando mensajes...")

    # Mantener el nodo activo
    :timer.sleep(:infinity)
  end

  # Función recursiva para recibir mensajes indefinidamente
  defp loop do
    receive do
      {:mensaje, msg} ->
        IO.puts("Recibido en nodo 2: #{msg}")
        loop()
    end
  end
end

Servidor.main()
```

Se define un módulo `Servidor` con una función `main` que inicia el nodo y crea un proceso que escucha mensajes de forma indefinida utilizando una función recursiva `loop`.

#### 3. Comprobar que epmd está corriendo

Antes de ejecutar los nodos, asegúrese de que el demonio de nombres de Erlang (Erlang Port Mapper Daemon, `epmd`) esté en ejecución. Este proceso se encarga de administrar los nombres y la comunicación entre los nodos distribuidos.

Puede verificar si `epmd` está corriendo con el siguiente comando en la terminal:

```bash
epmd -names
```

Si dice que no está corriendo, inícielo con:

```bash
epmd -daemon
```

#### 4. Ejecutar los nodos

Luego, en cada terminal (independiente), ejecutamos:

```bash
elixir nodo2.exs
```

y en la otra terminal:

```bash
elixir nodo1.exs
```

#### 5. Verificar la comunicación

En la terminal donde se ejecuta `nodo2.exs`, debería ver el mensaje recibido:

```
Recibido en nodo 2: Hola desde nodo1
```

Y dicho nodo permanecerá activo, esperando más mensajes de manera indefinida.

#### 6. Mejoras

Use variables a nivel de módulo para definir el nombre del nodo y la cookie, evitando repetirlos en varias partes del código.

---

## Comunicación entre nodos

En Elixir (y Erlang), los nodos pueden comunicarse entre sí a través de la red, siempre que compartan la misma **cookie de autenticación** y estén registrados en el **sistema de distribución** de la máquina virtual BEAM.

Cada nodo tiene un nombre que lo identifica de forma única en el clúster, y este nombre puede ser **corto** o **completo** (también llamados *shortnames* y *longnames*).

**Nombres cortos** (`:nodo1`, `:nodo2`)

Se utilizan cuando los nodos se ejecutan **en la misma máquina**. Son más simples y cómodos para entornos locales o de desarrollo. Generalmente en los nombres cortos, el `host` es implícito y se asume que es el nombre de la máquina local, aunque puede utilizarse `localhost`.

**Nombres completos** (`:nodo1@host1`, `:nodo2@host2`)

Se utilizan cuando los nodos se ejecutan **en máquinas diferentes** conectadas por red. En este caso, la parte después del `@` (`host1`, `host2`) corresponde al **nombre del host** o la **dirección IP** de cada máquina, lo que permite a la BEAM ubicar y establecer la comunicación entre ellas.

---

## Ejercicio 1

Cree una aplicación distribuida en Elixir que permita a un nodo cliente enviar una lista de números a un nodo servidor. El nodo servidor debe recibir la lista, calcular la suma y el promedio de los números, y devolver ambos resultados al nodo cliente.

En el cliente, los números se le piden al usuario a través de la consola. El cliente envía la lista al servidor y espera la respuesta con la suma y el promedio, que luego muestra en pantalla.

## Ejercicio 2

Se desea desarrollar una aplicación distribuida en Elixir que permita la comunicación entre múltiples nodos clientes y un **nodo servidor central**. Los clientes podrán conectarse simultáneamente al servidor y enviarle mensajes con el siguiente formato:

* `{:mayusculas, msg}`: Convierte el mensaje a mayúsculas y lo devuelve.
* `{:minusculas, msg}`: Convierte el mensaje a minúsculas y lo devuelve.
* `{:palindroma, msg}`: Verifica si el mensaje es un palíndromo y devuelve `true` o `false`.
* `{:contar_vocales, msg}`: Cuenta el número de vocales en el mensaje y lo devuelve.

El nodo servidor debe procesar múltiples solicitudes de forma concurrente y responder a cada cliente de manera independiente. Los nodos clientes, por su parte, deben poder enviar mensajes y recibir respuestas de forma asíncrona.

Además, hay un mensaje especial que finaliza la comunicación: `:fin`. Cuando el nodo servidor recibe este mensaje, le responde al nodo cliente con `:adios` y termina la comunicación con ese cliente.

Pruebe la aplicación creando al menos dos nodos clientes (si puede en máquinas diferentes) que envíen diferentes tipos de mensajes al nodo servidor y muestren las respuestas recibidas.

---

## Más allá: OTP

Hasta el momento hemos trabajado con procesos "a mano" usando `spawn`, `send`, `receive` y `Task`. Sin embargo, en aplicaciones reales esto puede volverse complejo y propenso a errores.

En aplicaciones reales, Elixir recomienda usar **OTP** (Open Telecom Platform), que provee:

- **GenServer**: procesos con estado encapsulado y callbacks.
- **Supervisores**: reinician procesos automáticamente si fallan.
- **Árboles de supervisión**: estructuras jerárquicas de procesos tolerantes a fallos.

Esto es lo que permite a aplicaciones hechas en Elixir ser **altamente concurrentes y resilientes**. En futuras clases profundizaremos en OTP y sus componentes.

---

## Para la próxima clase

- Leer sobre OTP y GenServer en la documentación oficial de Elixir: [https://hexdocs.pm/elixir/GenServer.html](https://hexdocs.pm/elixir/GenServer.html)
- Investigar qué es un Agente en Elixir y cómo se utiliza: [https://hexdocs.pm/elixir/Agent.html](https://hexdocs.pm/elixir/Agent.html)
- Qué es un Supervisor y cómo ayuda a manejar fallos en procesos: [https://hexdocs.pm/elixir/Supervisor.html](https://hexdocs.pm/elixir/Supervisor.html)