<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script> 
<script> 
  document.addEventListener("DOMContentLoaded", function() { mermaid.initialize({ startOnLoad: true }); }); 
</script>

```
Universidad del Quind√≠o
Programa de Ingenier√≠a de Sistemas y Computaci√≥n
Programaci√≥n III - Streams
Docente: Carlos Andr√©s Florez V.
```
## Evaluaci√≥n Perezosa (Lazy Evaluation)

La evaluaci√≥n perezosa es una caracter√≠stica de algunos lenguajes de programaci√≥n, como Elixir, que permite **diferir la evaluaci√≥n de una expresi√≥n hasta que su valor sea realmente necesario**. Esto puede mejorar la eficiencia y permitir la creaci√≥n de estructuras de datos infinitas, como las listas infinitas.

En Elixir, la evaluaci√≥n es estricta por defecto: las expresiones se eval√∫an inmediatamente y las estructuras de datos como listas, tuplas y mapas se construyen de forma eager. No obstante, Elixir proporciona el m√≥dulo Stream, que permite definir computaciones perezosas sobre colecciones enumerables, en las que los elementos se generan y procesan solo cuando son consumidos.

La **evaluaci√≥n perezosa** ofrece varias ventajas:

1. **Mejorar la eficiencia**: Evita c√°lculos innecesarios
2. **Reducir el uso de memoria**: No crea estructuras intermedias
3. **Permitir secuencias infinitas**: Genera valores bajo demanda
4. **Optimizar pipelines**: Procesa elementos uno a la vez en lugar de crear copias completas

## Evaluaci√≥n estricta vs perezosa

A continuaci√≥n, se muestra una comparaci√≥n entre la evaluaci√≥n estricta (usando `Enum`) y la evaluaci√≥n perezosa (usando `Stream`) en Elixir.

### Evaluaci√≥n estricta (Eager)

En evaluaci√≥n estricta, todas las operaciones se ejecutan inmediatamente:

```elixir
# Cada operaci√≥n crea una nueva lista completa
resultado = [1, 2, 3, 4, 5]
|> Enum.map(fn x -> x * 2 end)        # [2, 4, 6, 8, 10] - Lista completa en memoria
|> Enum.filter(fn x -> x > 5 end)     # [6, 8, 10] - Nueva lista en memoria
|> Enum.take(2)                       # [6, 8] - Otra lista en memoria
```

#### Diagrama de evaluaci√≥n estricta

Podemos representar el proceso de evaluaci√≥n estricta de la siguiente manera:


<div class="mermaid" style="text-align: center;">
graph TD
    E1[Lista original:<br/>1, 2, 3, 4, 5]
    E2[map: x * 2<br/>Lista completa en memoria]
    E3[filter: x > 5<br/>Lista completa en memoria]
    E4[take: 2<br/>Resultado final]
    
    E1 --> E2
    E2 --> E3
    E3 --> E4
    
    M1["[2, 4, 6, 8, 10]"]
    M2["[6, 8, 10]"]
    M3["[6, 8]"]
    
    E2 -.->|Crea lista intermedia| M1
    E3 -.->|Crea lista intermedia| M2
    E4 -.->|Lista final| M3
    
    Note1["- 3 listas en memoria<br/> - Procesa TODOS los elementos<br/> - Cada paso espera al anterior"]
    
    M3 -.-> Note1
    
    style E1 fill:#e3f2fd,stroke:#1976d2
    style E2 fill:#ffcccc,stroke:#cc0000,stroke-width:2px
    style E3 fill:#ffcccc,stroke:#cc0000,stroke-width:2px
    style E4 fill:#c8e6c9,stroke:#2e7d32,stroke-width:2px
    style M1 fill:#fff3e0,stroke:#f57c00
    style M2 fill:#fff3e0,stroke:#f57c00
    style M3 fill:#fff3e0,stroke:#f57c00
    style Note1 fill:#ffebee,stroke:#c62828
</div>

### Evaluaci√≥n perezosa (Lazy)

En evaluaci√≥n perezosa, las operaciones se encolan y ejecutan bajo demanda:

```elixir
# Las operaciones se encolan, no se ejecutan
resultado = [1, 2, 3, 4, 5]
|> Stream.map(fn x -> x * 2 end)      # No ejecuta, solo define
|> Stream.filter(fn x -> x > 5 end)   # No ejecuta, solo define
|> Enum.take(2)                       # AQU√ç se ejecuta todo

# Solo se procesan los elementos necesarios
# 1*2=2 (descartado), 2*2=4 (descartado), 3*2=6 (tomado), 4*2=8 (tomado), ¬°detiene!
```

#### Diagrama de evaluaci√≥n perezosa

Podemos representar el proceso de evaluaci√≥n perezosa de la siguiente manera:

<div class="mermaid" style="text-align: center;">
graph TD
    S1[Lista original:<br/>1, 2, 3, 4, 5]
    S2["Pipeline (no ejecuta a√∫n):<br/>map: x * 2<br/>filter: x > 5<br/>take: 2"]
    S3[Enum.take fuerza evaluaci√≥n]
    S4[Procesa elemento por elemento]
    S5[Resultado final]
    
    S1 --> S2
    S2 -.->|Definici√≥n lazy| S3
    S3 --> S4
    
    P1["Elem 1: 1 ‚Üí *2=2 ‚Üí >5? ‚ùå"]
    P2["Elem 2: 2 ‚Üí *2=4 ‚Üí >5? ‚ùå"]
    P3["Elem 3: 3 ‚Üí *2=6 ‚Üí >5? ‚úÖ toma 1/2"]
    P4["Elem 4: 4 ‚Üí *2=8 ‚Üí >5? ‚úÖ toma 2/2"]
    P5["Elem 5: üõë nunca se procesa"]
    
    S4 --> P1
    S4 --> P2
    S4 --> P3
    S4 --> P4
    S4 --> P5
    
    P1 -.-> S5
    P2 -.-> S5
    P3 -.-> S5
    P4 -.-> S5
    P5 -.-> S5
    
    Result["[6, 8]"]
    S5 --> Result
    
    Note2["- 0 listas intermedias<br/> - Solo procesa 4 elementos<br/> - Se detiene cuando tiene suficientes"]
    
    Result -.-> Note2
    
    style S1 fill:#e3f2fd,stroke:#1976d2
    style S2 fill:#e1f5fe,stroke:#01579b,stroke-width:2px
    style S3 fill:#fff9c4,stroke:#f57f17
    style S4 fill:#fff9c4,stroke:#f57f17
    style P1 fill:#ffcccc,stroke:#cc0000
    style P2 fill:#ffcccc,stroke:#cc0000
    style P3 fill:#c8e6c9,stroke:#2e7d32
    style P4 fill:#c8e6c9,stroke:#2e7d32
    style P5 fill:#e0e0e0,stroke:#757575
    style Result fill:#c8e6c9,stroke:#2e7d32,stroke-width:3px
    style Note2 fill:#e8f5e9,stroke:#2e7d32
</div>

---

# Streams en Elixir

Un **Stream** es una **composici√≥n perezosa de transformaciones** sobre una colecci√≥n enumerable. Los Streams no almacenan datos, sino que definen **c√≥mo transformarlos** cuando sea necesario.

## Caracter√≠sticas clave

Las principales caracter√≠sticas de los Streams son:

1. **Lazy (perezoso)**: No ejecuta hasta que se fuerza con `Enum`.
2. **Composable**: Se pueden encadenar m√∫ltiples operaciones.
3. **Eficiente en memoria**: No crea estructuras intermedias.
4. **Infinito**: Puede representar secuencias sin fin.
5. **Un solo paso**: Procesa cada elemento una vez a trav√©s de todo el pipeline.

## ¬øCu√°ndo usar Streams?

Es recomendable utilizar **Streams** en situaciones donde se manejan **colecciones muy grandes**, como aquellas que contienen millones de elementos, o cuando es necesario procesar **archivos extensos** l√≠nea por l√≠nea. Tambi√©n resultan apropiados cuando solo se requieren **algunos elementos** del resultado, cuando se trabaja con **secuencias infinitas** o cuando se implementan **pipelines largos** con m√∫ltiples transformaciones. Asimismo, los Streams son convenientes cuando la fuente de datos es **costosa**, como una API o una base de datos, ya que permiten procesar la informaci√≥n de manera perezosa y eficiente.

Por el contrario, **no se recomienda emplear Streams** cuando las colecciones son **peque√±as**, especialmente si contienen menos de 1000 elementos, ya que pueden a√±adir complejidad innecesaria. Tampoco son adecuados cuando se necesita **la totalidad del resultado de inmediato** o cuando se requiere **iterar varias veces** sobre los mismos datos, dado que los Streams no permiten la reutilizaci√≥n. Finalmente, es preferible evitarlos cuando **la simplicidad del c√≥digo** es m√°s importante que la eficiencia, pues su uso puede dificultar la lectura y comprensi√≥n de soluciones simples.

## Comparaci√≥n Enum vs Stream

En la siguiente tabla se resumen las diferencias clave entre `Enum` y `Stream` en Elixir:

| Aspecto | Enum | Stream |
|---------|------|--------|
| **Evaluaci√≥n** | Inmediata (eager) | Diferida (lazy) |
| **Memoria** | Crea listas intermedias | Sin listas intermedias |
| **Velocidad (peque√±o)** | M√°s r√°pido | M√°s lento (overhead) |
| **Velocidad (grande)** | M√°s lento | M√°s r√°pido |
| **Resultado** | Lista/valor final | Stream (hasta forzar) |
| **Uso ideal** | Colecciones peque√±as | Colecciones grandes |

---

## Funciones principales del m√≥dulo Stream

El m√≥dulo `Stream` en Elixir proporciona una variedad de funciones para crear y manipular streams de datos de manera perezosa. Entre las funciones m√°s comunes se encuentran:

- `map/2`: Aplica una funci√≥n a cada elemento del stream.
- `filter/2`: Filtra elementos seg√∫n una condici√≥n.
- `reject/2`: Rechaza elementos seg√∫n una condici√≥n.
- `take/2`: Toma los primeros N elementos del stream.
- `take_while/2`: Toma elementos mientras se cumpla una condici√≥n.
- `drop_while/2`: Descarta elementos mientras se cumpla una condici√≥n.
- `drop/2`: Descarta los primeros N elementos del stream.
- `iterate/2`: Crea un stream infinito a partir de una funci√≥n iterativa.
- `chunk_every/2`: Agrupa elementos en lotes de tama√±o fijo.
- `chunk_by/2`: Agrupa elementos seg√∫n una funci√≥n.


---

## Ejemplo: Generar n√∫meros primos

Se requiere implementar un m√≥dulo en Elixir capaz de generar n√∫meros primos de forma perezosa, utilizando Streams para evitar el c√°lculo y almacenamiento innecesario de grandes cantidades de datos. El m√≥dulo debe cumplir las siguientes condiciones:

- Debe existir una funci√≥n `stream/0` que genere un `Stream` infinito de n√∫meros primos, comenzando desde 2.
  - El `Stream` no debe calcular todos los primos de antemano; debe producir cada n√∫mero solo cuando se lo solicite.

- Debe implementarse una funci√≥n `primeros/1` que reciba un entero `n` y retorne una lista con los primeros n n√∫meros primos, obtenidos a partir del `Stream` anterior.

- Debe existir una funci√≥n privada para verificar si un n√∫mero es primo.
  - La verificaci√≥n debe comprobar divisores solo hasta la ra√≠z cuadrada del n√∫mero para mantener la eficiencia.

- Con el m√≥dulo implementado, debe ser posible:
  - Obtener los primeros 10 n√∫meros primos.
  - Obtener todos los n√∫meros primos comprendidos entre 100 y 200 utilizando operaciones de `Stream` como `drop_while` y `take_while`.

A continuaci√≥n se presenta una posible implementaci√≥n del m√≥dulo `Primos` que cumple con los requisitos mencionados:

```elixir
defmodule Primos do
  def stream do
    Stream.iterate(2, &(&1 + 1)) # Genera n√∫meros enteros a partir de 2
    |> Stream.filter(&es_primo?/1) # Filtra solo los n√∫meros primos
  end

  def primeros(n) do
    stream() |> Enum.take(n) # Toma los primeros n n√∫meros primos
  end

  defp es_primo?(n) when n < 2, do: false
  defp es_primo?(2), do: true
  defp es_primo?(n) do
    limite = :math.sqrt(n)
    Stream.iterate(2, &(&1 + 1)) # Genera n√∫meros enteros a partir de 2
    |> Stream.take_while(&(&1 <= limite)) # Toma hasta la ra√≠z cuadrada de n
    |> Enum.all?(fn x -> rem(n, x) != 0 end) # Verifica que n no sea divisible por ninguno
  end

  def main do
    # Generar los primeros 10 primos
    primeros(10) # => [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

    # Primos entre 100 y 200
    stream()
    |> Stream.drop_while(fn x -> x < 100 end)
    |> Stream.take_while(fn x -> x <= 200 end)
    |> Enum.to_list()
  end

end

Primos.main()
```

A diferencia de una implementaci√≥n que calculara todos los n√∫meros primos hasta un l√≠mite dado, este enfoque con `Streams` permite generar y verificar cada n√∫mero primo solo cuando es necesario, optimizando el uso de memoria y tiempo de procesamiento.

---

## Usos comunes de Streams

Algunos casos comunes donde los `Streams` son especialmente √∫tiles incluyen:

- **Archivos grandes**, l√≠nea a l√≠nea, sin cargar todo en memoria.
- **Secuencias infinitas**, n√∫meros que se generan bajo demanda y se procesan parcialmente.
- **Pipelines complejos**, donde cada elemento pasa una sola vez, sin listas intermedias.
- **Integraci√≥n con APIs o bases de datos**, paginaci√≥n lazy, solo se traen los datos necesarios.

---

## Para la pr√≥xima clase

- Investigar m√°s sobre el m√≥dulo `Stream` y sus funciones.
- Practicar con ejemplos de `Streams` en Elixir.
- Leer sobre el manejo de archivos en Elixir.
