<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script> 
<script> 
  document.addEventListener("DOMContentLoaded", function() { mermaid.initialize({ startOnLoad: true }); }); 
</script>

```
Universidad del Quindío
Programa de Ingeniería de Sistemas y Computación
Programación III - Streams
Docente: Carlos Andrés Florez V.
```

# Evaluación perezosa (Lazy Evaluation)

La evaluación perezosa es una característica de algunos lenguajes de programación, como Elixir, que permite **diferir la evaluación de una expresión hasta que su valor sea realmente necesario**. Esto puede mejorar la eficiencia y permitir la creación de estructuras de datos infinitas, como las listas infinitas.

En Elixir, las listas son evaluadas de manera estricta, lo que significa que todos sus elementos son evaluados inmediatamente. Sin embargo, Elixir proporciona el módulo `Stream`, que permite trabajar con secuencias de datos de manera perezosa.

La **evaluación perezosa** ofrece varias ventajas:

1. **Mejorar la eficiencia**: Evita cálculos innecesarios
2. **Reducir el uso de memoria**: No crea estructuras intermedias
3. **Permitir secuencias infinitas**: Genera valores bajo demanda
4. **Optimizar pipelines**: Procesa elementos uno a la vez en lugar de crear copias completas

## Evaluación estricta vs perezosa

A continuación, se muestra una comparación entre la evaluación estricta (usando `Enum`) y la evaluación perezosa (usando `Stream`) en Elixir.

### Evaluación estricta (Eager)

En evaluación estricta, todas las operaciones se ejecutan inmediatamente:

```elixir
# Cada operación crea una nueva lista completa
resultado = [1, 2, 3, 4, 5]
|> Enum.map(fn x -> x * 2 end)        # [2, 4, 6, 8, 10] - Lista completa en memoria
|> Enum.filter(fn x -> x > 5 end)     # [6, 8, 10] - Nueva lista en memoria
|> Enum.take(2)                       # [6, 8] - Otra lista en memoria
```

**Proceso:**
```
[1,2,3,4,5] 
    ↓ map (*2)
[2,4,6,8,10] ← Lista intermedia 1
    ↓ filter (>5)
[6,8,10] ← Lista intermedia 2
    ↓ take(2)
[6,8] ← Resultado final

Total: 3 listas en memoria
```

### Evaluación perezosa (Lazy)

En evaluación perezosa, las operaciones se encolan y ejecutan bajo demanda:

```elixir
# Las operaciones se encolan, no se ejecutan
resultado = [1, 2, 3, 4, 5]
|> Stream.map(fn x -> x * 2 end)      # No ejecuta, solo define
|> Stream.filter(fn x -> x > 5 end)   # No ejecuta, solo define
|> Enum.take(2)                       # AQUÍ se ejecuta todo

# Solo se procesan los elementos necesarios
# 1*2=2 (descartado), 2*2=4 (descartado), 3*2=6 (tomado), 4*2=8 (tomado), ¡detiene!
```

**Proceso:**
```
Elemento 1: 1 → *2 → 2 → >5? NO → descarta
Elemento 2: 2 → *2 → 4 → >5? NO → descarta  
Elemento 3: 3 → *2 → 6 → >5? SÍ → toma (1/2)
Elemento 4: 4 → *2 → 8 → >5? SÍ → toma (2/2) ¡DETIENE!
Elemento 5: nunca se procesa

Total: 0 listas intermedias, procesa solo 4 elementos
```

---

# Streams en Elixir

Un **Stream** es una **composición perezosa de transformaciones** sobre una colección enumerable. Los Streams no almacenan datos, sino que definen **cómo transformarlos** cuando sea necesario.

## Características clave

Las principales características de los Streams son:

1. **Lazy (perezoso)**: No ejecuta hasta que se fuerza con `Enum`.
2. **Composable**: Se pueden encadenar múltiples operaciones.
3. **Eficiente en memoria**: No crea estructuras intermedias.
4. **Infinito**: Puede representar secuencias sin fin.
5. **Un solo paso**: Procesa cada elemento una vez a través de todo el pipeline.

## ¿Cuándo usar Streams?

Es recomendable utilizar **Streams** en situaciones donde se manejan **colecciones muy grandes**, como aquellas que contienen millones de elementos, o cuando es necesario procesar **archivos extensos** línea por línea. También resultan apropiados cuando solo se requieren **algunos elementos** del resultado, cuando se trabaja con **secuencias infinitas** o cuando se implementan **pipelines largos** con múltiples transformaciones. Asimismo, los Streams son convenientes cuando la fuente de datos es **costosa**, como una API o una base de datos, ya que permiten procesar la información de manera perezosa y eficiente.

Por el contrario, **no se recomienda emplear Streams** cuando las colecciones son **pequeñas**, especialmente si contienen menos de 1000 elementos, ya que pueden añadir complejidad innecesaria. Tampoco son adecuados cuando se necesita **la totalidad del resultado de inmediato** o cuando se requiere **iterar varias veces** sobre los mismos datos, dado que los Streams no permiten la reutilización. Finalmente, es preferible evitarlos cuando **la simplicidad del código** es más importante que la eficiencia, pues su uso puede dificultar la lectura y comprensión de soluciones simples.

## Comparación Enum vs Stream

| Aspecto | Enum | Stream |
|---------|------|--------|
| **Evaluación** | Inmediata (eager) | Diferida (lazy) |
| **Memoria** | Crea listas intermedias | Sin listas intermedias |
| **Velocidad (pequeño)** | Más rápido | Más lento (overhead) |
| **Velocidad (grande)** | Más lento | Más rápido |
| **Resultado** | Lista/valor final | Stream (hasta forzar) |
| **Uso ideal** | Colecciones pequeñas | Colecciones grandes |

---

## Funciones principales del módulo Stream

El módulo `Stream` en Elixir proporciona una variedad de funciones para crear y manipular streams de datos de manera perezosa. Entre las funciones más comunes se encuentran:

- `map/2`: Aplica una función a cada elemento del stream.
- `filter/2`: Filtra elementos según una condición.
- `reject/2`: Rechaza elementos según una condición.
- `flat_map/2`: Aplica una función y aplana el resultado.
- `take/2`: Toma los primeros N elementos del stream.
- `drop/2`: Descarta los primeros N elementos del stream.
- `iterate/2`: Crea un stream infinito a partir de una función iterativa.
- `chunk_every/2`: Agrupa elementos en lotes de tamaño fijo.
- `chunk_by/2`: Agrupa elementos según una función.
- `zip/2`: Combina dos streams en uno de tuplas.
- `concat/2`: Concatena dos streams.

---

## Ejemplos prácticos

### Ejemplo 1: Generar números primos

Se requiere implementar un módulo en Elixir capaz de generar números primos de forma perezosa, utilizando Streams para evitar el cálculo y almacenamiento innecesario de grandes cantidades de datos. El módulo debe cumplir las siguientes condiciones:

- Debe existir una función `stream/0` que genere un `Stream` infinito de números primos, comenzando desde 2.
  - El `Stream` no debe calcular todos los primos de antemano; debe producir cada número solo cuando se lo solicite.

- Debe implementarse una función `primeros/1` que reciba un entero `n` y retorne una lista con los primeros n números primos, obtenidos a partir del `Stream` anterior.

- Debe existir una función privada para verificar si un número es primo.
  - La verificación debe comprobar divisores solo hasta la raíz cuadrada del número para mantener la eficiencia.

- Con el módulo implementado, debe ser posible:
  - Obtener los primeros 10 números primos.
  - Obtener todos los números primos comprendidos entre 100 y 200 utilizando operaciones de `Stream` como `drop_while` y `take_while`.

A continuación se presenta una posible implementación del módulo `Primos` que cumple con los requisitos mencionados:

```elixir
defmodule Primos do
  def stream do
    Stream.iterate(2, &(&1 + 1)) # Genera números enteros a partir de 2
    |> Stream.filter(&es_primo?/1) # Filtra solo los números primos
  end

  def primeros(n) do
    stream() |> Enum.take(n) # Toma los primeros n números primos
  end

  defp es_primo?(n) when n < 2, do: false
  defp es_primo?(2), do: true
  defp es_primo?(n) do
    limite = :math.sqrt(n)
    Stream.iterate(2, &(&1 + 1)) # Genera números enteros a partir de 2
    |> Stream.take_while(&(&1 <= limite)) # Toma hasta la raíz cuadrada de n
    |> Enum.all?(fn x -> rem(n, x) != 0 end) # Verifica que n no sea divisible por ninguno
  end

  def main do
    # Generar los primeros 10 primos
    primeros(10) # => [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]

    # Primos entre 100 y 200
    stream()
    |> Stream.drop_while(fn x -> x < 100 end)
    |> Stream.take_while(fn x -> x <= 200 end)
    |> Enum.to_list()
  end

end

Primos.main()
```

### Ejemplo 2: Procesamiento de datos en lotes

Una empresa necesita procesar una lista muy grande de usuarios antes de enviarlos a un servicio externo. Debido al tamaño de los datos, no es viable cargar toda la información procesada en memoria. Por ello, se requiere implementar un sistema de procesamiento **perezoso** y **en lotes**, aprovechando Streams en Elixir.

Se solicita desarrollar un módulo llamado `ProcesadorBatch` que cumpla con los siguientes requisitos:

1. Debe existir una función `procesar_usuarios/1` que reciba una lista potencialmente muy grande de usuarios.
   Esta función debe aplicar una **pipeline de operaciones con Streams**, sin cargar toda la información procesada en memoria.

2. El procesamiento de usuarios debe cumplir los siguientes pasos:

   * **Filtrar** solo aquellos usuarios cuyo campo `activo` sea `true`.
   * **Normalizar** los datos de cada usuario:

     * convertir el email a minúsculas,
     * eliminar espacios extra en el nombre,
     * y conservar únicamente `id`, `email` normalizado y `nombre` normalizado.
   * **Agrupar** los usuarios en **lotes de 100 elementos**.
   * **Enviar cada lote** a una función que simule una llamada a un servicio externo (API).

3. La función encargada de enviar un lote debe:

   * imprimir un mensaje indicando cuántos usuarios contiene el lote,
   * simular un retardo de 100 ms para imitar la latencia de la API.

4. El flujo completo debe ejecutarse con un `Stream.run/0`, ya que no se requiere retornar ningún valor al finalizar el proceso.

El objetivo es que el módulo permita procesar listas extremadamente grandes sin saturar la memoria, utilizando únicamente evaluación perezosa mediante Streams.

A continuación se presenta una posible implementación del módulo `ProcesadorBatch` que cumple con los requisitos mencionados:

```elixir
defmodule ProcesadorBatch do
  def procesar_usuarios(usuarios) do
    usuarios
    |> Stream.filter(&usuario_activo?/1)
    |> Stream.map(&normalizar_datos/1)
    |> Stream.chunk_every(100)  # Lotes de 100
    |> Stream.each(&enviar_a_api/1) # Simular envío a API
    |> Stream.run()  # Ejecuta todo sin retornar resultado, si no usamos run, no se ejecuta nada ya que es lazy
  end

  defp usuario_activo?(%{activo: true}), do: true
  defp usuario_activo?(_), do: false

  defp normalizar_datos(usuario) do
    %{
      id: usuario.id,
      email: String.downcase(usuario.email),
      nombre: String.trim(usuario.nombre)
    }
  end

  defp enviar_a_api(lote) do
    # Simular llamada a API
    IO.puts("Enviando lote de #{length(lote)} usuarios a la API...")
  end

  def main do
    # Simulación de una lista grande de usuarios
    usuarios = for i <- 1..10_000 do
      %{
        id: i,
        email: "usuario#{i}@ejemplo.com",
        nombre: "Usuario #{i}",
        activo: rem(i, 2) == 0  # Activo si el ID es par
      }
    end

    procesar_usuarios(usuarios)
  end
end

ProcesadorBatch.main()
```

### Ejemplo 3: Pipeline complejo

Una empresa desea analizar una gran lista de ventas generada por su sistema interno. Cada venta es representada como un mapa con la siguiente estructura:

```elixir
%{
  cliente_id: entero,
  producto: cadena,
  cantidad: entero,
  precio: float
}
```

Cada elemento de la lista corresponde a una venta realizada por un cliente. Los datos pueden ser muy numerosos, por lo que se busca aplicar **procesamiento eficiente con Streams** siempre que sea posible. Se **solicita implementar** un módulo `AnalizadorVentas` que cumpla con los siguientes requisitos:

1. Implementar la función `reporte_top_clientes/1`, que debe recibir una **lista de ventas** y producir una lista con los **10 clientes que más dinero han generado**, ordenados de mayor a menor ingreso total.

2. El procesamiento debe realizarse de la siguiente manera:

   * **Ignorar ventas inválidas**, es decir, aquellas donde `cantidad <= 0` o `precio <= 0`.
   * **Parsear o normalizar** cada venta según sea necesario (por ejemplo, convertir valores numéricos si vienen como cadenas).
   * Calcular el **total de cada venta** multiplicando `cantidad * precio`.
   * Agrupar las ventas por `cliente_id`.
   * Para cada cliente:

     * sumar el total de todas sus compras,
     * contar cuántas ventas ha realizado.
   * Ordenar los clientes por `total_ventas` en orden descendente.
   * Retornar los **10 primeros**.

3. Cada elemento del resultado debe tener la estructura:

```elixir
%{
  cliente_id: ...,
  total_ventas: ...,
  cantidad_compras: ...
}
```

Este análisis permitirá identificar a los clientes más valiosos y obtener métricas útiles para la toma de decisiones comerciales.

A continuación se presenta una posible implementación del módulo `AnalizadorVentas` que cumple con los requisitos mencionados:


```elixir
defmodule AnalizadorVentas do
  def reporte_top_clientes(ventas) do
    ventas
    |> Stream.filter(&venta_valida?/1) # Filtrar ventas válidas
    |> Stream.map(&calcular_total/1) # Calcular total por venta
    |> Enum.group_by(& &1.cliente_id) # Agrupar por cliente_id
    |> Enum.map(fn {cliente, ventas} -> 
      %{
        cliente_id: cliente,
        total_ventas: Enum.reduce(ventas, 0, fn v, acc -> v.total + acc end),
        cantidad_compras: length(ventas)
      }
    end)
    |> Enum.sort_by(& &1.total_ventas, :desc) # Ordenar por total_ventas descendente
    |> Enum.take(10)
  end

  defp venta_valida?(%{cantidad: c, precio: p}) when c > 0 and p > 0, do: true
  defp venta_valida?(_), do: false

  defp calcular_total(venta) do
    Map.put(venta, :total, venta.cantidad * venta.precio)
  end
end

```

---

## Buenas prácticas con Streams

Cuando se trabaja con Streams en Elixir, es importante seguir ciertas buenas prácticas para maximizar su eficiencia y legibilidad. A continuación, se presentan algunas recomendaciones clave:

### 1. Forzar evaluación al final

Siempre utilice `Enum` para forzar la evaluación del Stream al final de la cadena de transformaciones. Esto asegura que todas las operaciones perezosas se ejecuten en el momento adecuado.

```elixir
# Malo: múltiples evaluaciones
stream = Stream.map(1..100, &(&1 * 2))
Enum.take(stream, 5)
Enum.take(stream, 5)  # Re-evalúa desde cero

# Bueno: evaluar una vez si se reutiliza
lista = Stream.map(1..100, &(&1 * 2)) |> Enum.to_list()
Enum.take(lista, 5)
Enum.take(lista, 5)  # No re-evalúa
```

### 2. Combinar con Enum apropiadamente

Las funciones de `Stream` deben usarse para transformaciones, mientras que las funciones de `Enum` son ideales para operaciones que requieren el resultado final.

```elixir
# Stream para transformaciones, Enum para finalizar
1..1_000_000
|> Stream.map(&(&1 * 2))
|> Stream.filter(&(&1 > 1000))
|> Enum.take(100)  # Fuerza evaluación
```

### 3. No usar Stream para colecciones pequeñas

Para colecciones pequeñas, `Enum` suele ser más eficiente debido a la sobrecarga de `Stream`.

```elixir
# Malo: overhead innecesario
[1, 2, 3, 4, 5]
|> Stream.map(&(&1 * 2))
|> Enum.to_list()

# Bueno: Enum es más directo
[1, 2, 3, 4, 5]
|> Enum.map(&(&1 * 2))
```

---

## Ejercicios

Para practicar el uso de Streams en Elixir, se proponen los siguientes ejercicios:

### Ejercicio 1: Procesador de números

Implemente un stream que:
1. Genere la secuencia de Fibonacci infinita
2. Filtre solo números pares
3. Tome los primeros 20
4. Calcule su suma

### Ejercicio 2: Generador de contraseñas

Cree un stream que genere contraseñas seguras:
1. Combine letras, números y símbolos
2. Longitud configurable
3. Genere infinitas contraseñas únicas
4. Permita tomar N contraseñas

---

## Para la próxima clase

1. **Manejo de archivos en Elixir**:
   - Módulos `File` y `Path`
   - Leer y escribir archivos
   - Streams de archivos

2. **Practicar con Streams**:
   - Experimentar con funciones del módulo Stream
   - Comparar rendimiento Enum vs Stream
   - Crear streams personalizados