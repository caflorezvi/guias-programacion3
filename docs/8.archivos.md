```
Universidad del Quindío
Programa de Ingeniería de Sistemas y Computación
Programación III - Manejo de archivos
Docente: Carlos Andrés Florez V.
```

# Manejo de archivos

Elixir proporciona varias herramientas para trabajar con archivos, principalmente a través de los módulos `File` y `Path`. Estas herramientas permiten leer, escribir, y manipular archivos y directorios de una manera funcional y segura.

## Módulo `File`

El módulo `File` contiene funciones para interactuar con el sistema de archivos. Algunas de las funciones más comunes son:

- `File.read/1`: Lee el contenido de un archivo y lo devuelve como un binario.
- `File.write/2`: Escribe datos en un archivo.
- `File.open/2`: Abre un archivo con un modo específico (por ejemplo, `:read`, `:write`).
- `File.close/1`: Cierra un archivo abierto.
- `File.stream!/2`: Crea un stream a partir de un archivo, permitiendo leerlo línea por línea de manera perezosa.

## Módulo `Path`

El módulo `Path` ofrece utilidades para trabajar con rutas de archivos de forma independiente del sistema operativo.

- `Path.join/2`: Une dos partes de una ruta.
- `Path.expand/1`: Convierte una ruta relativa en una ruta absoluta.
- `Path.dirname/1`: Devuelve el nombre del directorio de una ruta.
- `Path.basename/1`: Devuelve el nombre del archivo de una ruta.

---

## Leer archivos y Pattern Matching

La forma más sencilla de leer un archivo es usando `File.read/1`. Esta función, como muchas otras en Elixir, sigue la convención de devolver una tupla para indicar el éxito o el fracaso de la operación.

- Si la lectura es **exitosa**, devuelve `{:ok, contenido}`, donde `contenido` es un binario con los datos del archivo.
- Si ocurre un **error** (por ejemplo, el archivo no existe), devuelve `{:error, razon}`, donde `razon` es un átomo que describe el error (ej. `:enoent` para "No such file or directory").

Para manejar estos dos posibles resultados, se utiliza la construcción `case` junto con **pattern matching**. Esto permite "desempaquetar" la tupla y actuar de manera diferente según el resultado.

### Ejemplo

```elixir
defmodule Lector do
  def leer_archivo(ruta) do
    case File.read(ruta) do
      # Si el resultado coincide con este patrón, el contenido se asigna a la variable `contenido`
      {:ok, contenido} ->
        IO.puts("Contenido del archivo:")
        IO.puts(contenido)
      # Si coincide con este otro, la razón del error se asigna a la variable `razon`
      {:error, razon} ->
        IO.puts("Error al leer el archivo: #{reason}")
    end
  end
end

Lector.leer_archivo("mi_archivo.txt")
```

## Escribir archivos

Para escribir en un archivo, se puede usar `File.write/2`. Esta función sobrescribirá el contenido del archivo si ya existe. Su retorno también puede ser manejado con `case`:

- `:ok` si la escritura fue exitosa.
- `{:error, razon}` si hubo un problema.

### Ejemplo

```elixir
defmodule Escritor do
  def escribir_archivo(ruta, contenido) do
    case File.write(ruta, contenido) do
      :ok ->
        IO.puts("Archivo escrito exitosamente.")
      {:error, razon} ->
        IO.puts("Error al escribir el archivo: #{reason}")
    end
  end
end

Escritor.escribir_archivo("nuevo_archivo.txt", "Este es el contenido.")
```

## Procesar archivos grandes con Streams

Cuando se trabaja con archivos muy grandes, no es eficiente cargarlos completamente en memoria. En su lugar, se puede usar `File.stream!/1` para crear un **stream**. Un stream es una colección "perezosa" (lazy), lo que significa que el archivo se lee pieza por pieza (generalmente línea por línea) solo cuando se necesita. Esto es ideal para procesar datos secuencialmente usando el módulo `Enum`.

### La convención del `!` en `File.stream!`

En Elixir, es una convención que las funciones que terminan con un signo de exclamación (`!`) pueden **lanzar un error** si fallan, en lugar de devolver una tupla `{:error, ...}`. `File.stream!/1` sigue esta convención: si el archivo no se puede abrir, lanzará un error y detendrá el programa. La versión "segura", `File.stream/1`, devolvería `{:ok, stream}` o `{:error, razon}`, permitiendo manejar el error con `case`.

Se usa la versión con `!` en pipelines (`|>`) cuando se asume que el archivo debe existir y cualquier fallo es considerado una excepción que debe detener el flujo normal.

### ¿Cómo procesa `Enum` un stream?

Un stream es como una "receta" para generar una secuencia de datos, no los datos en sí. Cuando se pasa un stream a una función del módulo `Enum` (como `Enum.count`, `Enum.map`, etc.), ocurre lo siguiente:

1. `Enum` le pide al stream el **primer elemento** (la primera línea del archivo).
2. El stream lee solo esa primera línea del disco y se la entrega a `Enum`.
3. `Enum` procesa ese elemento (en el caso de `count`, incrementa un contador interno).
4. `Enum` le pide al stream el **segundo elemento**.
5. El stream lee la segunda línea del disco y se la entrega.
6. Este proceso se repite hasta que el stream se queda sin elementos.

De esta manera, en ningún momento se carga el archivo completo en memoria. `Enum` "tira" de los datos del stream uno por uno, haciéndolo increíblemente eficiente para archivos de cualquier tamaño.

### Ejemplo: Contar líneas de un archivo

```elixir
defmodule ContadorLineas do
  def contar(ruta) do
    ruta
    |> File.stream!() # 1. Abre un stream (receta para leer el archivo)
    |> Enum.count()   # 2. Pide los elementos uno a uno y los cuenta
  end
end

numero_lineas = ContadorLineas.contar("mi_archivo_grande.txt")
IO.puts("El archivo tiene #{numero_lineas} líneas.")
```

---

## Ejercicios

### Ejercicio 1: Frecuencia de palabras

Se requiere un programa que lea un archivo de texto, cuente la frecuencia de cada palabra y guarde los resultados en un nuevo archivo llamado `frecuencia.txt`. El resultado debe tener el formato `palabra: frecuencia`.

### Ejercicio 2: Procesamiento de datos de un CSV

Para este ejercicio, se asume que existe un archivo `productos.csv` con el siguiente formato:

```csv
nombre,precio,cantidad
Laptop,1200,10
Mouse,25,50
Teclado,75,30
Monitor,300,15
```

Se debe crear un módulo que realice lo siguiente:
1. Leer el archivo `productos.csv`.
2. Ignorar la primera línea (el encabezado).
3. Convertir cada línea en un mapa, por ejemplo: `%{nombre: "Laptop", precio: 1200, cantidad: 10}`.
4. Calcular el valor total del inventario (la suma de `precio * cantidad` para todos los productos).
5. Imprimir en consola el valor total del inventario.

**Pista:** Se recomienda utilizar `File.stream!/1`, `Enum.drop/2`, `Enum.map/2`, `String.split/2` y `String.to_integer/1`.

### Ejercicio 3: Informe de directorio

Se debe desarrollar un script que reciba una ruta a un directorio y genere un archivo `informe.txt` que liste todos los archivos de ese directorio junto con su tamaño en bytes.

---

## Para la próxima clase

Se proponen los siguientes temas para investigación:

- Las diferentes opciones y modos que se pueden usar con `File.open/2`.
- Qué es `Stream` y cómo se utiliza en Elixir, como representa la evaluación perezosa de datos.