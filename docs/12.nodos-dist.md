```
Universidad del Quindío
Programa de Ingeniería de Sistemas y Computación
Programación III - Aplicaciones Distribuidas y Concurrentes
Docente: Carlos Andrés Florez V.
```

# Aplicaciones distribuidas

En los ejemplos vistos en las clases anteriores, **todos los procesos se ejecutaban en un mismo nodo** dentro de la máquina virtual BEAM. Sin embargo, Elixir también permite crear **aplicaciones distribuidas**, donde los procesos pueden ejecutarse en **nodos diferentes**, ya sea dentro de una misma máquina o en equipos distintos conectados por red.

Esta capacidad de distribución se logra mediante el módulo `Node`, que proporciona las herramientas necesarias para **gestionar y comunicar nodos** dentro del entorno distribuido de Elixir.

## Requisitos previos para la comunicación distribuida

Antes de trabajar con aplicaciones distribuidas en Elixir, es importante entender tres conceptos fundamentales que hacen posible la comunicación entre nodos:

### 1. El demonio EPMD (Erlang Port Mapper Daemon)

**EPMD** es un servicio que actúa como un directorio de nodos en la máquina virtual BEAM. Su función principal es:

- **Registrar nodos**: Cuando se inicia un nodo distribuido, este se registra automáticamente en `epmd`.
- **Resolver nombres**: Permite que los nodos se encuentren entre sí, mapeando nombres de nodos a puertos de red.
- **Facilitar conexiones**: Actúa como intermediario para establecer la comunicación inicial entre nodos.

**Verificar si EPMD está corriendo:**

```bash
epmd -names
```

Si no está corriendo, verá un mensaje de error. Puede iniciarlo manualmente con:

```bash
epmd -daemon
```

Sin embargo, en la mayoría de los casos, **EPMD se inicia automáticamente** cuando se ejecuta el primer nodo distribuido. Es importante verificar que esté activo antes de comenzar a trabajar con aplicaciones distribuidas.

### 2. Cookies de autenticación

Las **cookies** son un mecanismo de seguridad simple que asegura que solo los nodos autorizados puedan comunicarse entre sí. Funcionan como una contraseña compartida:

- **Todos los nodos que deseen comunicarse deben tener la misma cookie**.
- Si las cookies no coinciden, la conexión será rechazada.
- Se establecen mediante `Node.set_cookie/1` o con la bandera `--cookie` al iniciar `iex`.

**Importante:** Las cookies NO son un mecanismo de seguridad robusto. En entornos de producción, se deben implementar medidas adicionales como firewalls, VPNs o TLS.

### 3. Requisitos de red

Para que dos nodos se comuniquen, deben cumplirse las siguientes condiciones de red:

- **Conectividad de red**: Los nodos deben poder alcanzarse mutuamente a través de la red.
- **Puertos abiertos**: 
  - EPMD escucha en el puerto **4369** por defecto.
  - Cada nodo usa un puerto dinámico adicional para la comunicación directa.
- **Resolución de nombres**: Los nodos deben poder resolver los nombres de host de los demás (usando DNS, `/etc/hosts`, o direcciones IP directamente).
- **Firewall**: Asegúrese de que el firewall no esté bloqueando los puertos necesarios.

**Para nodos en la misma máquina:** Estos requisitos se cumplen automáticamente usando `localhost`.

**Para nodos en máquinas diferentes:** Debe verificar la conectividad con herramientas como `ping` y asegurarse de que los puertos estén abiertos.

---

## Módulo Node

El módulo `Node` ofrece funciones para trabajar con **nodos distribuidos** y facilitar la comunicación entre ellos. Algunas de las más utilizadas son:

- `Node.start/1` o `Node.start/2`: inicia un nodo con un nombre específico.
- `Node.connect/1`: establece una conexión con otro nodo en la red.
- `Node.list/0`: devuelve la lista de nodos actualmente conectados.
- `Node.self/0`: obtiene el nombre del nodo actual.
- `Node.set_cookie/1`: establece la cookie de autenticación para la comunicación entre nodos.
- `Node.spawn_link/2`: permite crear un proceso en un nodo remoto y enlazarlo con el proceso local.

Gracias a estas funciones, es posible construir **sistemas distribuidos** en Elixir donde los procesos se comunican y colaboran de forma transparente, sin importar si se encuentran en el mismo equipo o en distintos dispositivos conectados a la red.

### Nombres de nodos

Cada nodo debe tener un nombre que lo identifica de forma única en el clúster, y este nombre puede ser **corto** o **completo** (también llamados *shortnames* y *longnames*).

#### Nombres cortos (shortnames)

Se utilizan cuando los nodos se ejecutan **en la misma máquina**. Son más simples y cómodos para entornos locales o de desarrollo.

**Formato:** `:nombre_nodo` o `:nombre_nodo@localhost`

**Ejemplos:**
```elixir
# Implícito: se asume el hostname de la máquina
Node.start(:nodo1, :shortnames)
# Resultado: :nodo1@nombre_de_tu_maquina

# Explícito con localhost
Node.start(:nodo1@localhost, :shortnames)
# Resultado: :nodo1@localhost
```

**Al iniciar con iex:**
```bash
iex --sname nodo1
# Esto crea automáticamente :nodo1@nombre_de_tu_maquina
```

#### Nombres completos (longnames)

Se utilizan cuando los nodos se ejecutan **en máquinas diferentes** conectadas por red. La parte después del `@` corresponde al **nombre del host** o la **dirección IP** de cada máquina.

**Formato:** `:nombre_nodo@hostname` o `:nombre_nodo@direccion_ip`

**Ejemplos:**
```elixir
# Con nombre de host
Node.start(:servidor@miservidor.local, :longnames)

# Con dirección IP
Node.start(:"servidor@192.168.1.100", :longnames)
# Nota: Se usa :"..." cuando hay caracteres especiales como puntos
```

**Al iniciar con iex:**
```bash
# Con nombre de host
iex --name servidor@miservidor.local

# Con dirección IP
iex --name servidor@192.168.1.100
```

**Regla importante:** No se pueden conectar nodos con shortnames a nodos con longnames. Todos los nodos del clúster deben usar el mismo tipo de nombre.

---

## Comunicación entre nodos

En Elixir (y Erlang), los nodos pueden comunicarse entre sí a través de la red, siempre que compartan la misma **cookie de autenticación** y estén registrados en el **sistema de distribución** de la máquina virtual BEAM.

### Primitivas de concurrencia distribuidas

Una vez que los nodos están conectados y comparten la misma cookie, es posible usar todas las primitivas de concurrencia de Elixir/Erlang entre nodos:

- Enviar y recibir mensajes con `send/2` y `receive`.
- Utilizar `:rpc` para ejecutar funciones de forma remota en otros nodos.
- Usar `:global` para registrar procesos con nombres globales.

Estas herramientas permiten construir sistemas distribuidos donde la comunicación entre nodos se comporta de forma transparente, como si todos los procesos vivieran en una misma máquina.

---

## Comunicación entre nodos con `send/2` y `receive`

Vamos a crear dos nodos en la misma máquina y establecer una conexión entre ambos. La idea es tener un nodo que envía un mensaje y otro que lo recibe. La diferencia respecto a los ejemplos anteriores es que ahora los procesos se pueden ejecutar de manera distribuida.

### Versión 1 (iex)

En esta versión, abrimos iex en dos terminales independientes y escribimos los comandos directamente en cada una. **No es lo más práctico**, pero es útil para entender cómo funciona la comunicación entre nodos.

#### 1. Iniciar el nodo receptor

En una terminal, ejecutamos:

```bash
iex --sname nodo2 --cookie mi_cookie 
```

La bandera `--sname` permite asignar un nombre corto al nodo (*shortname*), que es útil para nodos en la misma máquina. Si los nodos están en diferentes máquinas, se puede usar `--name` para asignar un nombre completo con el formato `nombre@host`. 

La cookie es opcional, pero como se mencionó anteriormente, es recomendable establecerla para asegurar que solo los nodos con la misma cookie puedan comunicarse.

#### 2. Creación del proceso que recibe mensajes

En la terminal donde está `nodo2`, ejecutamos el siguiente código para recibir el mensaje:

```elixir
# Se crea un proceso con un nombre propio
Process.register(self(), :proceso_en_nodo2)

IO.puts("Nodo iniciado correctamente: #{Node.self()}")
IO.puts("Esperando mensajes...")

# Esperar y recibir mensajes
receive do
  {:mensaje, msg} -> IO.puts("Recibido en nodo 2: #{msg}")
end
```

El `nodo2` será un receptor de mensajes. El proceso creado se registra con el nombre `:proceso_en_nodo2` para que pueda ser referenciado desde otros nodos.

#### 3. Iniciar el nodo emisor

En otra terminal diferente, ejecutamos:

```bash
iex --sname nodo1 --cookie mi_cookie
```

Es importante que los nombres de los nodos sean únicos en la red para evitar conflictos.

#### 4. Enviar un mensaje desde otro nodo

En la nueva terminal (`nodo1`) ejecutamos el siguiente código para conectarnos a `nodo2` y enviarle un mensaje:

```elixir
# Primero, conectarse al nodo2
Node.connect(:nodo2@tu_maquina) # Reemplaza 'tu_maquina' con el nombre de tu máquina

# Enviar el mensaje
send({:proceso_en_nodo2, :nodo2@tu_maquina}, {:mensaje, "Hola desde nodo 1"})
``` 

La comunicación entre nodos se establece usando el nombre completo del nodo receptor. Siguiendo el formato `nombre@host`, donde `host` es el nombre de la máquina donde se está ejecutando el nodo receptor.

**Para saber el nombre de `tu_maquina`:** Fíjese en la consola del `nodo2`, donde dice: `Nodo iniciado correctamente: nodo2@tu_maquina`.

> ⚠️ **Importante:** En este caso, la función `send/2` tiene un formato especial para referenciar procesos en nodos remotos: se usa una tupla con el nombre del proceso y el nombre del nodo: `{nombre_proceso, nombre_nodo}`.

#### 5. Verificar la comunicación

En la terminal de `nodo2`, debería ver el mensaje recibido:

```
Recibido en nodo 2: Hola desde nodo 1
```

El `nodo2` solo recibe un mensaje y luego termina. Si desea enviar más mensajes, debe ejecutar nuevamente el bloque `receive` o crear un bucle para mantener el proceso activo.

Tenga en cuenta que, para que esto funcione, **ambos nodos deben estar en la misma red** y ser capaces de comunicarse entre sí. No necesariamente deben estar en la misma máquina, pero sí deben poder resolver los nombres de los nodos entre sí.

### Versión 2 (scripts)

En lugar de escribir los comandos directamente en la consola, podemos crear archivos `.exs` para cada nodo y ejecutarlos. Además, se mejora la recepción de mensajes para que el nodo receptor pueda seguir escuchando indefinidamente.

#### 1. Código para nodo1 (`nodo1.exs`)

Cree un archivo llamado `nodo1.exs` con el siguiente contenido:

```elixir
defmodule Cliente do
  def main do
    # Inicia el nodo en modo distribuido con un nombre corto
    {:ok, _} = Node.start(:nodo1@localhost, :shortnames)

    # Establece la cookie (debe coincidir con la del nodo2)
    Node.set_cookie(:mi_cookie)

    # Intentar conectarse al nodo2
    case Node.connect(:nodo2@localhost) do
      true ->
        IO.puts("Conectado a nodo2@localhost correctamente")
        # Enviar mensaje al proceso remoto
        send({:proceso_en_nodo2, :nodo2@localhost}, {:mensaje, "Hola desde nodo1"})
        IO.puts("Mensaje enviado a nodo2")

      false ->
        IO.puts("No se pudo conectar al nodo remoto")
    end
  end
end

Cliente.main()
``` 

Se organiza el código dentro de un módulo `Cliente` con una función `main` para mayor claridad. No es obligatorio, pero es una buena práctica.

#### 2. Código para nodo2 (`nodo2.exs`)

Cree un archivo llamado `nodo2.exs` con el siguiente contenido:

```elixir
defmodule Servidor do
  def main do
    # Inicia el nodo en modo distribuido con un nombre corto
    {:ok, _} = Node.start(:nodo2@localhost, :shortnames)

    # Establece la cookie para la autenticación entre nodos
    Node.set_cookie(:mi_cookie)

    # Registrar el proceso con un nombre en este nodo
    Process.register(self(), :proceso_en_nodo2)

    IO.puts("Nodo iniciado correctamente: #{Node.self()}")
    IO.puts("Esperando mensajes...")

    # Bloquea el proceso principal
    loop()

    # Nunca se llega aquí debido al loop infinito
    IO.puts("Nodo finalizado")
  end

  # Función recursiva para recibir mensajes indefinidamente
  defp loop do
    receive do
      {:mensaje, msg} ->
        IO.puts("Recibido en nodo 2: #{msg}")
        loop()
    end
  end
end

Servidor.main()
```

Se define un módulo `Servidor` con una función `main` que inicia el nodo y crea un proceso que escucha mensajes de forma indefinida utilizando una función recursiva `loop`.

#### 3. Ejecutar los nodos

**Primero**, asegúrese de que `epmd` esté corriendo:

```bash
epmd -names
```

Si no está activo, inícielo con:

```bash
epmd -daemon
```

**Luego**, en terminales independientes, ejecute:

```bash
# Terminal 1
elixir nodo2.exs
```

```bash
# Terminal 2
elixir nodo1.exs
```

#### 4. Verificar la comunicación

En la terminal donde se ejecuta `nodo2.exs`, debería ver el mensaje recibido:

```
Nodo iniciado correctamente: nodo2@localhost
Esperando mensajes...
Recibido en nodo 2: Hola desde nodo1
```

Y dicho nodo permanecerá activo, esperando más mensajes de manera indefinida.

#### 5. Mejoras opcionales

- Use constantes a nivel de módulo para definir el nombre del nodo y la cookie, evitando repetirlos en varias partes del código.
- Agregue manejo de errores para las conexiones fallidas.
- Implemente un mecanismo de shutdown graceful con mensajes especiales como `:shutdown`.

---

## Comunicación remota con `:rpc`

El módulo `:rpc` (Remote Procedure Call) permite ejecutar funciones de forma remota en otros nodos distribuidos. Esto es útil cuando se desea invocar una función en un nodo diferente sin necesidad de gestionar manualmente la comunicación entre procesos.

`:rpc` es parte de la biblioteca estándar de Erlang y proporciona una interfaz sencilla para realizar llamadas a funciones en nodos remotos, manejando automáticamente la serialización de argumentos y resultados, así como la gestión de errores.

### Funciones principales de `:rpc`

Las funciones más comunes del módulo `:rpc` son:

- `:rpc.call/4`: Llama a una función en un nodo remoto y espera el resultado.
- `:rpc.cast/4`: Envía una petición a un nodo remoto sin esperar respuesta (asíncrono).
- `:rpc.multicall/4`: Llama a una función en múltiples nodos y recopila las respuestas.
- `:rpc.ping/1`: Verifica si un nodo remoto está disponible.

**Sintaxis de `:rpc.call/4`:**
```elixir
:rpc.call(nodo, modulo, funcion, argumentos)
```

### Ejemplo básico

Supongamos dos nodos conectados: `:nodo1@localhost` y `:nodo2@localhost`. Uno de ellos (nodo2) tiene un módulo llamado `Operaciones` con una función `cuadrado/1` que calcula el cuadrado de un número. El otro nodo (nodo1) quiere llamar a esta función de forma remota.

#### Versión 1 (Creando los nodos en iex)

**En una terminal, inicie `nodo2` con iex:**

```bash
iex --sname nodo2 --cookie mi_cookie
```

Luego, defina el módulo `Operaciones`:

```elixir
defmodule Operaciones do
  def cuadrado(x), do: x * x
end
```

**En otra terminal, inicie `nodo1` con iex:**

```bash
iex --sname nodo1 --cookie mi_cookie
```

Luego, llame a la función `cuadrado/1` en `nodo2` usando `:rpc.call/4`:

```elixir
resultado = :rpc.call(:nodo2@localhost, Operaciones, :cuadrado, [12])
IO.puts("Resultado remoto: #{resultado}")
```

Observará que el resultado impreso es `144`, que es el cuadrado de `12`. Se ha ejecutado la función `cuadrado/1` en el nodo remoto `nodo2` y se ha recibido el resultado en `nodo1`.

#### Versión 2 (Creando scripts para cada nodo)

Se crean dos archivos `.exs`, uno para cada nodo con el siguiente contenido:

**Nodo 1 - cliente (`cliente_rpc.exs`):**

```elixir
defmodule ClienteRPC do
  def main do
    # Inicia el nodo en modo distribuido con un nombre corto
    {:ok, _} = Node.start(:nodo1@localhost, :shortnames)

    # Establece la cookie para la autenticación entre nodos
    Node.set_cookie(:mi_cookie)

    IO.puts("Nodo1 iniciado correctamente: #{Node.self()}")

    # Esperar un momento para asegurar que el servidor esté listo
    :timer.sleep(1000)

    # Llamar a la función 'cuadrado/1' del módulo 'Operaciones' en el nodo2
    resultado = :rpc.call(:nodo2@localhost, Operaciones, :cuadrado, [12])
    IO.puts("Resultado remoto: #{resultado}")
  end
end

ClienteRPC.main()
```

En este ejemplo, el nodo 1 llama a la función `cuadrado/1` del módulo `Operaciones` en el nodo 2, pasando el argumento `12`. El resultado se recibe y se imprime en la consola.

**Nodo 2 - servidor (`servidor_rpc.exs`):**

```elixir
defmodule Operaciones do
  @moduledoc """
  Módulo que contiene operaciones matemáticas para ser llamadas remotamente
  """

  def cuadrado(numero) do
    IO.puts("Calculando el cuadrado de #{numero}...")
    numero * numero
  end
end

defmodule ServidorRPC do
  def main do
    # Inicia el nodo en modo distribuido con un nombre corto
    {:ok, _} = Node.start(:nodo2@localhost, :shortnames)
    
    # Establece la misma cookie que el cliente para la autenticación
    Node.set_cookie(:mi_cookie)
    
    IO.puts("Nodo2 iniciado correctamente: #{Node.self()}")
    IO.puts("Esperando llamadas RPC...")
    IO.puts("Presiona Ctrl+C dos veces para salir")
    
    # Mantener el proceso vivo indefinidamente
    :timer.sleep(:infinity)
  end
end

ServidorRPC.main()
```

El nodo 2 define el módulo `Operaciones` con la función `cuadrado/1`, que simplemente devuelve el cuadrado del número recibido.

**Ejecutar los nodos:**

```bash
# Terminal 1
elixir servidor_rpc.exs

# Terminal 2
elixir cliente_rpc.exs
```

En este caso, el nodo 1 puede ejecutar la función en el nodo 2 sin necesidad de gestionar manualmente los procesos o mensajes. El módulo `:rpc` se encarga de la comunicación y la ejecución remota, simplificando el desarrollo de aplicaciones distribuidas en Elixir.

---

## Registro global de procesos con `:global`

El módulo `:global` permite **registrar procesos con un nombre único en todo un clúster de nodos**, no solo dentro de un nodo individual. Mientras que `Process.register/2` asigna un nombre local visible únicamente dentro del nodo donde se ejecuta el proceso, `:global` mantiene una **tabla de nombres distribuida** y sincronizada entre todos los nodos conectados.

### ¿Cómo funciona la tabla de nombres global?

Erlang/Elixir incluyen un **sistema de nombres global integrado** cuya función es coordinar y sincronizar la información sobre procesos registrados en un entorno distribuido. Cuando un proceso se registra usando `:global.register_name/2`:

* El nombre se añade a la **tabla de nombres global**, una estructura lógica compartida entre nodos.
* Los nodos del clúster **intercambian mensajes de sincronización** para asegurar que todos mantengan la misma información.
* Si un nodo se conecta a otros posteriormente, la tabla se **reconcilia automáticamente**, añadiendo o eliminando nombres según corresponda.
* Si un nodo se desconecta, los demás ajustan la tabla para mantener una vista **consistente y coherente** de los procesos disponibles.

La tabla de nombres global garantiza que **cualquier proceso registrado mediante `:global` pueda ser buscado y referenciado por nombre desde cualquier nodo**, sin necesidad de conocer en cuál está ejecutándose.

Este mecanismo simplifica la comunicación en sistemas distribuidos porque permite escribir código como si todos los procesos estuvieran en un único nodo, dejando al sistema operativo distribuido de Erlang la responsabilidad de mantener la coherencia.

### Funciones principales de `:global`

Las funciones más comunes del módulo `:global` son:

- `:global.register_name/2`: Registra un proceso con un nombre global. Devuelve `:yes` si tiene éxito, `:no` si el nombre ya está registrado.
- `:global.whereis_name/1`: Busca el PID asociado al nombre global. Devuelve el PID o `:undefined` si no existe.
- `:global.unregister_name/1`: Elimina el registro de un nombre global.
- `:global.registered_names/0`: Devuelve la lista de todos los nombres registrados globalmente.

### Ejemplo básico

A continuación, se muestra un ejemplo simple de cómo usar `:global` para registrar y buscar un proceso en nodos diferentes.

**Nodo servidor (`servidor_global.exs`):**

```elixir
defmodule ServidorGlobal do
  def main do
    {:ok, _} = Node.start(:servidor@localhost, :shortnames)
    Node.set_cookie(:mi_cookie)

    # Registrar el proceso principal con un nombre global
    case :global.register_name(:servidor_global, self()) do
      :yes ->
        IO.puts("Servidor global registrado exitosamente")
        IO.puts("PID: #{inspect(self())}")
        IO.puts("Esperando mensajes...")
        loop()
      
      :no ->
        IO.puts("Error: El nombre :servidor_global ya está registrado")
    end
  end

  defp loop do
    receive do
      {:saludo, msg, from} ->
        IO.puts("Mensaje recibido: #{msg}")
        send(from, {:respuesta, "Hola, #{msg}, desde el servidor global!"})
        loop()
      
      :shutdown ->
        IO.puts("Cerrando servidor...")
        :global.unregister_name(:servidor_global)
    end
  end
end

ServidorGlobal.main()
```

Si se ejecuta este código en un nodo, el proceso principal se registra globalmente con el nombre `:servidor_global`. Si este nombre ya está registrado en otro nodo, la llamada a `:global.register_name/2` devolverá `:no`.

**Nodo cliente (`cliente_global.exs`):**

```elixir
defmodule ClienteGlobal do
  def main do
    {:ok, _} = Node.start(:cliente@localhost, :shortnames)
    Node.set_cookie(:mi_cookie)

    IO.puts("Cliente iniciado")
    IO.puts("Buscando servidor global...")

    # Esperar un momento para que los nodos se sincronicen
    :timer.sleep(1000)

    case :global.whereis_name(:servidor_global) do
      :undefined ->
        IO.puts("Servidor global no encontrado")

      pid ->
        IO.puts("Servidor encontrado: #{inspect(pid)}")
        send(pid, {:saludo, "cliente", self()})

        receive do
          {:respuesta, msg} -> IO.puts("Respuesta: #{msg}")
        after
          5000 -> IO.puts("Timeout: no se recibió respuesta")
        end
    end
  end
end

ClienteGlobal.main()
```

**Ejecutar:**

```bash
# Terminal 1
elixir servidor_global.exs

# Terminal 2
elixir cliente_global.exs
```

Con `:global`, no es necesario conocer el nodo donde se encuentra el proceso registrado. El cliente puede buscar el proceso por su nombre global y enviarle mensajes directamente.

---

## Comparativa entre métodos de comunicación

Ya sea que se utilice `send/2` con `receive`, `:global` o `:rpc`, cada método tiene sus propias características y casos de uso ideales. A continuación, se presenta una tabla comparativa para ayudar a entender las diferencias clave entre estos métodos de comunicación en aplicaciones distribuidas:

| Característica               | `send/2` + `receive`                | `:global`                           | `:rpc`                              |
|------------------------------|-------------------------------------|------------------------------------|------------------------------------|
| **Nivel de abstracción**     | Bajo                                | Medio                              | Alto                               |
| **Facilidad de uso**         | Requiere manejo manual de mensajes  | Más sencillo que `send/2`          | Muy sencillo, similar a llamadas locales |
| **Registro de procesos**     | Local (por nodo)                    | Global (en todo el clúster)        | No aplica                          |
| **Comunicación entre nodos** | Directa mediante PIDs               | A través de nombres globales       | Llamadas a funciones remotas       |
| **Manejo de errores**        | Manual                              | Automático en la tabla global      | Automático, con manejo de errores integrado |
| **Rendimiento**              | Alto, pero con mayor complejidad    | Moderado, debido a la sincronización | Puede ser más lento debido a la serialización |
| **Casos de uso ideales**     | Chat, eventos en tiempo real, control fino sobre mensajes | Descubrimiento de servicios, failover, coordinación de procesos | Cálculos remotos, microservicios, operaciones síncronas |

**Recomendaciones:**

- Use `send/2` + `receive` cuando necesite control total sobre la comunicación y el formato de los mensajes.
- Use `:global` cuando necesite un registro distribuido de procesos que puedan ser descubiertos por cualquier nodo.
- Use `:rpc` cuando quiera ejecutar funciones remotas de manera simple, sin preocuparse por la gestión de mensajes.

---

## Troubleshooting común

A continuación, se presentan los problemas más comunes al trabajar con aplicaciones distribuidas en Elixir y cómo resolverlos:

### 1. Cookies que no coinciden

**Síntoma:** Los nodos no pueden conectarse entre sí, aunque están en la misma red.

**Causa:** Las cookies de autenticación no coinciden entre los nodos.

**Solución:**
```elixir
# Verificar la cookie actual
Node.get_cookie()

# Establecer la misma cookie en todos los nodos
Node.set_cookie(:mi_cookie_secreta)
```

**Al usar iex:**
```bash
iex --sname nodo1 --cookie mi_cookie
```

### 2. Nombres de nodos duplicados

**Síntoma:** Error al iniciar un nodo: `{:error, {:already_started, :...}}`

**Causa:** Ya existe un nodo con el mismo nombre en la máquina.

**Solución:**
- Cierre el nodo existente antes de iniciar uno nuevo con el mismo nombre.
- Use nombres únicos para cada nodo.
- Verifique los nodos activos con: `epmd -names`

### 3. EPMD no está corriendo

**Síntoma:** Error: `Protocol 'inet_tcp': register/listen error: econnrefused`

**Causa:** El demonio EPMD no está activo.

**Solución:**
```bash
# Verificar si está corriendo
epmd -names

# Iniciarlo manualmente
epmd -daemon

# Verificar que esté activo
epmd -names
```

### 4. Problemas de firewall

**Síntoma:** Los nodos no pueden conectarse entre máquinas diferentes, pero sí funcionan en localhost.

**Causa:** El firewall está bloqueando los puertos necesarios.

**Solución:**
- Abra el puerto **4369** (EPMD) en el firewall.
- Abra un rango de puertos dinámicos para la comunicación entre nodos (por ejemplo, 9000-9100).
- En Linux (usando `ufw`):
  ```bash
  sudo ufw allow 4369/tcp
  sudo ufw allow 9000:9100/tcp
  ```

### 5. No se puede resolver el nombre del host

**Síntoma:** `Node.connect/1` devuelve `false` o error de resolución de nombres.

**Causa:** El sistema no puede resolver el nombre del host al que intenta conectarse.

**Solución:**
- Use direcciones IP en lugar de nombres de host:
  ```elixir
  Node.connect(:"nodo@192.168.1.100")
  ```
- O agregue el nombre del host a `/etc/hosts` (Linux/Mac) o `C:\Windows\System32\drivers\etc\hosts` (Windows):
  ```
  192.168.1.100  servidor
  ```

### 6. Mezcla de shortnames y longnames

**Síntoma:** Los nodos no pueden conectarse aunque todo parece estar bien configurado.

**Causa:** Un nodo usa shortnames y otro usa longnames.

**Solución:**
- Todos los nodos deben usar el mismo tipo de nombre.
- Para nodos en la misma máquina: use `--sname` (shortnames).
- Para nodos en diferentes máquinas: use `--name` (longnames).

### 7. Proceso no registrado

**Síntoma:** Error al enviar mensajes: el proceso receptor no existe.

**Causa:** El proceso no se registró correctamente o ya finalizó.

**Solución:**
```elixir
# Verificar si el proceso está registrado localmente
Process.whereis(:nombre_proceso)

# Verificar si está registrado globalmente
:global.whereis_name(:nombre_global)

# Verificar procesos registrados en un nodo remoto
:rpc.call(:nodo@host, Process, :registered, [])
```

### 8. Timeout en comunicación remota

**Síntoma:** El cliente no recibe respuesta del servidor.

**Causa:** El servidor está ocupado, no está escuchando, o la red es lenta.

**Solución:**
- Aumente el timeout en el bloque `receive`:
  ```elixir
  receive do
    {:respuesta, msg} -> IO.puts(msg)
  after
    10_000 -> IO.puts("Timeout: no se recibió respuesta")
  end
  ```
- Verifique que el servidor esté activo y escuchando mensajes.

### 9. Verificación rápida de conectividad

**Comandos útiles para diagnosticar problemas:**

```elixir
# Ver el nombre del nodo actual
Node.self()

# Ver nodos conectados
Node.list()

# Ver todos los nodos (incluyendo el actual)
[Node.self() | Node.list()]

# Ping a un nodo remoto
Node.ping(:nodo@host)
# Devuelve :pong si está conectado, :pang si no

# Ver procesos registrados localmente
Process.registered()

# Ver procesos registrados globalmente
:global.registered_names()
```

---

## Ejercicio 1

Cree una aplicación distribuida en Elixir que permita a un nodo cliente enviar una lista de números a un nodo servidor. El nodo servidor debe recibir la lista y realizar las siguientes operaciones:
- Calcular la suma de los números en la lista.
- Calcular el promedio de los números en la lista.
- Filtrar los números pares de la lista.
- Simular una tarea costosa que tome 50 segundos en completarse (por ejemplo, usando `:timer.sleep/1`).

En el cliente, los números se le piden al usuario a través de la consola. El cliente envía la lista al servidor y espera la respuesta para cada operación. Para la tarea costosa, el cliente debe usar un timeout para no esperar indefinidamente.

### 1. Crear el servidor

Cree un archivo llamado `servidor.exs` con el siguiente contenido:

```elixir
defmodule Servidor do
  # Inicia el nodo servidor y espera peticiones
  def main do
    Node.start(:servidor@localhost, :shortnames)
    Node.set_cookie(:cookie)
    Process.register(self(), :principal) # Registrar el proceso principal con un nombre

    IO.puts("Servidor iniciado en #{node()}")
    IO.puts("Esperando conexiones...\n")

    loop() # Iniciar el bucle de recepción de mensajes
  end

  def loop do
    # Se reciben los diferentes tipos de mensajes posibles y se responde adecuadamente
    # Los mensajes deben coincidir con los enviados por el cliente
    receive do
      {:sumar_numeros, pid, lista} ->
        IO.puts("[#{timestamp()}] Petición: sumar_numeros")
        resultado = sumar_numeros(lista)
        send(pid, {:resultado_suma, resultado})

      {:calcular_promedio, pid, lista} ->
        IO.puts("[#{timestamp()}] Petición: calcular_promedio")
        resultado = calcular_promedio(lista)
        send(pid, {:resultado_promedio, resultado})

      {:filtrar_pares, pid, lista} ->
        IO.puts("[#{timestamp()}] Petición: filtrar_pares")
        resultado = filtrar_pares(lista)
        send(pid, {:lista_filtrada, resultado})

      {:tarea_costosa, pid} ->
        IO.puts("[#{timestamp()}] Petición: tarea_costosa (50s)")

        # Se crea un proceso separado para no bloquear el proceso principal del servidor
        spawn(fn ->
            hacer_tarea_costosa()
            send(pid, :tarea_completada)
            IO.puts("[#{timestamp()}] Tarea costosa completada")
        end)

      mensaje ->
        IO.puts("[#{timestamp()}] Mensaje desconocido: #{inspect(mensaje)}")
    end

    loop()
  end

  # Funciones auxiliares para las operaciones solicitadas

  defp filtrar_pares(lista), do: Enum.filter(lista, fn el -> rem(el, 2) == 0 end)
  defp sumar_numeros(lista), do: Enum.sum(lista)
  defp calcular_promedio([]), do: :error
  defp calcular_promedio(lista), do: Enum.sum(lista) / length(lista)
  defp hacer_tarea_costosa(), do: :timer.sleep(50000)

  # Obtener la hora actual en formato legible
  defp timestamp do
    Time.utc_now() |> Time.to_string() |> String.slice(0..7)
  end
end

Servidor.main()
```

Revise detalladamente el código para entender cómo se manejan las peticiones y respuestas entre el cliente y el servidor. Recuerde que el bloque `receive` bloquea el proceso hasta que llega un mensaje, por lo que es importante manejar cada tipo de mensaje adecuadamente, y en el caso de la tarea costosa, crear un proceso separado para no bloquear el servidor.

### 2. Crear el cliente

Cree un archivo llamado `cliente.exs` con el siguiente contenido:

```elixir
defmodule Cliente do
  # Se definen constantes para el nombre del servidor, proceso y timeout
  @nombre_servidor :servidor@localhost
  @nombre_proceso :principal
  @timeout 10000

  # Función principal del cliente 
  def main do
    Node.start(crear_nombre_nodo() |> String.to_atom(), :shortnames)
    Node.set_cookie(:cookie)

    IO.puts("Cliente iniciado en #{node()}")
    IO.puts("Intentando conectar al servidor...")

    # Intentar conectar al servidor
    conectar_servidor(Node.connect(@nombre_servidor))

    IO.puts("Conexión finalizada")
  end

  # Crear un nombre único para el nodo del cliente (ya que puede haber múltiples clientes)
  def crear_nombre_nodo do
    uuid = :crypto.strong_rand_bytes(8) |> Base.encode16(case: :lower)
    "cliente_#{uuid}@localhost"
  end

  # Si la conexión es exitosa, pedir números y enviar petición
  def conectar_servidor(true) do
    IO.puts("Conexión exitosa")
    pedir_numeros() |> enviar_peticion()
    esperar_respuesta()
  end

  # Si la conexión falla, mostrar mensaje de error
  def conectar_servidor(false), do: IO.puts("No se pudo conectar al servidor")

  # Mostrar menú y pedir números al usuario
  def pedir_numeros do
    IO.puts("\nBienvenido cliente")
    IO.puts("Opciones disponibles:")
    IO.puts("1 - Sumar los números")
    IO.puts("2 - Calcular el promedio")
    IO.puts("3 - Filtrar números pares")
    IO.puts("4 - Ejecutar tarea costosa\n")

    opcion = IO.gets("Seleccione una opción (1-4): ") |> String.trim()
    {opcion, crear_lista([])}
  end

  # Manejo de las diferentes peticiones según la opción seleccionada por el usuario

  def enviar_peticion({"1", lista}) do
    # Dado que el servidor está en otro nodo, se usa una tupla con el nombre del proceso y el nodo
    send({@nombre_proceso, @nombre_servidor}, {:sumar_numeros, self(), lista})
  end

  def enviar_peticion({"2", lista}) do
    send({@nombre_proceso, @nombre_servidor}, {:calcular_promedio, self(), lista})
  end

  def enviar_peticion({"3", lista}) do
    send({@nombre_proceso, @nombre_servidor}, {:filtrar_pares, self(), lista})
  end

  def enviar_peticion({"4", _lista}) do
    send({@nombre_proceso, @nombre_servidor}, {:tarea_costosa, self()})
  end

  def enviar_peticion({opcion, _lista}) do
    IO.puts("Opción inválida: #{opcion}")
  end

  # Bloque que espera la respuesta del servidor según la petición realizada
  def esperar_respuesta do
    receive do
      {:resultado_suma, suma} ->
        IO.puts("\nResultado recibido:")
        IO.puts("  Suma: #{suma}")

      {:resultado_promedio, :error} ->
        IO.puts("\nError: No se puede procesar una lista vacía")

      {:resultado_promedio, promedio} ->
        IO.puts("\nResultado recibido:")
        IO.puts("  Promedio: #{promedio}")

      {:lista_filtrada, lista} ->
        IO.puts("\nNúmeros pares filtrados:")
        IO.inspect(lista)

      :tarea_completada ->
        IO.puts("\nLa tarea costosa terminó exitosamente")

    # Manejo de timeout en caso de que el servidor no responda a tiempo
    after 
      @timeout ->
        IO.puts("\nTimeout: El servidor no respondió en #{@timeout}ms")
    end
  end

  # Función recursiva para crear la lista de números ingresados por el usuario
  def crear_lista(lista) do
    valor = IO.gets("Ingrese un número (o 'fin' para terminar): ") |> String.trim()

    case valor do
      "fin" ->
        Enum.reverse(lista)
      _ ->
        case Integer.parse(valor) do
          {num, _} ->
            crear_lista([num | lista])
          :error ->
            IO.puts("Error: Solo se aceptan números enteros")
            crear_lista(lista)
        end
    end
  end
end

Cliente.main()
```

Lea detenidamente el código para entender cómo se manejan las peticiones y respuestas entre el cliente y el servidor. Note que el cliente crea un nombre único para su nodo, ya que puede haber múltiples clientes conectándose al mismo servidor.

### 3. Ejecutar y probar la aplicación

Primero, asegúrese de que `epmd` esté corriendo:

```bash
epmd -names
```

Si no está activo, inícielo con:

```bash
epmd -daemon
```

Luego, en una terminal, ejecute el servidor:

```bash
elixir servidor.exs
```

En otras dos terminales independientes, ejecute dos clientes diferentes:

```bash
elixir cliente.exs
```

Siga las instrucciones en la consola del cliente para ingresar números y seleccionar las operaciones a realizar. Verifique que el servidor procese las solicitudes correctamente y que el cliente reciba las respuestas esperadas.

Envíe diferentes tipos de mensajes desde cada cliente y observe cómo el servidor maneja las peticiones concurrentemente.

### 4. Ejecución en máquinas diferentes

Para ejecutar los nodos en máquinas diferentes, primero necesita conocer las direcciones IP de cada máquina:

**En Linux/macOS:**
```bash
ifconfig
# Busque su dirección IP en la sección de su interfaz de red activa
```

**En Windows:**
```bash
ipconfig
# Busque "Dirección IPv4" en la sección de su adaptador de red activo
```

**Modificar los archivos:**

Supongamos que:
- La IP del servidor es `192.168.1.20`
- La IP del cliente es `192.168.1.21`

**En `servidor.exs`**, cambie:
```elixir
# De:
Node.start(:servidor@localhost, :shortnames)

# A:
Node.start(:"servidor@192.168.1.20", :longnames)
```

**En `cliente.exs`**, cambie:
```elixir
# Constante del servidor
@nombre_servidor :"servidor@192.168.1.20"

# Y en crear_nombre_nodo():
def crear_nombre_nodo do
  uuid = :crypto.strong_rand_bytes(8) |> Base.encode16(case: :lower)
  "cliente_#{uuid}@192.168.1.21"  # Use la IP del cliente
end

# Y al iniciar el nodo:
Node.start(crear_nombre_nodo() |> String.to_atom(), :longnames)
```

**Importante:** Asegúrese de que:
- Ambas máquinas estén en la misma red.
- El firewall permita las conexiones en el puerto 4369 (EPMD) y los puertos dinámicos.
- Las cookies coincidan en ambos nodos.

Esta es una forma práctica de entender cómo funcionan las aplicaciones distribuidas en Elixir.

---

## Ejercicio 2

Se desea desarrollar una aplicación distribuida en Elixir que permita la comunicación entre múltiples nodos clientes y un **nodo servidor central**. Los clientes podrán conectarse simultáneamente al servidor y enviarle mensajes con el siguiente formato:

* `{:mayusculas, msg}`: Convierte el mensaje a mayúsculas y lo devuelve.
* `{:minusculas, msg}`: Convierte el mensaje a minúsculas y lo devuelve.
* `{:palindroma, msg}`: Verifica si el mensaje es un palíndromo y devuelve `true` o `false`.
* `{:contar_vocales, msg}`: Cuenta el número de vocales en el mensaje y lo devuelve.
* `{:guardar, msg}`: Guarda el mensaje en una lista en memoria en el servidor.
* `{:consultar}`: Devuelve la lista de mensajes guardados en memoria.

El nodo servidor debe procesar múltiples solicitudes de forma concurrente y responder a cada cliente de manera independiente. Los nodos clientes, por su parte, deben poder enviar mensajes y recibir respuestas de forma asíncrona.

Además, hay un mensaje especial que finaliza la comunicación: `:fin`. Cuando el nodo servidor recibe este mensaje, le responde al nodo cliente con `:adios` y continúa esperando conexiones de otros clientes.

**Requisitos:**

1. El servidor debe manejar múltiples clientes concurrentemente.
2. Cada operación debe ser realizada por un proceso separado para no bloquear el servidor principal.
3. Los clientes deben mostrar un menú interactivo para seleccionar operaciones.
4. Implemente manejo de errores y timeouts apropiados.

**Pruebe la aplicación creando al menos dos nodos clientes** (si puede en máquinas diferentes) que envíen diferentes tipos de mensajes al nodo servidor y muestren las respuestas recibidas.

**Pistas:**

- Use `spawn` para crear procesos que manejen cada petición.
- Mantenga el estado (lista de mensajes guardados) en el proceso principal del servidor.
- Para la operación de palíndromo, normalice el string (sin espacios, en minúsculas).
- Para contar vocales, puede usar: `String.graphemes/1` y `Enum.count/2`.

---

## Más allá: OTP

Hasta el momento hemos trabajado con procesos "a mano" usando `spawn`, `send`, `receive` y `Task`. Sin embargo, en aplicaciones reales esto puede volverse complejo y propenso a errores.

En aplicaciones reales, Elixir recomienda usar **OTP** (Open Telecom Platform), que provee:

- **GenServer**: procesos con estado encapsulado y callbacks estandarizados.
- **Supervisores**: reinician procesos automáticamente si fallan.
- **Árboles de supervisión**: estructuras jerárquicas de procesos tolerantes a fallos.

Los ejemplos vistos muestran comunicación distribuida "manual" con primitivas básicas. En producción, estos patrones se encapsulan usando GenServer (para mantener estado), Tasks supervisadas (para trabajo asíncrono), y Registry/`:global` para descubrimiento de servicios. OTP no reemplaza estos conceptos fundamentales de comunicación entre nodos, sino que los estructura de forma más robusta, mantenible y tolerante a fallos.

Esto es lo que permite a aplicaciones hechas en Elixir ser **altamente concurrentes y resilientes**. En futuras clases profundizaremos en OTP y sus componentes.

---

## Para la próxima clase

- Leer sobre OTP y GenServer en la documentación oficial de Elixir: [https://hexdocs.pm/elixir/GenServer.html](https://hexdocs.pm/elixir/GenServer.html)
- Investigar qué es un Agente en Elixir y cómo se utiliza: [https://hexdocs.pm/elixir/Agent.html](https://hexdocs.pm/elixir/Agent.html)
- Qué es un Supervisor y cómo ayuda a manejar fallos en procesos: [https://hexdocs.pm/elixir/Supervisor.html](https://hexdocs.pm/elixir/Supervisor.html)