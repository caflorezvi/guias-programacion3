```
Universidad del Quindío
Programa de Ingeniería de Sistemas y Computación
Programación III - Expresiones lógico-matemáticas y estructuras de control
Docente: Carlos Andrés Florez V.
```

# Expresiones lógico-matemáticas y estructuras de control

Para comprender las expresiones lógico-matemáticas en Elixir, es importante familiarizarse con su sintaxis y características principales. A continuación, se presentan algunos de los conceptos fundamentales que se abordarán en esta guía:

- Operadores lógicos y matemáticos.
- Funciones lambda.
- Evaluación de expresiones.
- Patrones de coincidencia (pattern matching).
- Ejemplos prácticos.

## Tipos de datos y operadores

En elixir, existen diferentes tipos de datos, como: `integer`, `float`, `boolean`, `atom`, `string`, `list`, `tuple`, entre otros. Para trabajar con estos tipos de datos, es importante conocer las funciones y operadores que se pueden utilizar.

Los operadores lógicos, matemáticos y de comparación son fundamentales para realizar operaciones en Elixir. A continuación se listan los operadores según su categoría:

- Operadores lógicos: `and`, `or`, `not`, `&&`, `||`, `!`
- Operadores matemáticos: `+`, `-`, `*`, `/`
- Operadores de comparación: `==`, `!=`, `>`, `<`, `>=`, `<=`, `===`, `!==`

También existen funciones matemáticas como:

- `div/2`, calcula la división entera.
- `rem/2`, calcula el residuo de una división.
- `abs/1`, devuelve el valor absoluto de un número.
- `round/1`, redondea un número al entero más cercano.

Para más información sobre tipos de datos, operadores y funciones básicas, puede acceder a [https://hexdocs.pm/elixir/basic-types.html](https://hexdocs.pm/elixir/basic-types.html).

## Átomos y tuplas

Los tipos de datos `atom` y `tuple` son estructuras de datos importantes en Elixir. Un `atom` es un valor constante que se utiliza comúnmente como identificador o etiqueta. Por ejemplo, `:ok`, `:error` y `:user` son átomos. Por otro lado, una `tuple` es una colección ordenada de elementos que puede contener diferentes tipos de datos. Las tuplas se definen utilizando llaves `{}` y son útiles para agrupar valores relacionados.

Para más información sobre átomos y tuplas, puede consultar [documentación de átomos](https://hexdocs.pm/elixir/1.12/Atom.html) y [documentación de tuplas](https://hexdocs.pm/elixir/1.12.3/Tuple.html).

---

## Ejercicio 1

La oficina de tesorería de una empresa requiere un programa que calcule el salario de un empleado, considerando las horas trabajadas y el valor establecido por hora. El programa debe solicitar el nombre del empleado, la cantidad de horas laboradas y el valor por hora, para luego obtener el salario correspondiente e imprimirlo.

### Versión 1

```elixir
defmodule Salario do

  def main do
    nombre = leer_nombre()
    horas_trabajadas = leer_horas_trabajadas()
    valor_por_hora = leer_valor_por_hora()

    salario = calcular_salario(horas_trabajadas, valor_por_hora)
    imprimir_mensaje(nombre, salario)
  end

  defp leer_nombre do
    IO.gets("Ingrese el nombre del empleado: ") 
    |> String.trim()
  end

  defp leer_horas_trabajadas do
    IO.gets("Ingrese las horas trabajadas: ") 
    |> String.trim() 
    |> String.to_integer()
  end

  defp leer_valor_por_hora do
    IO.gets("Ingrese el valor por hora: ") 
    |> String.trim() 
    |> String.to_float()
  end

  defp calcular_salario(horas_trabajadas, valor_por_hora), do: horas_trabajadas * valor_por_hora

  defp imprimir_mensaje(nombre, salario) do
    IO.puts("El salario de #{nombre} es: $#{salario}")
  end
end

Salario.main()
```

Así como vimos en la clase anterior, el módulo `String` de elixir tiene una serie de funciones útiles para manipular cadenas de texto. Para este ejercicio, es necesario conocer las siguientes funciones:

- `String.to_integer/1`: Convierte una cadena en un número entero.
- `String.to_float/1`: Convierte una cadena en un número de punto flotante.

> **⚠️ Importante:** Las funciones `String.to_integer/1` y `String.to_float/1` pueden lanzar excepciones si la cadena no representa un número válido. Para manejar estos casos, se recomienda utilizar estas funciones dentro de un bloque `try`/`rescue`. 

### Versión 2

Usando `try`/`rescue` la función `leer_horas_trabajadas/0` quedaría de la siguiente manera:

```elixir
defp leer_horas_trabajadas do
  entrada = IO.gets("Ingrese las horas trabajadas: ") 
  |> String.trim()

  try do # Intenta convertir la entrada a un número entero
    String.to_integer(entrada)
  rescue # Si ocurre un ArgumentError, se imprime un mensaje de error y se devuelve 0
    ArgumentError ->
      IO.puts("Horas trabajadas inválidas. Se utilizará 0 como valor predeterminado.")
      0
  end
end
```

Se asume que algo similar a lo que se hizo con `leer_horas_trabajadas/0` se hará con `leer_valor_por_hora/0`. 

Aunque esta implementación es mejor, en elixir **se prefiere utilizar un enfoque más funcional y menos imperativo**. En lugar de usar `try`/`rescue`, se pueden utilizar las funciones `Integer.parse/1` y `Float.parse/1` para manejar la entrada del usuario de manera más robusta.

### Versión 3

Para esta implementación se opta por usar `Integer.parse/1` y `Float.parse/1` ya que estas funciones retornan valores explícitos, lo que permite un manejo de errores más controlado. Esto es **mucho más seguro** que usar `String.to_integer/1` y `String.to_float/1`, ya que estas últimas pueden lanzar excepciones si la entrada no es válida y "explotar" el programa.

```elixir

defp leer_horas_trabajadas do
  horas = IO.gets("Ingrese las horas trabajadas: ") 
  |> String.trim() 
  |> Integer.parse() # Devuelve una tupla o :error

  case horas do # Patrón de coincidencia
    {numero, _} -> numero # Si horas es una tupla, se obtiene el número y se ignora el resto
    :error ->  # Si horas es un átomo :error, se imprime un mensaje de error y se devuelve 0
      imprimir_error("Horas trabajadas inválidas. Se utilizará 0 como valor predeterminado.")
      0 # Se devuelve 0 como valor predeterminado
  end
end

defp leer_valor_por_hora do
  valor = IO.gets("Ingrese el valor por hora: ") 
  |> String.trim() 
  |> Float.parse()

  case valor do
    {numero, _} -> numero
    :error -> 
      imprimir_error("Valor por hora inválido. Se utilizará 0 como valor predeterminado.")
      0.0 # Se devuelve 0.0 como valor predeterminado porque es un número decimal
  end
end

defp imprimir_error(mensaje) do
  IO.puts(:standard_error, mensaje) # Imprime el mensaje de error en la salida estándar de errores (por defecto es la terminal)
end
```

Las funciones `Integer.parse/1` y `Float.parse/1` retornan una tupla con dos elementos: el valor numérico convertido y la parte restante de la cadena:

```
{numero, resto}
```

Si la cadena no comienza con un número válido, la función devuelve el átomo `:error`.

**Ejemplos:**

```elixir
Integer.parse("123abc")
# => {123, "abc"}

Integer.parse("42")
# => {42, ""}

Integer.parse("abc")
# => :error

Float.parse("3.14xyz")
# => {3.14, "xyz"}
```

Para manejar estos posibles resultados se utiliza una estructura `case`, que permite evaluar distintos patrones y ejecutar acciones según la forma del valor recibido. Esto aprovecha el **pattern matching** (coincidencia de patrones), una característica fundamental de Elixir que permite verificar la estructura de un dato y extraer información de él simultáneamente.

En este ejemplo se consideran dos patrones:

* `{numero, _}`: coincide con una tupla donde el primer elemento es el número convertido y el segundo elemento se ignora mediante `_`. Si coincide, se retorna `numero`.
* `:error`: coincide con el caso en que la conversión falla; se muestra un mensaje y se devuelve un valor predeterminado (0 o 0.0).

Gracias al pattern matching, cada caso se define explícitamente, haciendo el código más declarativo y fácil de entender.

Para más información puede leer acerca del [Módulo String](https://hexdocs.pm/elixir/String.html), [Módulo Integer](https://hexdocs.pm/elixir/Integer.html) y [Módulo Float](https://hexdocs.pm/elixir/Float.html). Adicionalmente, se recomienda revisar [esta documentación](https://hexdocs.pm/elixir/case-cond-and-if.html#case) para profundizar en el uso de la estructura `case` y [esta documentación](https://hexdocs.pm/elixir/pattern-matching.html) para entender el **pattern matching**.

### Versión 4

Para mejorar la organización del código, se puede **crear un módulo separado** para manejar las operaciones de entrada/salida. Esto permite que el módulo `Salario` se enfoque en la lógica de negocio y delegue las operaciones de entrada/salida a otro módulo.

```elixir
defmodule Salario do
  @moduledoc """
  Módulo que contiene la lógica para calcular el salario de un empleado.
  """

  def main do
    nombre = "Ingrese el nombre del empleado: "
    |> Util.leer(:string)

    horas_trabajadas = "Ingrese las horas trabajadas: "
    |> Util.leer(:integer)

    valor_por_hora = "Ingrese el valor por hora: "
    |> Util.leer(:float)

    salario = calcular_salario(horas_trabajadas, valor_por_hora)

    generar_mensaje(nombre, salario)
    |> Util.imprimir_mensaje
  end

  defp calcular_salario(horas_trabajadas, valor_por_hora), do: horas_trabajadas * valor_por_hora

  defp generar_mensaje(nombre, salario) do
    "El salario de #{nombre} es: $#{salario}"
  end

end

defmodule Util do
  @moduledoc """
  Módulo de utilidades para manejo de entrada/salida. Este módulo puede ser reutilizado 
  en otros programas para leer diferentes tipos de datos y manejar errores de entrada de manera consistente.
  """

  def leer(mensaje, :string) do
    IO.gets(mensaje)
    |> String.trim()
  end

  def leer(mensaje, :integer) do
    horas = IO.gets(mensaje)
    |> String.trim()
    |> Integer.parse()

    case horas do
      {numero, _} -> numero
      :error ->
        imprimir_error("Error. Se utilizará 0 como valor predeterminado.")
        0
    end
  end

  def leer(mensaje, :float) do
    valor = IO.gets(mensaje)
    |> String.trim()
    |> Float.parse()

    case valor do
      {numero, _} -> numero
      :error ->
        imprimir_error("Error. Se utilizará 0 como valor predeterminado.")
        0
    end
  end

  def imprimir_error(mensaje) do
    IO.puts(:standard_error, mensaje)
  end

  def imprimir_mensaje(mensaje) do
    IO.puts(mensaje)
  end

end

Salario.main()
```

Ahora las funciones del módulo `Util` gestionan la entrada y salida de datos y pueden reutilizarse fácilmente desde otros módulos. Además, se emplea un **átomo** para indicar el tipo de dato a leer (`:string`, `:integer` o `:float`), y Elixir invoca automáticamente la función de parseo correspondiente gracias al **pattern matching**.

### Versión 5

Finalmente, se modificará el módulo `Util` para que las funciones de lectura de enteros y flotantes utilicen una función auxiliar encargada de capturar el valor, realizar su *parseo* y manejar posibles errores. Con este cambio se **reduce la duplicación de código**, ya que las funciones `leer(mensaje, :integer)` y `leer(mensaje, :float)` tenían implementaciones prácticamente idénticas.

```elixir
defmodule Util do

  def leer(mensaje, :string) do
    IO.gets(mensaje)
    |> String.trim()
  end

  def leer(mensaje, :integer) do
    leer_con_parser(mensaje, &Integer.parse/1) # Se pasa la función de parseo como argumento
  end

  def leer(mensaje, :float) do
    leer_con_parser(mensaje, &Float.parse/1) # Se pasa la función de parseo como argumento
  end

  defp leer_con_parser(mensaje, funcion) do
    valor = IO.gets(mensaje)
    |> String.trim()
    |> funcion.() # Se ejecuta la función de parseo

    case valor do
      {numero, _} -> numero
      :error ->
        imprimir_error("Error. Se utilizará 0 como valor predeterminado.")
        0
    end
  end

  def imprimir_error(mensaje) do
    IO.puts(:standard_error, mensaje)
  end

  def imprimir_mensaje(mensaje) do
    IO.puts(mensaje)
  end

end
```

La función `leer_con_parser/2` recibe el mensaje y la función de parseo. Para el caso de `leer(mensaje, :integer)` la función de parseo es `Integer.parse/1`. Para ejecutarla se utiliza el operador `.` así: `funcion.(valor)`. Otra alternativa es pasar la función así:

```elixir
def leer(mensaje, :integer) do
  leer_con_parser(mensaje, fn valor -> Integer.parse(valor) end)
end
```

Ambas hacen lo mismo, ya depende de cuál es más legible para el desarrollador. Estas funciones se conocen como **funciones anónimas o lambdas**.

> **Reutilización de módulo `Util`**
> 
> Para reutilizar el módulo `Util` en cualquier script de Elixir, siga estos pasos:
> 
> 1. Cree un archivo llamado `util.exs` y copie en él el código del módulo `Util` que creamos previamente.
> 2. Abra la terminal y sitúese en la carpeta donde se encuentra dicho archivo.
> 3. Compile el archivo con el siguiente comando:
>    ```bash
>    elixirc util.exs
>    ```
> 4. Al ejecutar este comando, se generará un archivo llamado `Elixir.Util.beam` en la misma carpeta.
> 5. Este archivo contiene la versión compilada del módulo `Util`, y podrá ser utilizado en otros scripts de Elixir.

### Versión 6 (opcional)

Elixir usa notación científica (algo como `5.0e19`) para representar números muy grandes o muy pequeños, lo que puede dificultar la lectura de los resultados. Para mejorar la presentación de los números, se puede utilizar la función `:erlang.float_to_binary/2` para convertir un número a una cadena con un formato específico. Modifique el módulo `Salario` para que el salario se formatee con dos decimales, de la siguiente manera:

```elixir
defmodule Salario do

  def main do
    nombre = "Ingrese el nombre del empleado: "
    |> Util.leer(:string)

    horas_trabajadas = "Ingrese las horas trabajadas: "
    |> Util.leer(:integer)

    valor_por_hora = "Ingrese el valor por hora: "
    |> Util.leer(:float)

    salario = calcular_salario(horas_trabajadas, valor_por_hora)

    generar_mensaje(nombre, salario)
    |> Util.imprimir_mensaje()
  end

  defp calcular_salario(horas, valor), do: horas * valor
  defp formatear_salario(salario), do: :erlang.float_to_binary(salario, decimals: 2)

  defp generar_mensaje(nombre, salario) do
    # Se redondea el salario a dos decimales y evita la notación científica
    salario_formateado = formatear_salario(salario)
    "El salario de #{nombre} es: $#{salario_formateado}"
  end

end

Salario.main()
```

---

## Ejercicio 2

Un estudiante necesita un programa que le ayude a calcular la nota definitiva de dos cursos, cada curso tiene 4 notas parciales. El primer curso calcula la nota definitiva como un promedio aritmético, mientras que el segundo curso lo hace mediante un promedio ponderado usando los porcentajes de 15%, 30%, 35% y 20% respectivamente. Además, el programa debe indicar si el estudiante aprueba o no.

### Versión 1

```elixir
defmodule Notas do

  def main do
    n1 = Util.leer("Ingrese la nota 1: ", :float)
    n2 = Util.leer("Ingrese la nota 2: ", :float)
    n3 = Util.leer("Ingrese la nota 3: ", :float)
    n4 = Util.leer("Ingrese la nota 4: ", :float)

    nota_final = calcular_nota_curso_1(n1, n2, n3, n4)
    es_aprobado = aprobado?(nota_final)

    generar_mensaje(es_aprobado, nota_final)
    |> Util.imprimir_mensaje()

  end

  defp calcular_nota_curso_1(n1, n2, n3, n4), do: (n1 + n2 + n3 + n4) / 4

  defp calcular_nota_curso_2(n1, n2, n3, n4), do: n1 * 0.15 + n2 * 0.30 + n3 * 0.35 + n4 * 0.20

  defp aprobado?(nota), do: nota >= 3.0

  defp generar_mensaje(es_aprobado, nota) do
    if es_aprobado do
      "El estudiante aprobó el curso con una nota de #{nota}."
    else
      "El estudiante no aprobó el curso con una nota de #{nota}."
    end
  end

end

Notas.main()
```

Como se puede ver en el código, si una función es muy simple, se puede utilizar la **sintaxis de una sola línea**. Por ejemplo, las funciones `calcular_nota_curso_1/4`, `calcular_nota_curso_2/4` y `aprobado?/1` son lo suficientemente simples como para ser escritas en una sola línea.

Los nombres de las funciones que retornan un `boolean` deben terminar con un signo de interrogación (`?`) por convención.

### Versión 2

Para esta versión se ha usado el **pattern matching** para simplificar la generación de mensajes.

```elixir
defmodule Notas do

  def main do
    n1 = Util.leer("Ingrese la nota 1: ", :float)
    n2 = Util.leer("Ingrese la nota 2: ", :float)
    n3 = Util.leer("Ingrese la nota 3: ", :float)
    n4 = Util.leer("Ingrese la nota 4: ", :float)

    nota_final = calcular_nota_curso_1(n1, n2, n3, n4)
    es_aprobado = aprobado?(nota_final)

    generar_mensaje(es_aprobado, nota_final)
    |> Util.imprimir_mensaje()

  end

  defp calcular_nota_curso_1(n1, n2, n3, n4), do: (n1 + n2 + n3 + n4) / 4

  defp calcular_nota_curso_2(n1, n2, n3, n4), do: n1 * 0.15 + n2 * 0.30 + n3 * 0.35 + n4 * 0.20

  defp aprobado?(nota), do: nota >= 3.0

  defp generar_mensaje(true, nota), do: "El estudiante aprobó el curso con una nota de #{nota}."
  defp generar_mensaje(false, nota), do: "El estudiante no aprobó el curso con una nota de #{nota}."

end

Notas.main()
```

Hay dos funciones `generar_mensaje/2`, la primera asume que el estudiante aprobó el curso, mientras que la segunda asume que no lo aprobó, observe que el primer patrón coincide con `true` y el segundo con `false`.

> ⚠️ **Importante:** Recuerde que para usar las funciones del módulo `Util`, debe asegurarse de que el archivo `util.exs` esté compilado y disponible en la misma carpeta que su script.

**Complete el código.** Haga que el usuario pueda elegir si desea calcular la nota del primer o segundo curso. Según su elección, se debe llamar a la función `calcular_nota_curso_1` o `calcular_nota_curso_2`. Valide que la opción ingresada por el usuario sea correcta, en caso contrario imprima un mensaje de error.

### Versión 3 (opcional)

En ciertos casos, los números pueden tener muchos decimales, lo que puede dificultar la lectura del resultado. Para mejorar la presentación de la nota final, se puede utilizar la función `Float.round/2` para redondear el resultado a un número específico de decimales. Por ejemplo, para redondear a dos decimales, se puede modificar la función `calcular_nota_curso_1/4` de la siguiente manera:

```elixir
defp calcular_nota_curso_1(n1, n2, n3, n4) do
  nota = (n1 + n2 + n3 + n4) / 4
  Float.round(nota, 2) # Redondea la nota a dos decimales
end
```

La diferencia entre `Float.round/2` y `:erlang.float_to_binary/2` es que `Float.round/2` devuelve un número de punto flotante redondeado, mientras que `:erlang.float_to_binary/2` devuelve una cadena que representa el número en un formato específico.

Use `Float.round/2` si desea mantener el resultado como un número, y use `:erlang.float_to_binary/2` si desea obtener una representación en cadena del número con un formato específico.

---

## Ejercicio 3

Una empresa está haciendo una campaña para promocionar un nuevo producto. Por lo tanto, se está dando un porcentaje de descuento al valor total de la compra de los clientes, el cual varía según el monto de la compra. 

El programa debe solicitar al usuario el monto de la compra y luego aplicar el descuento correspondiente. Los rangos de descuento son los siguientes:

- Si el monto es mayor a **\$50.000** y menor o igual a **\$100.000**, el descuento es del 5%.
- Si el monto es mayor a **\$100.000** y menor o igual a **\$500.000**, el descuento es del 10%.
- Si el monto es mayor a **\$500.000**, el descuento es del 15%.

Se requiere implementar un programa que calcule el precio final después de aplicar el descuento correspondiente e imprima un mensaje con el resultado.

### Versión 1

```elixir
defmodule Descuento do

  def main do
    precio = Util.leer("Ingrese el valor de la compra: ", :float)
    descuento = obtener_descuento(precio)
    precio_final = calcular_descuento(precio, descuento)

    generar_mensaje(precio, descuento, precio_final)
    |> Util.imprimir_mensaje()
  end

  defp obtener_descuento(precio) do
    if precio <= 50000 do
      0
    else
      if precio <= 100000 do
        0.05
      else
        if precio <= 500000 do
          0.1
        else
          0.15
        end
      end
    end
  end

  defp calcular_descuento(precio, descuento), do: precio - (precio * descuento)

  defp generar_mensaje(precio, descuento, precio_final) do
    "El precio original es: #{precio}, el descuento aplicado es: #{descuento * 100}%, y el precio final es: #{precio_final}"
  end

end

Descuento.main()
```

Aunque el código funciona correctamente, presenta múltiples estructuras `if` anidadas que reducen la legibilidad y dificultan el mantenimiento. En Elixir es preferible evitar anidamientos innecesarios y utilizar alternativas más expresivas, como `cond`, `guard` o pattern matching, que permiten evaluar múltiples condiciones de forma más clara y declarativa.
 

### Versión 2

En esta nueva versión se modifica la función `obtener_descuento/1` para utilizar `cond`.

```elixir
defp obtener_descuento(precio) do
  cond do
    precio <= 50000 -> 0
    precio <= 100000 -> 0.05
    precio <= 500000 -> 0.1
    true -> 0.15
  end
end
```

Al usar `cond`, la función `obtener_descuento/1` se simplifica al eliminar la necesidad de múltiples cláusulas `if` que se vuelven difíciles de leer y mantener.

La última condición `true` actúa como un caso por defecto, si ninguna de las condiciones anteriores se cumple, se aplica un descuento del 15%.

### Versión 3

En esta nueva versión se modifica la función `obtener_descuento/1` para utilizar `guard`.

```elixir
defp obtener_descuento(precio) when precio > 50000 and precio <= 100000, do: 0.05
defp obtener_descuento(precio) when precio > 100000 and precio <= 500000, do: 0.1
defp obtener_descuento(precio) when precio > 500000, do: 0.15
defp obtener_descuento(_), do: 0.0
```

Al utilizar `guard`, la función `obtener_descuento/1` se divide en múltiples cláusulas, cada una de las cuales maneja un caso específico. El último caso maneja cualquier valor (`_`) que no cumpla con los criterios anteriores y devuelve un descuento del 0%.

Para más información puede leer acerca de [cond](https://hexdocs.pm/elixir/case-cond-and-if.html#cond) y [guard](https://hexdocs.pm/elixir/1.6.5/guards.html) en la documentación oficial de Elixir, allí puede profundizar en el uso de estas estructuras de control.

---

## Ejercicio 4

Se requiere un programa que simule una lotería básica, donde el usuario puede elegir un número entre **1 y 10**, luego el programa debe generar un número aleatorio en el mismo rango, determinar si el usuario ganó o no y cuál fue la diferencia. Si el usuario escribe un número fuera de este rango, el programa debe informarle que su elección es inválida y terminar.

Para generar números aleatorios en Elixir, se puede utilizar el módulo `:rand` de Erlang. Para más información, puede consultar la [documentación oficial](https://www.erlang.org/doc/apps/stdlib/rand.html).

### Versión 1


```elixir
defmodule Loteria do
  @minimo 1
  @maximo 10

  def main do
    "Ingrese un número entre #{@minimo} y #{@maximo}: "
    |> Util.leer(:integer)
    |> jugar()
    |> Util.imprimir_mensaje()
  end

  defp jugar(numero) when numero >= @minimo and numero <= @maximo do
    numero
    |> calcular_diferencia()
    |> evaluar_resultado()
  end

  defp jugar(_), do: "Número no válido, fin del juego."

  defp calcular_diferencia(numero_usuario) do 
    numero_ganador = :rand.uniform(@maximo) # Genera un número aleatorio entre 1 y @maximo
    abs(numero_usuario - numero_ganador) # Devuelve el valor absoluto de la diferencia
  end

  defp evaluar_resultado(0), do: "¡Felicidades, has ganado!"
  defp evaluar_resultado(diferencia), do: "Lo siento, has perdido. La diferencia fue de #{diferencia}."
end

Loteria.main()
```

En esta implementación se usan dos constantes, `@minimo` y `@maximo` a nivel de módulo, para definir el rango de números válidos. Esto facilita la modificación del rango en el futuro, si es necesario.


### Versión 2 (opcional)

La función `jugar/1` también puede escribirse de la siguiente manera:

```elixir
defp jugar(numero) when numero in @minimo..@maximo do
  numero
  |> calcular_diferencia()
  |> evaluar_resultado()
end
```

La diferencia es que se utiliza un rango de valores (`@minimo..@maximo`) en lugar de combinar operaciones de comparación con `and`. El uso de rangos en los `guard` es una práctica idiomática en Elixir que puede ser mejor en ciertos casos.

---

## Ejercicio 5

Se requiere un programa que calcule las operaciones aritméticas básicas a partir de dos números ingresados por el usuario. Se debe validar que en la división no se produzca una división por cero, cuando una operación se pueda hacer debe retornar un `:ok` junto a la respuesta, en caso contrario debe retornar `:error` con un mensaje apropiado.

```elixir
defmodule Calculadora do

  def main do
    numero1 = Util.leer("Ingrese el primer número: ", :integer)
    numero2 = Util.leer("Ingrese el segundo número: ", :integer)
    operacion = Util.leer("Escriba 1 para suma, 2 para resta, 3 para multiplicación, 4 para división: ", :integer)

    validar_operacion(numero1, numero2, operacion)
    |> generar_mensaje()
    |> Util.imprimir_mensaje()
  end

  defp validar_operacion(numero1, numero2, operacion) when operacion in 1..4 do
    operar(numero1, numero2, operacion)
  end

  defp validar_operacion(_, _, _), do: {:error, "Operación no válida."}

  defp operar(numero1, numero2, 1), do: {:ok, numero1 + numero2}
  defp operar(numero1, numero2, 2), do: {:ok, numero1 - numero2}
  defp operar(numero1, numero2, 3), do: {:ok, numero1 * numero2}
  defp operar(_numero1, 0, 4), do: {:error, "División por cero no permitida."}
  defp operar(numero1, numero2, 4), do: {:ok, numero1 / numero2}
  defp operar(_, _, _), do: {:error, "Operación no válida."}

  defp generar_mensaje({:ok, resultado}), do: "El resultado es: #{resultado}"
  defp generar_mensaje({:error, mensaje}), do: "Error: #{mensaje}"

end

Calculadora.main()
```

Se destaca la utilización de **tuplas** para manejar los resultados de las operaciones, lo que permite un manejo de errores más claro y conciso. Además, gracias al **pattern matching**, se puede descomponer fácilmente el resultado en varias partes y actuar en consecuencia. Lea el código e intente identificar cómo se manejan los diferentes casos.

---

## Ejercicio 6

Eres parte del comité organizador de un concierto. Tienes un total de **325** entradas para repartir entre diferentes colegios. Cada colegio recibirá **20** entradas completas, y lo que sobre se guardará para rifarlas entre el público en general.

Haga un programa en Elixir que calcule:

- ¿Cuántos colegios podrán recibir entradas completas?
- ¿Cuántas entradas sobrarán para la rifa?

Haga una función que retorne una tupla con los resultados, e imprima los resultados en la función principal. También permita que el usuario ingrese la cantidad total de entradas y la cantidad de entradas por colegio.

---

## Ejercicio 7

La alcaldía local quiere hacerle recomendaciones a la comunidad sobre las condiciones climáticas. Para ello, se necesita un programa que analice la temperatura actual y la humedad relativa, y genere un mensaje así:

1. Pedirle al usuario la temperatura actual (°C).
2. Pedirle la humedad relativa (%).
3. Según estas condiciones, muestre un mensaje con recomendaciones:
   - Si la temperatura es mayor o igual a **30°C** y la humedad es alta (**> 70%**), indicar: `"Clima muy caluroso y húmedo, cuidado con golpes de calor"`.
   - Si la temperatura es alta (**≥ 30°C**) pero la humedad es baja (**≤ 40%**), indicar: `"Clima seco y caliente, mantente hidratado"`.
   - Si la temperatura está entre **15°C** y **29°C**, considerar que es `"Clima agradable"`.
   - Si la temperatura es menor a **15°C**, decir: `"Hace frío, abrígate"`.
   - Si los datos no cumplen ninguna condición (ej: humedad fuera de **0–100**), debe mostrar: `"Valores inválidos"`.

Haga un programa en elixir que imprima las recomendaciones.

---

## Para la próxima clase

- Investigue para qué sirve `unless` en Elixir e implemente un programa que utilice esta construcción para verificar si un número ingresado por el usuario es par o impar. Si el número es impar, imprima un mensaje indicando que el número es impar; de lo contrario, no haga nada.
- Investigue para qué sirve `with` en Elixir e implemente un programa que utilice esta construcción para leer dos números ingresados por el usuario y calcular su suma. Si ambos números son válidos, imprima el resultado; de lo contrario, muestre un mensaje de error indicando que uno o ambos números no son válidos.
- Investigar qué colecciones (estructuras de datos) tiene Elixir y sus características principales.
- Investigar sobre el manejo de errores en Elixir y las mejores prácticas.