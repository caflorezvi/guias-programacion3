```
Universidad del QuindÃ­o
Programa de IngenierÃ­a de Sistemas y ComputaciÃ³n
ProgramaciÃ³n III - Expresiones lÃ³gico-matemÃ¡ticas y estructuras de control
Docente: Carlos AndrÃ©s Florez V.
```

# Expresiones lÃ³gico-matemÃ¡ticas y estructuras de control

Para comprender las expresiones lÃ³gico-matemÃ¡ticas en Elixir, es importante familiarizarse con su sintaxis y caracterÃ­sticas principales. A continuaciÃ³n, se presentan algunos de los conceptos fundamentales que se abordarÃ¡n en esta guÃ­a:

- Operadores lÃ³gicos y matemÃ¡ticos.
- Funciones lambda.
- EvaluaciÃ³n de expresiones.
- Patrones de coincidencia (pattern matching).
- Ejemplos prÃ¡cticos.

## Tipos de datos y operadores

En elixir, existen diferentes tipos de datos, como: `integer`, `float`, `boolean`, `atom`, `string`, `list`, `tuple`, entre otros. Para trabajar con estos tipos de datos, es importante conocer las funciones y operadores que se pueden utilizar.

Los operadores lÃ³gicos, matemÃ¡ticos y de comparaciÃ³n son fundamentales para realizar operaciones en Elixir. A continuaciÃ³n se listan los operadores segÃºn su categorÃ­a:

- Operadores lÃ³gicos: `and`, `or`, `not`, `&&`, `||`, `!`
- Operadores matemÃ¡ticos: `+`, `-`, `*`, `/`
- Operadores de comparaciÃ³n: `==`, `!=`, `>`, `<`, `>=`, `<=`, `===`, `!==`

TambiÃ©n existen funciones matemÃ¡ticas como:

- `div/2`, calcula la divisiÃ³n entera.
- `rem/2`, calcula el residuo de una divisiÃ³n.
- `abs/1`, devuelve el valor absoluto de un nÃºmero.
- `round/1`, redondea un nÃºmero al entero mÃ¡s cercano. 

Para mÃ¡s informaciÃ³n sobre tipos de datos, operadores y funciones bÃ¡sicas, puede acceder a [https://hexdocs.pm/elixir/basic-types.html](https://hexdocs.pm/elixir/basic-types.html).

## Ãtomos y tuplas

Los tipos de datos `atom` y `tuple` son estructuras de datos importantes en Elixir. Un `atom` es un valor constante que se utiliza comÃºnmente como identificador o etiqueta. Por ejemplo, `:ok`, `:error` y `:user` son Ã¡tomos. Por otro lado, una `tuple` es una colecciÃ³n ordenada de elementos que puede contener diferentes tipos de datos. Las tuplas se definen utilizando llaves `{}` y son Ãºtiles para agrupar valores relacionados.

Para mÃ¡s informaciÃ³n sobre Ã¡tomos y tuplas, puede consultar [documentaciÃ³n de Ã¡tomos](https://hexdocs.pm/elixir/1.12/Atom.html) y [documentaciÃ³n de tuplas](https://hexdocs.pm/elixir/1.12.3/Tuple.html).

---

## Ejercicio 1

La oficina de tesorerÃ­a de una empresa requiere un programa que calcule el salario de un empleado, considerando las horas trabajadas y el valor establecido por hora. El programa debe solicitar el nombre del empleado, la cantidad de horas laboradas y el valor por hora, para luego obtener el salario correspondiente e imprimirlo.

### VersiÃ³n 1

```elixir
defmodule Salario do

  def main do
    nombre = leer_nombre()
    horas_trabajadas = leer_horas_trabajadas()
    valor_por_hora = leer_valor_por_hora()

    salario = calcular_salario(horas_trabajadas, valor_por_hora)
    imprimir_mensaje(nombre, salario)
  end

  defp leer_nombre do
    IO.gets("Ingrese el nombre del empleado: ") 
    |> String.trim()
  end

  defp leer_horas_trabajadas do
    IO.gets("Ingrese las horas trabajadas: ") 
    |> String.trim() 
    |> String.to_integer()
  end

  defp leer_valor_por_hora do
    IO.gets("Ingrese el valor por hora: ") 
    |> String.trim() 
    |> String.to_float()
  end

  defp calcular_salario(horas_trabajadas, valor_por_hora) do
    horas_trabajadas * valor_por_hora
  end

  defp imprimir_mensaje(nombre, salario) do
    IO.puts("El salario de #{nombre} es: $#{salario}")
  end
end

Salario.main()
```

AsÃ­ como vimos en la clase anterior, el mÃ³dulo `String` de elixir tiene una serie de funciones Ãºtiles para manipular cadenas de texto. Para este ejercicio, es necesario conocer las siguientes funciones:

- `String.to_integer/1`: Convierte una cadena en un nÃºmero entero.
- `String.to_float/1`: Convierte una cadena en un nÃºmero de punto flotante.

> **âš ï¸ Importante:** Las funciones `String.to_integer/1` y `String.to_float/1` pueden fallar si la cadena no representa un nÃºmero vÃ¡lido. Para manejar estos casos, se recomienda utilizar estas funciones dentro de un bloque `try`/`rescue`. 

### VersiÃ³n 2

Usando `try`/`rescue` la funciÃ³n `leer_horas_trabajadas/0` quedarÃ­a de la siguiente manera:

```elixir
defp leer_horas_trabajadas do
  entrada = IO.gets("Ingrese las horas trabajadas: ") 
  |> String.trim()

  try do # Intenta convertir la entrada a un nÃºmero entero
    String.to_integer(entrada)
  rescue # Si ocurre un ArgumentError, se imprime un mensaje de error y se devuelve 0
    ArgumentError ->
      IO.puts("Horas trabajadas invÃ¡lidas. Se utilizarÃ¡ 0 como valor predeterminado.")
      0
  end
end
```

Se asume que algo similar a lo que se hizo con `leer_horas_trabajadas/0` se harÃ¡ con `leer_valor_por_hora/0`. 

Aunque esta implementaciÃ³n es mejor, en elixir **se prefiere utilizar un enfoque mÃ¡s funcional y menos imperativo**. En lugar de usar `try`/`rescue`, se pueden utilizar las funciones `Integer.parse/1` y `Float.parse/1` para manejar la entrada del usuario de manera mÃ¡s robusta.

### VersiÃ³n 3

Para esta implementaciÃ³n se opta por usar `Integer.parse/1` y `Float.parse/1` ya que estas funciones retornan valores explÃ­citos, lo que permite un manejo de errores mÃ¡s controlado. Esto es **mucho mÃ¡s seguro** que usar `String.to_integer/1` y `String.to_float/1`, ya que estas Ãºltimas pueden lanzar excepciones si la entrada no es vÃ¡lida y "explotar" el programa.

```elixir

defp leer_horas_trabajadas do
  horas = IO.gets("Ingrese las horas trabajadas: ") 
  |> String.trim() 
  |> Integer.parse() # Devuelve una tupla o :error

  case horas do # PatrÃ³n de coincidencia
    {numero, _} -> numero # Si horas es una tupla, se obtiene el nÃºmero y se ignora el resto
    :error ->  # Si horas es un Ã¡tomo :error, se imprime un mensaje de error y se devuelve 0
      imprimir_error("Horas trabajadas invÃ¡lidas. Se utilizarÃ¡ 0 como valor predeterminado.")
      0
  end
end

defp leer_valor_por_hora do
  valor = IO.gets("Ingrese el valor por hora: ") 
  |> String.trim() 
  |> Float.parse()

  case valor do
    {numero, _} -> numero
    :error -> 
      imprimir_error("Valor por hora invÃ¡lido. Se utilizarÃ¡ 0 como valor predeterminado.")
      0.0
  end
end

defp imprimir_error(mensaje) do
  IO.puts(:standard_error, mensaje) # Imprime el mensaje de error en la salida estÃ¡ndar de errores (por defecto es la terminal)
end
```

Las funciones `Integer.parse/1` y `Float.parse/1` retornan una **tupla** con dos elementos: el valor numÃ©rico convertido y la parte restante de la cadena. Su forma es:

```elixir
{numero, resto}
```

Si la cadena no comienza con un nÃºmero vÃ¡lido, la funciÃ³n devuelve `:error`.

Para tratar estos posibles resultados, se utiliza un `case`. Esta estructura permite manejar de forma clara los distintos patrones que puede devolver una funciÃ³n, y es especialmente Ãºtil cuando se trabaja con tuplas o con valores que pueden fallar.

Observe que en el `case` se tienen dos patrones:

1. `{numero, _}`: Este patrÃ³n coincide con una tupla donde el primer elemento es el nÃºmero convertido y el segundo elemento (representado por `_`) es ignorado. Si este patrÃ³n coincide, se devuelve `numero`.
2. `:error`: Este patrÃ³n coincide con el Ã¡tomo `:error`. Si este patrÃ³n coincide, se imprime un mensaje de error y se devuelve un valor predeterminado (0 o 0.0).

Esto es lo que se conoce como **pattern matching** o coincidencia de patrones, una caracterÃ­stica poderosa de Elixir que permite descomponer y analizar datos de manera concisa y clara.

---

#### Pattern Matching

El **pattern matching** es una de las caracterÃ­sticas mÃ¡s potentes de Elixir. Permite verificar la forma de un dato y, al mismo tiempo, extraer valores de Ã©l. En este caso, se utiliza para:

* Reconocer la tupla `{numero, resto}`
* Detectar el Ã¡tomo `:error`
* Elegir la acciÃ³n correcta segÃºn el patrÃ³n recibido

Esto hace que el cÃ³digo sea mÃ¡s declarativo y menos propenso a errores, ya que cada caso se define explÃ­citamente.

---

Para mÃ¡s informaciÃ³n, puede consultar los siguientes recursos:

* [MÃ³dulo String](https://hexdocs.pm/elixir/String.html)
* [MÃ³dulo Integer](https://hexdocs.pm/elixir/Integer.html)
* [MÃ³dulo Float](https://hexdocs.pm/elixir/Float.html)
* [DocumentaciÃ³n de `case`](https://hexdocs.pm/elixir/case-cond-and-if.html#case)
* [Pattern matching](https://hexdocs.pm/elixir/pattern-matching.html)


### VersiÃ³n 4

Para mejorar la organizaciÃ³n del cÃ³digo, se puede **crear un mÃ³dulo separado** para manejar las operaciones de entrada/salida. Esto permite que el mÃ³dulo `Salario` se enfoque en la lÃ³gica de negocio y delegue las operaciones de entrada/salida a otro mÃ³dulo.

```elixir
defmodule Salario do

  def main do
    nombre = "Ingrese el nombre del empleado: "
    |> Util.leer(:string)

    horas_trabajadas = "Ingrese las horas trabajadas: "
    |> Util.leer(:integer)

    valor_por_hora = "Ingrese el valor por hora: "
    |> Util.leer(:float)

    salario = calcular_salario(horas_trabajadas, valor_por_hora)

    generar_mensaje(nombre, salario)
    |> Util.imprimir_mensaje
  end

  defp calcular_salario(horas_trabajadas, valor_por_hora) do
    horas_trabajadas * valor_por_hora
  end

  defp generar_mensaje(nombre, salario) do
    "El salario de #{nombre} es: $#{salario}"
  end

end

defmodule Util do

  # FunciÃ³n que lee diferentes tipos de datos segÃºn el segundo parÃ¡metro (:string, :integer, :float)
  def leer(mensaje, :string) do
    IO.gets(mensaje)
    |> String.trim()
  end

  def leer(mensaje, :integer) do
    horas = IO.gets(mensaje)
    |> String.trim()
    |> Integer.parse()

    case horas do
      {numero, _} -> numero
      :error ->
        imprimir_error("Error. Se utilizarÃ¡ 0 como valor predeterminado.")
        0
    end
  end

  def leer(mensaje, :float) do
    valor = IO.gets(mensaje)
    |> String.trim()
    |> Float.parse()

    case valor do
      {numero, _} -> numero
      :error ->
        imprimir_error("Error. Se utilizarÃ¡ 0 como valor predeterminado.")
        0
    end
  end

  def imprimir_error(mensaje) do
    IO.puts(:standard_error, mensaje)
  end

  def imprimir_mensaje(mensaje) do
    IO.puts(mensaje)
  end

end

Salario.main()
```

Ahora las funciones del mÃ³dulo `Util` gestionan la entrada y salida de datos y pueden reutilizarse fÃ¡cilmente desde otros mÃ³dulos. AdemÃ¡s, se emplea un **Ã¡tomo** para indicar el tipo de dato a leer (`:string`, `:integer` o `:float`), y Elixir invoca automÃ¡ticamente la funciÃ³n de parseo correspondiente gracias al **pattern matching**.

### VersiÃ³n 5

Finalmente, se modificarÃ¡ el mÃ³dulo `Util` para que las funciones de lectura de enteros y flotantes utilicen una funciÃ³n auxiliar encargada de la captura del valor, su parseo y el manejo de errores. Con este cambio se **reduce la duplicaciÃ³n de cÃ³digo**.

```elixir
defmodule Util do

  def leer(mensaje, :string) do
    IO.gets(mensaje)
    |> String.trim()
  end

  def leer(mensaje, :integer) do
    leer_con_parser(mensaje, &Integer.parse/1) # Se pasa la funciÃ³n de parseo como argumento
  end

  def leer(mensaje, :float) do
    leer_con_parser(mensaje, &Float.parse/1) # Se pasa la funciÃ³n de parseo como argumento
  end

  defp leer_con_parser(mensaje, funcion) do
    valor = IO.gets(mensaje)
    |> String.trim()
    |> funcion.() # Se ejecuta la funciÃ³n de parseo

    case valor do
      {numero, _} -> numero
      :error ->
        imprimir_error("Error. Se utilizarÃ¡ 0 como valor predeterminado.")
        0
    end
  end

  def imprimir_error(mensaje) do
    IO.puts(:standard_error, mensaje)
  end

  def imprimir_mensaje(mensaje) do
    IO.puts(mensaje)
  end

end
```

La funciÃ³n `leer_con_parser/2` recibe el mensaje y la funciÃ³n de parseo. Para el caso de `leer(mensaje, :integer)` la funciÃ³n de parseo es `Integer.parse/1`. Para ejecutarla se utiliza el operador `.` asÃ­: `funcion.(valor)`. Otra alternativa es pasar la funciÃ³n asÃ­:

```elixir
def leer(mensaje, :integer) do
  leer_con_parser(mensaje, fn valor -> Integer.parse(valor) end)
end
```

Ambas hacen lo mismo, ya depende de cuÃ¡l es mÃ¡s legible para el desarrollador. Estas funciones se conocen como **funciones anÃ³nimas o lambdas**.

---

### ğŸ› ï¸ ReutilizaciÃ³n de mÃ³dulo `Util`

Para reutilizar el mÃ³dulo `Util` en cualquier script de Elixir, siga estos pasos:

1. Cree un archivo llamado `util.exs` y copie en Ã©l el cÃ³digo del mÃ³dulo `Util` que creamos previamente.
2. Abra la terminal y sitÃºese en la carpeta donde se encuentra dicho archivo.
3. Compile el archivo con el siguiente comando:
   ```bash
   elixirc util.exs
   ```
4. Al ejecutar este comando, se generarÃ¡ un archivo llamado `Elixir.Util.beam` en la misma carpeta.
5. Este archivo contiene la versiÃ³n compilada del mÃ³dulo `Util`, y podrÃ¡ ser utilizado en otros scripts de Elixir.

---

## Ejercicio 2

Un estudiante necesita un programa que le ayude a calcular la nota definitiva de dos cursos, cada curso tiene 4 notas parciales. El primer curso calcula la nota definitiva como un promedio aritmÃ©tico, mientras que el segundo curso lo hace mediante un promedio ponderado usando los porcentajes de 15%, 30%, 35% y 20% respectivamente. AdemÃ¡s, el programa debe indicar si el estudiante aprueba o no.

### VersiÃ³n 1

```elixir
defmodule Notas do

  def main do
    n1 = Util.leer("Ingrese la nota 1: ", :float)
    n2 = Util.leer("Ingrese la nota 2: ", :float)
    n3 = Util.leer("Ingrese la nota 3: ", :float)
    n4 = Util.leer("Ingrese la nota 4: ", :float)

    nota_final = calcular_nota_curso_1(n1, n2, n3, n4)
    es_aprobado = aprobado?(nota_final)

    generar_mensaje(es_aprobado, nota_final)
    |> Util.imprimir_mensaje()

  end

  defp calcular_nota_curso_1(n1, n2, n3, n4), do: (n1 + n2 + n3 + n4) / 4

  defp calcular_nota_curso_2(n1, n2, n3, n4), do: n1 * 0.15 + n2 * 0.30 + n3 * 0.35 + n4 * 0.20

  defp aprobado?(nota), do: nota >= 3.0

  defp generar_mensaje(es_aprobado, nota) do
    if es_aprobado do
      "El estudiante aprobÃ³ el curso con una nota de #{nota}."
    else
      "El estudiante no aprobÃ³ el curso con una nota de #{nota}."
    end
  end

end

Notas.main()
```

Como se puede ver en el cÃ³digo, si una funciÃ³n es muy simple, se puede utilizar la **sintaxis de una sola lÃ­nea**. Por ejemplo, las funciones `calcular_nota_curso_1/4`, `calcular_nota_curso_2/4` y `aprobado?/1` son lo suficientemente simples como para ser escritas en una sola lÃ­nea.

Los nombres de las funciones que retornan un `boolean` deben terminar con un signo de interrogaciÃ³n (`?`) por convenciÃ³n.

### VersiÃ³n 2

Para esta versiÃ³n se ha usado el **pattern matching** para simplificar la generaciÃ³n de mensajes.

```elixir
defmodule Notas do

  def main do
    n1 = Util.leer("Ingrese la nota 1: ", :float)
    n2 = Util.leer("Ingrese la nota 2: ", :float)
    n3 = Util.leer("Ingrese la nota 3: ", :float)
    n4 = Util.leer("Ingrese la nota 4: ", :float)

    nota_final = calcular_nota_curso_1(n1, n2, n3, n4)
    es_aprobado = aprobado?(nota_final)

    generar_mensaje(es_aprobado, nota_final)
    |> Util.imprimir_mensaje

  end

  defp calcular_nota_curso_1(n1, n2, n3, n4), do: (n1 + n2 + n3 + n4) / 4

  defp calcular_nota_curso_2(n1, n2, n3, n4), do: n1 * 0.15 + n2 * 0.30 + n3 * 0.35 + n4 * 0.20

  defp aprobado?(nota), do: nota >= 3.0

  defp generar_mensaje(true, nota), do: "El estudiante aprobÃ³ el curso con una nota de #{nota}."
  defp generar_mensaje(false, nota), do: "El estudiante no aprobÃ³ el curso con una nota de #{nota}."

end

Notas.main()
```

Hay dos funciones `generar_mensaje/2`, la primera asume que el estudiante aprobÃ³ el curso, mientras que la segunda asume que no lo aprobÃ³, observe que el primer patrÃ³n coincide con `true` y el segundo con `false`.

> âš ï¸ **Importante:** Recuerde que para usar las funciones del mÃ³dulo `Util`, debe asegurarse de que el archivo `util.exs` estÃ© compilado y disponible en la misma carpeta que su script.

**Complete el cÃ³digo.** Haga que el usuario pueda elegir si desea calcular la nota del primer o segundo curso. SegÃºn su elecciÃ³n, se debe llamar a la funciÃ³n `calcular_nota_curso_1` o `calcular_nota_curso_2`. Valide que la opciÃ³n ingresada por el usuario sea correcta, en caso contrario imprima un mensaje de error.

---

## Ejercicio 3

Una empresa estÃ¡ haciendo una campaÃ±a para promocionar un nuevo producto. Por lo tanto, se estÃ¡ dando un porcentaje de descuento al valor total de la compra de los clientes, el cual varÃ­a segÃºn el monto de la compra. 

El programa debe solicitar al usuario el monto de la compra y luego aplicar el descuento correspondiente. Los rangos de descuento son los siguientes:

- Si el monto es mayor a **\$50.000** y menor o igual a **\$100.000**, el descuento es del 5%.
- Si el monto es mayor a **\$100.000** y menor o igual a **\$500.000**, el descuento es del 10%.
- Si el monto es mayor a **\$500.000**, el descuento es del 15%.

Se requiere implementar un programa que calcule el precio final despuÃ©s de aplicar el descuento correspondiente e imprima un mensaje con el resultado.

### VersiÃ³n 1

```elixir
defmodule Descuento do

  def main do
    precio = Util.leer("Ingrese el valor de la compra: ", :float)
    descuento = obtener_descuento(precio)
    precio_final = calcular_descuento(precio, descuento)

    generar_mensaje(precio, descuento, precio_final)
    |> Util.imprimir_mensaje
  end

  defp obtener_descuento(precio) do
    if precio <= 50000 do
      0
    else
      if precio <= 100000 do
        0.05
      else
        if precio <= 500000 do
          0.1
        else
          0.15
        end
      end
    end
  end

  defp calcular_descuento(precio, descuento), do: precio - (precio * descuento)

  defp generar_mensaje(precio, descuento, precio_final) do
    "El precio original es: #{precio}, el descuento aplicado es: #{descuento * 100}%, y el precio final es: #{precio_final}"
  end

end

Descuento.main()
```

Aunque el cÃ³digo funciona, se puede mejorar utilizando `cond` o `guard` para simplificar el cÃ³digo y hacerlo mÃ¡s legible.

### VersiÃ³n 2

En esta nueva versiÃ³n se modifica la funciÃ³n `obtener_descuento/1` para utilizar `cond`.

```elixir
defp obtener_descuento(precio) do
  cond do
    precio <= 50000 -> 0
    precio <= 100000 -> 0.05
    precio <= 500000 -> 0.1
    true -> 0.15
  end
end
```

Al usar `cond`, la funciÃ³n `obtener_descuento/1` se simplifica al eliminar la necesidad de mÃºltiples clÃ¡usulas `if` que se vuelven difÃ­ciles de leer y mantener.

La Ãºltima condiciÃ³n `true` actÃºa como un caso por defecto, si ninguna de las condiciones anteriores se cumple, se aplica un descuento del 15%.

### VersiÃ³n 3

En esta nueva versiÃ³n se modifica la funciÃ³n `obtener_descuento/1` para utilizar `guard`.

```elixir
defp obtener_descuento(precio) when precio > 50000 and precio <= 100000, do: 0.05
defp obtener_descuento(precio) when precio > 100000 and precio <= 500000, do: 0.1
defp obtener_descuento(precio) when precio > 500000, do: 0.15
defp obtener_descuento(_), do: 0.0
```

Al utilizar `guard`, la funciÃ³n `obtener_descuento/1` se divide en mÃºltiples clÃ¡usulas, cada una de las cuales maneja un caso especÃ­fico. El Ãºltimo caso maneja cualquier valor (`_`) que no cumpla con los criterios anteriores y devuelve un descuento del 0%.

Para mÃ¡s informaciÃ³n puede leer acerca de [cond](https://hexdocs.pm/elixir/case-cond-and-if.html#cond) y [guard](https://hexdocs.pm/elixir/1.6.5/guards.html) en la documentaciÃ³n oficial de Elixir, allÃ­ puede profundizar en el uso de estas estructuras de control.

---

## Ejercicio 4

Se requiere un programa que simule una loterÃ­a bÃ¡sica, donde el usuario puede elegir un nÃºmero entre **1 y 10**, luego el programa debe generar un nÃºmero aleatorio en el mismo rango, determinar si el usuario ganÃ³ o no y cuÃ¡l fue la diferencia. Si el usuario escribe un nÃºmero fuera de este rango, el programa debe informarle que su elecciÃ³n es invÃ¡lida y terminar.

Para generar nÃºmeros aleatorios en Elixir, se puede utilizar el mÃ³dulo `:rand` de Erlang. Para mÃ¡s informaciÃ³n, puede consultar la [documentaciÃ³n oficial](https://www.erlang.org/doc/apps/stdlib/rand.html).


```elixir
defmodule Loteria do
  @minimo 1
  @maximo 10

  def main do
    Util.leer("Ingrese un nÃºmero entre #{@minimo} y #{@maximo}: ", :integer)
    |> validar_y_jugar()
    |> Util.imprimir_mensaje()
  end

  defp validar_y_jugar(numero) when numero >= @minimo and numero <= @maximo, do: ejecutar_sorteo(numero)
  defp validar_y_jugar(_numero), do: "NÃºmero no vÃ¡lido, fin del juego."

  defp ejecutar_sorteo(numero_usuario) do
    numero_ganador = :rand.uniform(@maximo)
    diferencia = abs(numero_usuario - numero_ganador)
    evaluar_resultado(diferencia)
  end

  defp evaluar_resultado(0), do: "Â¡Felicidades, has ganado!"
  defp evaluar_resultado(diferencia), do: "Lo siento, has perdido. La diferencia fue de #{diferencia}."

end

Loteria.main()
```

En esta implementaciÃ³n se usan dos constantes, `@minimo` y `@maximo` a nivel de mÃ³dulo, para definir el rango de nÃºmeros vÃ¡lidos. Esto facilita la modificaciÃ³n del rango en el futuro, si es necesario.

---

## Ejercicio 5

Se requiere un programa que calcule las operaciones aritmÃ©ticas bÃ¡sicas a partir de dos nÃºmeros ingresados por el usuario. Se debe validar que en la divisiÃ³n no se produzca una divisiÃ³n por cero, cuando una operaciÃ³n se pueda hacer debe retornar un `:ok` junto a la respuesta, en caso contrario debe retornar `:error` con un mensaje apropiado.

```elixir
defmodule Calculadora do

  def main do
    numero1 = Util.leer("Ingrese el primer nÃºmero: ", :integer)
    numero2 = Util.leer("Ingrese el segundo nÃºmero: ", :integer)
    operacion = Util.leer("Escriba 1 para suma, 2 para resta, 3 para multiplicaciÃ³n, 4 para divisiÃ³n: ", :integer)

    validar_operacion(numero1, numero2, operacion)
    |> generar_mensaje()
    |> Util.imprimir_mensaje()
  end

  defp validar_operacion(numero1, numero2, operacion) when operacion in 1..4 do
    operar(numero1, numero2, operacion)
  end

  defp validar_operacion(_, _, _), do: {:error, "OperaciÃ³n no vÃ¡lida."}

  defp operar(numero1, numero2, 1), do: {:ok, numero1 + numero2} # Solo se ejecuta si operacion == 1
  defp operar(numero1, numero2, 2), do: {:ok, numero1 - numero2} # Solo se ejecuta si operacion == 2
  defp operar(numero1, numero2, 3), do: {:ok, numero1 * numero2} # Solo se ejecuta si operacion == 3
  defp operar(_numero1, 0, 4), do: {:error, "DivisiÃ³n por cero no permitida."} # Solo se ejecuta si operacion == 4 y numero2 == 0
  defp operar(numero1, numero2, 4), do: {:ok, numero1 / numero2} # Solo se ejecuta si operacion == 4
  defp operar(_, _, _), do: {:error, "OperaciÃ³n no vÃ¡lida."} # Valor por defecto

  defp generar_mensaje({:ok, resultado}), do: "El resultado es: #{resultado}" # Solo se ejecuta si la tupla es {:ok, resultado}
  defp generar_mensaje({:error, mensaje}), do: "Error: #{mensaje}" # Solo se ejecuta si la tupla es {:error, mensaje}

end

Calculadora.main()
```

Se destaca la utilizaciÃ³n de **tuplas** para manejar los resultados de las operaciones, lo que permite un manejo de errores mÃ¡s claro y conciso. AdemÃ¡s, gracias al **pattern matching**, se puede descomponer fÃ¡cilmente el resultado en varias partes y actuar en consecuencia. Lea el cÃ³digo e intente identificar cÃ³mo se manejan los diferentes casos.

---

## Ejercicio 6

Eres parte del comitÃ© organizador de un concierto. Tienes un total de **325** entradas para repartir entre diferentes colegios. Cada colegio recibirÃ¡ **20** entradas completas, y lo que sobre se guardarÃ¡ para rifarlas entre el pÃºblico en general.

Haga un programa en Elixir que calcule:

- Â¿CuÃ¡ntos colegios podrÃ¡n recibir entradas completas?
- Â¿CuÃ¡ntas entradas sobrarÃ¡n para la rifa?

Haga una funciÃ³n que retorne una tupla con los resultados, e imprima los resultados en la funciÃ³n principal. TambiÃ©n permita que el usuario ingrese la cantidad total de entradas y la cantidad de entradas por colegio.

---

## Ejercicio 7

La alcaldÃ­a local quiere hacerle recomendaciones a la comunidad sobre las condiciones climÃ¡ticas. Para ello, se necesita un programa que analice la temperatura actual y la humedad relativa, y genere un mensaje asÃ­:

1. Pedirle al usuario la temperatura actual (Â°C).
2. Pedirle la humedad relativa (%).
3. SegÃºn estas condiciones, muestre un mensaje con recomendaciones:
   - Si la temperatura es mayor o igual a **30Â°C** y la humedad es alta (**> 70%**), indicar: `"Clima muy caluroso y hÃºmedo, cuidado con golpes de calor"`.
   - Si la temperatura es alta (**â‰¥ 30Â°C**) pero la humedad es baja (**â‰¤ 40%**), indicar: `"Clima seco y caliente, mantente hidratado"`.
   - Si la temperatura estÃ¡ entre **15Â°C** y **29Â°C**, considerar que es `"Clima agradable"`.
   - Si la temperatura es menor a **15Â°C**, decir: `"Hace frÃ­o, abrÃ­gate"`.
   - Si los datos no cumplen ninguna condiciÃ³n (ej: humedad fuera de **0â€“100**), debe mostrar: `"Valores invÃ¡lidos"`.

Haga un programa en elixir que imprima las recomendaciones.

---

## Para la prÃ³xima clase

- Investigar quÃ© colecciones (estructuras de datos) tiene Elixir y sus caracterÃ­sticas principales.
- Investigar para quÃ© sirve el operador `&` y cÃ³mo se utiliza en Elixir.
- Investigar sobre el manejo de errores en Elixir y las mejores prÃ¡cticas.