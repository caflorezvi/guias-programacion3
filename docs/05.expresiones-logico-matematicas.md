```
Universidad del Quind√≠o
Programa de Ingenier√≠a de Sistemas y Computaci√≥n
Programaci√≥n III - Expresiones l√≥gico-matem√°ticas y estructuras de control
Docente: Carlos Andr√©s Florez V.
```

# Expresiones l√≥gico-matem√°ticas y estructuras de control

Para comprender las expresiones l√≥gico-matem√°ticas en Elixir, es importante familiarizarse con su sintaxis y caracter√≠sticas principales. A continuaci√≥n, se presentan algunos de los conceptos fundamentales que se abordar√°n en esta gu√≠a:

- Operadores l√≥gicos y matem√°ticos.
- Funciones lambda.
- Evaluaci√≥n de expresiones.
- Patrones de coincidencia (pattern matching).
- Ejemplos pr√°cticos.

## Tipos de datos y operadores

En elixir, existen diferentes tipos de datos, como: `integer`, `float`, `boolean`, `atom`, `string`, `list`, `tuple`, entre otros. Para trabajar con estos tipos de datos, es importante conocer las funciones y operadores que se pueden utilizar.

Los operadores l√≥gicos, matem√°ticos y de comparaci√≥n son fundamentales para realizar operaciones en Elixir. A continuaci√≥n se listan los operadores seg√∫n su categor√≠a:

- Operadores l√≥gicos: `and`, `or`, `not`, `&&`, `||`, `!`
- Operadores matem√°ticos: `+`, `-`, `*`, `/`
- Operadores de comparaci√≥n: `==`, `!=`, `>`, `<`, `>=`, `<=`, `===`, `!==`

Tambi√©n existen funciones matem√°ticas como:

- `div/2`, calcula la divisi√≥n entera.
- `rem/2`, calcula el residuo de una divisi√≥n.
- `abs/1`, devuelve el valor absoluto de un n√∫mero.
- `round/1`, redondea un n√∫mero al entero m√°s cercano.

Para m√°s informaci√≥n sobre tipos de datos, operadores y funciones b√°sicas, puede acceder a [https://hexdocs.pm/elixir/basic-types.html](https://hexdocs.pm/elixir/basic-types.html).

## √Åtomos y tuplas

Los tipos de datos `atom` y `tuple` son estructuras de datos importantes en Elixir. Un `atom` es un valor constante que se utiliza com√∫nmente como identificador o etiqueta. Por ejemplo, `:ok`, `:error` y `:user` son √°tomos. Por otro lado, una `tuple` es una colecci√≥n ordenada de elementos que puede contener diferentes tipos de datos. Las tuplas se definen utilizando llaves `{}` y son √∫tiles para agrupar valores relacionados.

Para m√°s informaci√≥n sobre √°tomos y tuplas, puede consultar [documentaci√≥n de √°tomos](https://hexdocs.pm/elixir/1.12/Atom.html) y [documentaci√≥n de tuplas](https://hexdocs.pm/elixir/1.12.3/Tuple.html).

---

## Ejercicio 1

La oficina de tesorer√≠a de una empresa requiere un programa que calcule el salario de un empleado, considerando las horas trabajadas y el valor establecido por hora. El programa debe solicitar el nombre del empleado, la cantidad de horas laboradas y el valor por hora, para luego obtener el salario correspondiente e imprimirlo.

### Versi√≥n 1

```elixir
defmodule Salario do

  def main do
    nombre = leer_nombre()
    horas_trabajadas = leer_horas_trabajadas()
    valor_por_hora = leer_valor_por_hora()

    salario = calcular_salario(horas_trabajadas, valor_por_hora)
    imprimir_mensaje(nombre, salario)
  end

  defp leer_nombre do
    IO.gets("Ingrese el nombre del empleado: ") 
    |> String.trim()
  end

  defp leer_horas_trabajadas do
    IO.gets("Ingrese las horas trabajadas: ") 
    |> String.trim() 
    |> String.to_integer()
  end

  defp leer_valor_por_hora do
    IO.gets("Ingrese el valor por hora: ") 
    |> String.trim() 
    |> String.to_float()
  end

  defp calcular_salario(horas_trabajadas, valor_por_hora) do
    horas_trabajadas * valor_por_hora
  end

  defp imprimir_mensaje(nombre, salario) do
    IO.puts("El salario de #{nombre} es: $#{salario}")
  end
end

Salario.main()
```

As√≠ como vimos en la clase anterior, el m√≥dulo `String` de elixir tiene una serie de funciones √∫tiles para manipular cadenas de texto. Para este ejercicio, es necesario conocer las siguientes funciones:

- `String.to_integer/1`: Convierte una cadena en un n√∫mero entero.
- `String.to_float/1`: Convierte una cadena en un n√∫mero de punto flotante.

> **‚ö†Ô∏è Importante:** Las funciones `String.to_integer/1` y `String.to_float/1` pueden lanzar excepciones si la cadena no representa un n√∫mero v√°lido. Para manejar estos casos, se recomienda utilizar estas funciones dentro de un bloque `try`/`rescue`. 

### Versi√≥n 2

Usando `try`/`rescue` la funci√≥n `leer_horas_trabajadas/0` quedar√≠a de la siguiente manera:

```elixir
defp leer_horas_trabajadas do
  entrada = IO.gets("Ingrese las horas trabajadas: ") 
  |> String.trim()

  try do # Intenta convertir la entrada a un n√∫mero entero
    String.to_integer(entrada)
  rescue # Si ocurre un ArgumentError, se imprime un mensaje de error y se devuelve 0
    ArgumentError ->
      IO.puts("Horas trabajadas inv√°lidas. Se utilizar√° 0 como valor predeterminado.")
      0
  end
end
```

Se asume que algo similar a lo que se hizo con `leer_horas_trabajadas/0` se har√° con `leer_valor_por_hora/0`. 

Aunque esta implementaci√≥n es mejor, en elixir **se prefiere utilizar un enfoque m√°s funcional y menos imperativo**. En lugar de usar `try`/`rescue`, se pueden utilizar las funciones `Integer.parse/1` y `Float.parse/1` para manejar la entrada del usuario de manera m√°s robusta.

### Versi√≥n 3

Para esta implementaci√≥n se opta por usar `Integer.parse/1` y `Float.parse/1` ya que estas funciones retornan valores expl√≠citos, lo que permite un manejo de errores m√°s controlado. Esto es **mucho m√°s seguro** que usar `String.to_integer/1` y `String.to_float/1`, ya que estas √∫ltimas pueden lanzar excepciones si la entrada no es v√°lida y "explotar" el programa.

```elixir

defp leer_horas_trabajadas do
  horas = IO.gets("Ingrese las horas trabajadas: ") 
  |> String.trim() 
  |> Integer.parse() # Devuelve una tupla o :error

  case horas do # Patr√≥n de coincidencia
    {numero, _} -> numero # Si horas es una tupla, se obtiene el n√∫mero y se ignora el resto
    :error ->  # Si horas es un √°tomo :error, se imprime un mensaje de error y se devuelve 0
      imprimir_error("Horas trabajadas inv√°lidas. Se utilizar√° 0 como valor predeterminado.")
      0
  end
end

defp leer_valor_por_hora do
  valor = IO.gets("Ingrese el valor por hora: ") 
  |> String.trim() 
  |> Float.parse()

  case valor do
    {numero, _} -> numero
    :error -> 
      imprimir_error("Valor por hora inv√°lido. Se utilizar√° 0 como valor predeterminado.")
      0.0
  end
end

defp imprimir_error(mensaje) do
  IO.puts(:standard_error, mensaje) # Imprime el mensaje de error en la salida est√°ndar de errores (por defecto es la terminal)
end
```

Las funciones `Integer.parse/1` y `Float.parse/1` retornan una **tupla** con dos elementos: el valor num√©rico convertido y la parte restante de la cadena. Su forma es:

```elixir
{numero, resto}
```

Si la cadena no comienza con un n√∫mero v√°lido, la funci√≥n devuelve `:error`.

Para tratar estos posibles resultados, se utiliza un `case`. Esta estructura permite manejar de forma clara los distintos patrones que puede devolver una funci√≥n, y es especialmente √∫til cuando se trabaja con tuplas o con valores que pueden fallar.

Observe que en el `case` se tienen dos patrones:

1. `{numero, _}`: Este patr√≥n coincide con una tupla donde el primer elemento es el n√∫mero convertido y el segundo elemento (representado por `_`) es ignorado. Si este patr√≥n coincide, se devuelve `numero`.
2. `:error`: Este patr√≥n coincide con el √°tomo `:error`. Si este patr√≥n coincide, se imprime un mensaje de error y se devuelve un valor predeterminado (0 o 0.0).

Esto es lo que se conoce como **pattern matching** o coincidencia de patrones, una caracter√≠stica poderosa de Elixir que permite descomponer y analizar datos de manera concisa y clara.

#### Pattern Matching

El **pattern matching** es una de las caracter√≠sticas m√°s potentes de Elixir. Permite verificar la forma de un dato y, al mismo tiempo, extraer valores de √©l. En este caso, se utiliza para:

* Reconocer la tupla `{numero, resto}`
* Detectar el √°tomo `:error`
* Elegir la acci√≥n correcta seg√∫n el patr√≥n recibido

Esto hace que el c√≥digo sea m√°s declarativo y menos propenso a errores, ya que cada caso se define expl√≠citamente.

Para m√°s informaci√≥n puede leer acerca del [M√≥dulo String](https://hexdocs.pm/elixir/String.html), [M√≥dulo Integer](https://hexdocs.pm/elixir/Integer.html) y [M√≥dulo Float](https://hexdocs.pm/elixir/Float.html). Adicionalmente, se recomienda revisar [esta documentaci√≥n](https://hexdocs.pm/elixir/case-cond-and-if.html#case) para profundizar en el uso de la estructura `case` y [esta documentaci√≥n](https://hexdocs.pm/elixir/pattern-matching.html) para entender el **pattern matching**.

### Versi√≥n 4

Para mejorar la organizaci√≥n del c√≥digo, se puede **crear un m√≥dulo separado** para manejar las operaciones de entrada/salida. Esto permite que el m√≥dulo `Salario` se enfoque en la l√≥gica de negocio y delegue las operaciones de entrada/salida a otro m√≥dulo.

```elixir
defmodule Salario do
  @moduledoc """
  M√≥dulo que contiene la l√≥gica para calcular el salario de un empleado.
  """

  def main do
    nombre = "Ingrese el nombre del empleado: "
    |> Util.leer(:string)

    horas_trabajadas = "Ingrese las horas trabajadas: "
    |> Util.leer(:integer)

    valor_por_hora = "Ingrese el valor por hora: "
    |> Util.leer(:float)

    salario = calcular_salario(horas_trabajadas, valor_por_hora)

    generar_mensaje(nombre, salario)
    |> Util.imprimir_mensaje
  end

  defp calcular_salario(horas_trabajadas, valor_por_hora) do
    horas_trabajadas * valor_por_hora
  end

  defp generar_mensaje(nombre, salario) do
    "El salario de #{nombre} es: $#{salario}"
  end

end

defmodule Util do
  @moduledoc """
  M√≥dulo de utilidades para manejo de entrada/salida. Este m√≥dulo puede ser reutilizado 
  en otros programas para leer diferentes tipos de datos y manejar errores de entrada de manera consistente.
  """

  def leer(mensaje, :string) do
    IO.gets(mensaje)
    |> String.trim()
  end

  def leer(mensaje, :integer) do
    horas = IO.gets(mensaje)
    |> String.trim()
    |> Integer.parse()

    case horas do
      {numero, _} -> numero
      :error ->
        imprimir_error("Error. Se utilizar√° 0 como valor predeterminado.")
        0
    end
  end

  def leer(mensaje, :float) do
    valor = IO.gets(mensaje)
    |> String.trim()
    |> Float.parse()

    case valor do
      {numero, _} -> numero
      :error ->
        imprimir_error("Error. Se utilizar√° 0 como valor predeterminado.")
        0
    end
  end

  def imprimir_error(mensaje) do
    IO.puts(:standard_error, mensaje)
  end

  def imprimir_mensaje(mensaje) do
    IO.puts(mensaje)
  end

end

Salario.main()
```

Ahora las funciones del m√≥dulo `Util` gestionan la entrada y salida de datos y pueden reutilizarse f√°cilmente desde otros m√≥dulos. Adem√°s, se emplea un **√°tomo** para indicar el tipo de dato a leer (`:string`, `:integer` o `:float`), y Elixir invoca autom√°ticamente la funci√≥n de parseo correspondiente gracias al **pattern matching**.

### Versi√≥n 5

Finalmente, se modificar√° el m√≥dulo `Util` para que las funciones de lectura de enteros y flotantes utilicen una funci√≥n auxiliar encargada de la captura del valor, su parseo y el manejo de errores. Con este cambio se **reduce la duplicaci√≥n de c√≥digo**.

```elixir
defmodule Util do

  def leer(mensaje, :string) do
    IO.gets(mensaje)
    |> String.trim()
  end

  def leer(mensaje, :integer) do
    leer_con_parser(mensaje, &Integer.parse/1) # Se pasa la funci√≥n de parseo como argumento
  end

  def leer(mensaje, :float) do
    leer_con_parser(mensaje, &Float.parse/1) # Se pasa la funci√≥n de parseo como argumento
  end

  defp leer_con_parser(mensaje, funcion) do
    valor = IO.gets(mensaje)
    |> String.trim()
    |> funcion.() # Se ejecuta la funci√≥n de parseo

    case valor do
      {numero, _} -> numero
      :error ->
        imprimir_error("Error. Se utilizar√° 0 como valor predeterminado.")
        0
    end
  end

  def imprimir_error(mensaje) do
    IO.puts(:standard_error, mensaje)
  end

  def imprimir_mensaje(mensaje) do
    IO.puts(mensaje)
  end

end
```

La funci√≥n `leer_con_parser/2` recibe el mensaje y la funci√≥n de parseo. Para el caso de `leer(mensaje, :integer)` la funci√≥n de parseo es `Integer.parse/1`. Para ejecutarla se utiliza el operador `.` as√≠: `funcion.(valor)`. Otra alternativa es pasar la funci√≥n as√≠:

```elixir
def leer(mensaje, :integer) do
  leer_con_parser(mensaje, fn valor -> Integer.parse(valor) end)
end
```

Ambas hacen lo mismo, ya depende de cu√°l es m√°s legible para el desarrollador. Estas funciones se conocen como **funciones an√≥nimas o lambdas**.

#### üõ†Ô∏è Reutilizaci√≥n de m√≥dulo `Util`

Para reutilizar el m√≥dulo `Util` en cualquier script de Elixir, siga estos pasos:

1. Cree un archivo llamado `util.exs` y copie en √©l el c√≥digo del m√≥dulo `Util` que creamos previamente.
2. Abra la terminal y sit√∫ese en la carpeta donde se encuentra dicho archivo.
3. Compile el archivo con el siguiente comando:
   ```bash
   elixirc util.exs
   ```
4. Al ejecutar este comando, se generar√° un archivo llamado `Elixir.Util.beam` en la misma carpeta.
5. Este archivo contiene la versi√≥n compilada del m√≥dulo `Util`, y podr√° ser utilizado en otros scripts de Elixir.

### Versi√≥n 6 (opcional)

Elixir usa notaci√≥n cient√≠fica (algo como `5.0e19`) para representar n√∫meros muy grandes o muy peque√±os, lo que puede dificultar la lectura de los resultados. Para mejorar la presentaci√≥n de los n√∫meros, se puede utilizar la funci√≥n `:erlang.float_to_binary/2` para convertir un n√∫mero a una cadena con un formato espec√≠fico. Modifique el m√≥dulo `Salario` para que el salario se formatee con dos decimales, de la siguiente manera:

```elixir
defmodule Salario do

  def main do
    nombre = "Ingrese el nombre del empleado: "
    |> Util.leer(:string)

    horas_trabajadas = "Ingrese las horas trabajadas: "
    |> Util.leer(:integer)

    valor_por_hora = "Ingrese el valor por hora: "
    |> Util.leer(:float)

    salario = calcular_salario(horas_trabajadas, valor_por_hora)

    generar_mensaje(nombre, salario)
    |> Util.imprimir_mensaje()
  end

  defp calcular_salario(horas, valor), do: horas * valor
  defp formatear_salario(salario), do: :erlang.float_to_binary(salario, decimals: 2)

  defp generar_mensaje(nombre, salario) do
    # Se redondea el salario a dos decimales y evita la notaci√≥n cient√≠fica
    salario_formateado = formatear_salario(salario)
    "El salario de #{nombre} es: $#{salario_formateado}"
  end

end

Salario.main()
```

---

## Ejercicio 2

Un estudiante necesita un programa que le ayude a calcular la nota definitiva de dos cursos, cada curso tiene 4 notas parciales. El primer curso calcula la nota definitiva como un promedio aritm√©tico, mientras que el segundo curso lo hace mediante un promedio ponderado usando los porcentajes de 15%, 30%, 35% y 20% respectivamente. Adem√°s, el programa debe indicar si el estudiante aprueba o no.

### Versi√≥n 1

```elixir
defmodule Notas do

  def main do
    n1 = Util.leer("Ingrese la nota 1: ", :float)
    n2 = Util.leer("Ingrese la nota 2: ", :float)
    n3 = Util.leer("Ingrese la nota 3: ", :float)
    n4 = Util.leer("Ingrese la nota 4: ", :float)

    nota_final = calcular_nota_curso_1(n1, n2, n3, n4)
    es_aprobado = aprobado?(nota_final)

    generar_mensaje(es_aprobado, nota_final)
    |> Util.imprimir_mensaje()

  end

  defp calcular_nota_curso_1(n1, n2, n3, n4), do: (n1 + n2 + n3 + n4) / 4

  defp calcular_nota_curso_2(n1, n2, n3, n4), do: n1 * 0.15 + n2 * 0.30 + n3 * 0.35 + n4 * 0.20

  defp aprobado?(nota), do: nota >= 3.0

  defp generar_mensaje(es_aprobado, nota) do
    if es_aprobado do
      "El estudiante aprob√≥ el curso con una nota de #{nota}."
    else
      "El estudiante no aprob√≥ el curso con una nota de #{nota}."
    end
  end

end

Notas.main()
```

Como se puede ver en el c√≥digo, si una funci√≥n es muy simple, se puede utilizar la **sintaxis de una sola l√≠nea**. Por ejemplo, las funciones `calcular_nota_curso_1/4`, `calcular_nota_curso_2/4` y `aprobado?/1` son lo suficientemente simples como para ser escritas en una sola l√≠nea.

Los nombres de las funciones que retornan un `boolean` deben terminar con un signo de interrogaci√≥n (`?`) por convenci√≥n.

### Versi√≥n 2

Para esta versi√≥n se ha usado el **pattern matching** para simplificar la generaci√≥n de mensajes.

```elixir
defmodule Notas do

  def main do
    n1 = Util.leer("Ingrese la nota 1: ", :float)
    n2 = Util.leer("Ingrese la nota 2: ", :float)
    n3 = Util.leer("Ingrese la nota 3: ", :float)
    n4 = Util.leer("Ingrese la nota 4: ", :float)

    nota_final = calcular_nota_curso_1(n1, n2, n3, n4)
    es_aprobado = aprobado?(nota_final)

    generar_mensaje(es_aprobado, nota_final)
    |> Util.imprimir_mensaje

  end

  defp calcular_nota_curso_1(n1, n2, n3, n4), do: (n1 + n2 + n3 + n4) / 4

  defp calcular_nota_curso_2(n1, n2, n3, n4), do: n1 * 0.15 + n2 * 0.30 + n3 * 0.35 + n4 * 0.20

  defp aprobado?(nota), do: nota >= 3.0

  defp generar_mensaje(true, nota), do: "El estudiante aprob√≥ el curso con una nota de #{nota}."
  defp generar_mensaje(false, nota), do: "El estudiante no aprob√≥ el curso con una nota de #{nota}."

end

Notas.main()
```

Hay dos funciones `generar_mensaje/2`, la primera asume que el estudiante aprob√≥ el curso, mientras que la segunda asume que no lo aprob√≥, observe que el primer patr√≥n coincide con `true` y el segundo con `false`.

> ‚ö†Ô∏è **Importante:** Recuerde que para usar las funciones del m√≥dulo `Util`, debe asegurarse de que el archivo `util.exs` est√© compilado y disponible en la misma carpeta que su script.

**Complete el c√≥digo.** Haga que el usuario pueda elegir si desea calcular la nota del primer o segundo curso. Seg√∫n su elecci√≥n, se debe llamar a la funci√≥n `calcular_nota_curso_1` o `calcular_nota_curso_2`. Valide que la opci√≥n ingresada por el usuario sea correcta, en caso contrario imprima un mensaje de error.

### Versi√≥n 3 (opcional)

En ciertos casos, los n√∫meros pueden tener muchos decimales, lo que puede dificultar la lectura del resultado. Para mejorar la presentaci√≥n de la nota final, se puede utilizar la funci√≥n `Float.round/2` para redondear el resultado a un n√∫mero espec√≠fico de decimales. Por ejemplo, para redondear a dos decimales, se puede modificar la funci√≥n `calcular_nota_curso_1/4` de la siguiente manera:

```elixir
defp calcular_nota_curso_1(n1, n2, n3, n4) do
  nota = (n1 + n2 + n3 + n4) / 4
  Float.round(nota, 2) # Redondea la nota a dos decimales
end
```

La diferencia entre `Float.round/2` y `:erlang.float_to_binary/2` es que `Float.round/2` devuelve un n√∫mero de punto flotante redondeado, mientras que `:erlang.float_to_binary/2` devuelve una cadena que representa el n√∫mero en un formato espec√≠fico.

Use `Float.round/2` si desea mantener el resultado como un n√∫mero, y use `:erlang.float_to_binary/2` si desea obtener una representaci√≥n en cadena del n√∫mero con un formato espec√≠fico.

---

## Ejercicio 3

Una empresa est√° haciendo una campa√±a para promocionar un nuevo producto. Por lo tanto, se est√° dando un porcentaje de descuento al valor total de la compra de los clientes, el cual var√≠a seg√∫n el monto de la compra. 

El programa debe solicitar al usuario el monto de la compra y luego aplicar el descuento correspondiente. Los rangos de descuento son los siguientes:

- Si el monto es mayor a **\$50.000** y menor o igual a **\$100.000**, el descuento es del 5%.
- Si el monto es mayor a **\$100.000** y menor o igual a **\$500.000**, el descuento es del 10%.
- Si el monto es mayor a **\$500.000**, el descuento es del 15%.

Se requiere implementar un programa que calcule el precio final despu√©s de aplicar el descuento correspondiente e imprima un mensaje con el resultado.

### Versi√≥n 1

```elixir
defmodule Descuento do

  def main do
    precio = Util.leer("Ingrese el valor de la compra: ", :float)
    descuento = obtener_descuento(precio)
    precio_final = calcular_descuento(precio, descuento)

    generar_mensaje(precio, descuento, precio_final)
    |> Util.imprimir_mensaje
  end

  defp obtener_descuento(precio) do
    if precio <= 50000 do
      0
    else
      if precio <= 100000 do
        0.05
      else
        if precio <= 500000 do
          0.1
        else
          0.15
        end
      end
    end
  end

  defp calcular_descuento(precio, descuento), do: precio - (precio * descuento)

  defp generar_mensaje(precio, descuento, precio_final) do
    "El precio original es: #{precio}, el descuento aplicado es: #{descuento * 100}%, y el precio final es: #{precio_final}"
  end

end

Descuento.main()
```

Aunque el c√≥digo funciona, se puede mejorar utilizando `cond` o `guard` para simplificar el c√≥digo y hacerlo m√°s legible.

### Versi√≥n 2

En esta nueva versi√≥n se modifica la funci√≥n `obtener_descuento/1` para utilizar `cond`.

```elixir
defp obtener_descuento(precio) do
  cond do
    precio <= 50000 -> 0
    precio <= 100000 -> 0.05
    precio <= 500000 -> 0.1
    true -> 0.15
  end
end
```

Al usar `cond`, la funci√≥n `obtener_descuento/1` se simplifica al eliminar la necesidad de m√∫ltiples cl√°usulas `if` que se vuelven dif√≠ciles de leer y mantener.

La √∫ltima condici√≥n `true` act√∫a como un caso por defecto, si ninguna de las condiciones anteriores se cumple, se aplica un descuento del 15%.

### Versi√≥n 3

En esta nueva versi√≥n se modifica la funci√≥n `obtener_descuento/1` para utilizar `guard`.

```elixir
defp obtener_descuento(precio) when precio > 50000 and precio <= 100000, do: 0.05
defp obtener_descuento(precio) when precio > 100000 and precio <= 500000, do: 0.1
defp obtener_descuento(precio) when precio > 500000, do: 0.15
defp obtener_descuento(_), do: 0.0
```

Al utilizar `guard`, la funci√≥n `obtener_descuento/1` se divide en m√∫ltiples cl√°usulas, cada una de las cuales maneja un caso espec√≠fico. El √∫ltimo caso maneja cualquier valor (`_`) que no cumpla con los criterios anteriores y devuelve un descuento del 0%.

Para m√°s informaci√≥n puede leer acerca de [cond](https://hexdocs.pm/elixir/case-cond-and-if.html#cond) y [guard](https://hexdocs.pm/elixir/1.6.5/guards.html) en la documentaci√≥n oficial de Elixir, all√≠ puede profundizar en el uso de estas estructuras de control.

---

## Ejercicio 4

Se requiere un programa que simule una loter√≠a b√°sica, donde el usuario puede elegir un n√∫mero entre **1 y 10**, luego el programa debe generar un n√∫mero aleatorio en el mismo rango, determinar si el usuario gan√≥ o no y cu√°l fue la diferencia. Si el usuario escribe un n√∫mero fuera de este rango, el programa debe informarle que su elecci√≥n es inv√°lida y terminar.

Para generar n√∫meros aleatorios en Elixir, se puede utilizar el m√≥dulo `:rand` de Erlang. Para m√°s informaci√≥n, puede consultar la [documentaci√≥n oficial](https://www.erlang.org/doc/apps/stdlib/rand.html).


```elixir
defmodule Loteria do
  @minimo 1
  @maximo 10

  def main do
    Util.leer("Ingrese un n√∫mero entre #{@minimo} y #{@maximo}: ", :integer)
    |> validar_y_jugar()
    |> Util.imprimir_mensaje()
  end

  defp validar_y_jugar(numero) when numero >= @minimo and numero <= @maximo, do: ejecutar_sorteo(numero)
  defp validar_y_jugar(_numero), do: "N√∫mero no v√°lido, fin del juego."

  defp ejecutar_sorteo(numero_usuario) do
    numero_ganador = :rand.uniform(@maximo)
    diferencia = abs(numero_usuario - numero_ganador)
    evaluar_resultado(diferencia)
  end

  defp evaluar_resultado(0), do: "¬°Felicidades, has ganado!"
  defp evaluar_resultado(diferencia), do: "Lo siento, has perdido. La diferencia fue de #{diferencia}."

end

Loteria.main()
```

En esta implementaci√≥n se usan dos constantes, `@minimo` y `@maximo` a nivel de m√≥dulo, para definir el rango de n√∫meros v√°lidos. Esto facilita la modificaci√≥n del rango en el futuro, si es necesario.

---

## Ejercicio 5

Se requiere un programa que calcule las operaciones aritm√©ticas b√°sicas a partir de dos n√∫meros ingresados por el usuario. Se debe validar que en la divisi√≥n no se produzca una divisi√≥n por cero, cuando una operaci√≥n se pueda hacer debe retornar un `:ok` junto a la respuesta, en caso contrario debe retornar `:error` con un mensaje apropiado.

```elixir
defmodule Calculadora do

  def main do
    numero1 = Util.leer("Ingrese el primer n√∫mero: ", :integer)
    numero2 = Util.leer("Ingrese el segundo n√∫mero: ", :integer)
    operacion = Util.leer("Escriba 1 para suma, 2 para resta, 3 para multiplicaci√≥n, 4 para divisi√≥n: ", :integer)

    validar_operacion(numero1, numero2, operacion)
    |> generar_mensaje()
    |> Util.imprimir_mensaje()
  end

  defp validar_operacion(numero1, numero2, operacion) when operacion in 1..4 do
    operar(numero1, numero2, operacion)
  end

  defp validar_operacion(_, _, _), do: {:error, "Operaci√≥n no v√°lida."}

  defp operar(numero1, numero2, 1), do: {:ok, numero1 + numero2}
  defp operar(numero1, numero2, 2), do: {:ok, numero1 - numero2}
  defp operar(numero1, numero2, 3), do: {:ok, numero1 * numero2}
  defp operar(_numero1, 0, 4), do: {:error, "Divisi√≥n por cero no permitida."}
  defp operar(numero1, numero2, 4), do: {:ok, numero1 / numero2}
  defp operar(_, _, _), do: {:error, "Operaci√≥n no v√°lida."}

  defp generar_mensaje({:ok, resultado}), do: "El resultado es: #{resultado}"
  defp generar_mensaje({:error, mensaje}), do: "Error: #{mensaje}"

end

Calculadora.main()
```

Se destaca la utilizaci√≥n de **tuplas** para manejar los resultados de las operaciones, lo que permite un manejo de errores m√°s claro y conciso. Adem√°s, gracias al **pattern matching**, se puede descomponer f√°cilmente el resultado en varias partes y actuar en consecuencia. Lea el c√≥digo e intente identificar c√≥mo se manejan los diferentes casos.

---

## Ejercicio 6

Eres parte del comit√© organizador de un concierto. Tienes un total de **325** entradas para repartir entre diferentes colegios. Cada colegio recibir√° **20** entradas completas, y lo que sobre se guardar√° para rifarlas entre el p√∫blico en general.

Haga un programa en Elixir que calcule:

- ¬øCu√°ntos colegios podr√°n recibir entradas completas?
- ¬øCu√°ntas entradas sobrar√°n para la rifa?

Haga una funci√≥n que retorne una tupla con los resultados, e imprima los resultados en la funci√≥n principal. Tambi√©n permita que el usuario ingrese la cantidad total de entradas y la cantidad de entradas por colegio.

---

## Ejercicio 7

La alcald√≠a local quiere hacerle recomendaciones a la comunidad sobre las condiciones clim√°ticas. Para ello, se necesita un programa que analice la temperatura actual y la humedad relativa, y genere un mensaje as√≠:

1. Pedirle al usuario la temperatura actual (¬∞C).
2. Pedirle la humedad relativa (%).
3. Seg√∫n estas condiciones, muestre un mensaje con recomendaciones:
   - Si la temperatura es mayor o igual a **30¬∞C** y la humedad es alta (**> 70%**), indicar: `"Clima muy caluroso y h√∫medo, cuidado con golpes de calor"`.
   - Si la temperatura es alta (**‚â• 30¬∞C**) pero la humedad es baja (**‚â§ 40%**), indicar: `"Clima seco y caliente, mantente hidratado"`.
   - Si la temperatura est√° entre **15¬∞C** y **29¬∞C**, considerar que es `"Clima agradable"`.
   - Si la temperatura es menor a **15¬∞C**, decir: `"Hace fr√≠o, abr√≠gate"`.
   - Si los datos no cumplen ninguna condici√≥n (ej: humedad fuera de **0‚Äì100**), debe mostrar: `"Valores inv√°lidos"`.

Haga un programa en elixir que imprima las recomendaciones.

---

## Para la pr√≥xima clase

- Investigue para qu√© sirve `unless` en Elixir e implemente un programa que utilice esta construcci√≥n para verificar si un n√∫mero ingresado por el usuario es par o impar. Si el n√∫mero es impar, imprima un mensaje indicando que el n√∫mero es impar; de lo contrario, no haga nada.
- Investigue para qu√© sirve `with` en Elixir e implemente un programa que utilice esta construcci√≥n para leer dos n√∫meros ingresados por el usuario y calcular su suma. Si ambos n√∫meros son v√°lidos, imprima el resultado; de lo contrario, muestre un mensaje de error indicando que uno o ambos n√∫meros no son v√°lidos.
- Investigar qu√© colecciones (estructuras de datos) tiene Elixir y sus caracter√≠sticas principales.
- Investigar sobre el manejo de errores en Elixir y las mejores pr√°cticas.