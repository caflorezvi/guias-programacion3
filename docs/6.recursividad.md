<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

```
Universidad del Quindío
Programa de Ingeniería de Sistemas y Computación
Programación III - Recursividad
Docente: Carlos Andrés Florez V.
```

# Recursividad

La recursividad es una técnica de programación en la que **una función se llama a sí misma** para resolver un problema. En Elixir, la recursividad es una herramienta poderosa y se utiliza con frecuencia para trabajar con estructuras de datos como listas y árboles.

Considere la recursividad como una alternativa a los bucles tradicionales (como `for` o `while`) que se encuentran en otros lenguajes de programación. En los **lenguajes funcionales**, como Elixir, la recursividad es la forma preferida de iterar sobre datos. Por lo tanto, es fundamental entender cómo funciona y cómo implementarla correctamente.

## Conceptos clave

- **Caso base**: Es la condición que detiene la recursión. Sin un caso base, la función se llamará a sí misma indefinidamente, lo que resultará en un desbordamiento de pila.
- **Llamada recursiva**: Es la invocación de la función dentro de sí misma, generalmente con un argumento modificado que se acerca al caso base.

## Pila de llamadas

Cada vez que una función se llama a sí misma, se agrega una **nueva entrada** en la pila de llamadas. Cuando la función llega al **caso base**, las llamadas empiezan a resolverse en orden inverso, devolviendo los resultados a las funciones anteriores. Todo este proceso lo maneja automáticamente el entorno de ejecución de Elixir.

La pila de llamadas no es exclusiva de la recursividad. Cada vez que una función llama a otra, también se crea una nueva entrada en la pila, y cuando esa función termina, el control vuelve a la función que la llamó.

## Estado de las variables

En Elixir, las variables son **inmutables**. Esto significa que cada vez que una función se llama a sí misma, se crea un **nuevo contexto de ejecución** con sus propias variables. Por eso, los cambios en una llamada recursiva no afectan a las variables de las llamadas anteriores.

Si se quiere mantener un valor entre llamadas recursivas, es necesario **pasarlo como argumento** en la llamada recursiva.

## Ejemplo de recursividad

A continuación, se presentan ejemplos típicos de funciones recursivas y su implementación en Elixir.

### Factorial

El factorial de un número se calcula como el producto de todos los enteros positivos desde uno hasta ese número.

$$
n! = n \cdot (n-1) \cdot (n-2) \cdot \cdots \cdot 2 \cdot 1
$$

Su definición formal evidencia su naturaleza recursiva:

$$
n! =
\begin{cases}
1, & \text{si } n = 0, \\
n \cdot (n-1)!, & \text{si } n > 0.
\end{cases}
$$

Por lo tanto, su implementación en Elixir es la siguiente:

```elixir
defmodule Matematicas do
  def factorial(0), do: 1
  def factorial(n) when n > 0, do: n * factorial(n - 1)
end
```

En este ejemplo, la función `factorial/1` tiene dos cláusulas:
1. El caso base: `factorial(0)` devuelve 1.
2. La llamada recursiva: `factorial(n - 1)` se llama con un argumento reducido.

**Prueba de escritorio:**

Se quiere calcular el factorial de 5. El paso a paso sería el siguiente:

1. `factorial(5)` = 5 * `factorial(4)`
2. `factorial(4)` = 4 * `factorial(3)`
3. `factorial(3)` = 3 * `factorial(2)`
4. `factorial(2)` = 2 * `factorial(1)`
5. `factorial(1)` = 1 * `factorial(0)`
6. `factorial(0)` = 1

Por lo tanto, `factorial(5)` = 5 * 4 * 3 * 2 * 1 = 120.

### Fibonacci

La secuencia de Fibonacci es una serie de números en la que cada número es la suma de los dos anteriores. La definición formal de la secuencia es:

$$
F(n) = \begin{cases}
0 & \text{si } n = 0 \\
1 & \text{si } n = 1 \\
F(n-1) + F(n-2) & \text{si } n > 1
\end{cases}
$$

Se evidencia igualmente su naturaleza recursiva. La implementación en Elixir es la siguiente:

```elixir
defmodule Matematicas do
  def fibonacci(0), do: 0
  def fibonacci(1), do: 1
  def fibonacci(n) when n > 1, do: fibonacci(n - 1) + fibonacci(n - 2)
end
```

Tenemos dos cláusulas en la función `fibonacci/1`:

1. El caso base: `fibonacci(0)` devuelve 0 y `fibonacci(1)` devuelve 1.
2. La llamada recursiva: `fibonacci(n - 1) + fibonacci(n - 2)` se llama con argumentos reducidos.

**Prueba de escritorio:**

Se quiere calcular el enésimo número de Fibonacci, por ejemplo, el 5. El paso a paso sería el siguiente:

1. `fibonacci(5)` = `fibonacci(4)` + `fibonacci(3)`
2. `fibonacci(4)` = `fibonacci(3)` + `fibonacci(2)`
3. `fibonacci(3)` = `fibonacci(2)` + `fibonacci(1)`
4. `fibonacci(2)` = `fibonacci(1)` + `fibonacci(0)`
5. `fibonacci(1)` = 1
6. `fibonacci(0)` = 0

Reemplazando los valores, tenemos:

`fibonacci(5)` = 5
`fibonacci(4)` = 3
`fibonacci(3)` = 2
`fibonacci(2)` = 1
`fibonacci(1)` = 1
`fibonacci(0)` = 0

Por lo tanto, `fibonacci(5)` = 5.

Aunque esta implementación es simple y directa, no es la más eficiente debido a la recomputación de valores. Más adelante, se pueden explorar técnicas para optimizarla.

### Potencia

La potencia de un número se calcula como el producto de ese número por sí mismo un cierto número de veces. La definición formal es:

$$
a^n = \begin{cases}
1 & \text{si } n = 0 \\
a \cdot a^{n-1} & \text{si } n > 0
\end{cases}
$$

La implementación en Elixir es la siguiente:

```elixir
defmodule Matematicas do
  def potencia(_, 0), do: 1
  def potencia(a, n) when n > 0, do: a * potencia(a, n - 1)
end
```

La función `potencia/2` tiene dos cláusulas:

1. El caso base: `potencia(_, 0)` devuelve 1. Ignora la base.
2. La llamada recursiva: `potencia(a, n - 1)` se llama con un argumento reducido.

**Prueba de escritorio:**

Se quiere calcular `potencia(2, 3)`. El paso a paso sería el siguiente:

1. `potencia(2, 3)` = 2 * `potencia(2, 2)`
2. `potencia(2, 2)` = 2 * `potencia(2, 1)`
3. `potencia(2, 1)` = 2 * `potencia(2, 0)`
4. `potencia(2, 0)` = 1

Por lo tanto, `potencia(2, 3)` = 2 * 2 * 2 * 1 = 8.

### Multiplicación

La multiplicación de dos números se puede definir de manera recursiva como la suma repetida de uno de los números. La definición formal es:

$$
mult(a, b) = \begin{cases}
0 & \text{si } b = 0 \\
a + mult(a, b-1) & \text{si } b > 0
\end{cases}
$$

La implementación en Elixir es la siguiente:

```elixir
defmodule Matematicas do
  def multiplicar(_, 0), do: 0
  def multiplicar(a, b) when b > 0, do: a + multiplicar(a, b - 1)
end
```

**Prueba de escritorio:**

Se quiere calcular `multiplicar(2, 3)`. El paso a paso sería el siguiente:

1. `multiplicar(2, 3)` = 2 + `multiplicar(2, 2)`
2. `multiplicar(2, 2)` = 2 + `multiplicar(2, 1)`
3. `multiplicar(2, 1)` = 2 + `multiplicar(2, 0)`
4. `multiplicar(2, 0)` = 0

Por lo tanto, `multiplicar(2, 3)` = 2 + 2 + 2 + 0 = 6.

### Cadenas

La recursividad también se puede utilizar para manipular cadenas de texto. Por ejemplo, podemos implementar una función que invierta una cadena de la siguiente manera:

```elixir
defmodule Cadenas do

  def invertir(""), do: "" # Caso base: la cadena vacía se invierte a sí misma

  def invertir(cadena) do
    cadena_restante = String.slice(cadena, 0..-2//1) # Obtener la cadena sin el último carácter
    |> invertir() # Llamada recursiva con la cadena restante
    String.last(cadena) <> cadena_restante # Concatenar el último carácter con la cadena invertida
  end
end
``` 

El módulo `String` ya cuenta con la función `String.reverse/1` que invierte una cadena de texto de manera eficiente, pero es útil entender cómo funciona la recursión en este contexto.

**Prueba de escritorio:**

Se quiere calcular `Cadenas.invertir("hola")`. El paso a paso sería el siguiente:

1. `Cadenas.invertir("hola")` = "a" <> `Cadenas.invertir("hol")`
2. `Cadenas.invertir("hol")` = "l" <> `Cadenas.invertir("ho")`
3. `Cadenas.invertir("ho")` = "o" <> `Cadenas.invertir("h")`
4. `Cadenas.invertir("h")` = "h" <> `Cadenas.invertir("")`
5. `Cadenas.invertir("")` = ""

Por lo tanto, `Cadenas.invertir("hola")` = "a" <> "l" <> "o" <> "h" <> "" = "aloh".

### Listas

La recursividad es una técnica común para procesar listas en Elixir. Podemos utilizarla para implementar funciones que operen sobre listas de manera elegante y concisa. Aunque Elixir ya proporciona muchas funciones para trabajar con listas, como `Enum.map/2`, `Enum.filter/2`, y `Enum.reduce/3`, es útil entender cómo se pueden implementar estas operaciones de manera recursiva.

**Ejemplo 1: Sumar los elementos de una lista**

Por ejemplo, podemos definir una función que sume todos los elementos de una lista.

```elixir
defmodule Listas do
  def sumar([]), do: 0 # Caso base: la suma de una lista vacía es 0
  def sumar([head | tail]), do: head + sumar(tail) # Descomponer la lista en cabeza y cola. Se suma el head y se llama recursivamente con la cola (tail)
end
```

En este caso, la función `sumar/1` también tiene un caso base (una lista vacía) y una llamada recursiva que descompone la lista en su cabeza y cola.

Recuerde que en Elixir, las listas se representan como `[head | tail]`, donde `head` es el primer elemento de la lista y `tail` es el resto de la lista. Al descomponer la lista de esta manera, `tail` siempre será una lista (incluso si está vacía), lo que facilita la recursión.

**Prueba de escritorio:**

Se quiere calcular `Listas.sumar([1, 2, 3])`. El paso a paso sería el siguiente:

1. `Listas.sumar([1, 2, 3])` = 1 + `Listas.sumar([2, 3])`
2. `Listas.sumar([2, 3])` = 2 + `Listas.sumar([3])`
3. `Listas.sumar([3])` = 3 + `Listas.sumar([])`
4. `Listas.sumar([])` = 0

Por lo tanto, `Listas.sumar([1, 2, 3])` = 1 + 2 + 3 + 0 = 6.

**Ejemplo 2: Contar los números pares de una lista**

En este otro ejemplo, se cuentan los números de una lista que son pares, se utiliza guardas para verificar si el número es par:

```elixir
defmodule Listas do
  def contar_pares([]), do: 0
  def contar_pares([head | tail]) when rem(head, 2) == 0, do: 1 + contar_pares(tail) # Solo se cuenta si el residuo es 0
  def contar_pares([_head | tail]), do: contar_pares(tail) # No se cuenta si es impar, pero se sigue recorriendo la lista
end
```

**Prueba de escritorio:**

Se quiere calcular `Listas.contar_pares([1, 2, 3, 4, 5])`. El paso a paso sería el siguiente:

1. `Listas.contar_pares([1, 2, 3, 4, 5])` = `contar_pares([2, 3, 4, 5])` (1 es impar, no se cuenta)
2. `contar_pares([2, 3, 4, 5])` = 1 + `contar_pares([3, 4, 5])` (2 es par, se cuenta)
3. `contar_pares([3, 4, 5])` = `contar_pares([4, 5])` (3 es impar, no se cuenta)
4. `contar_pares([4, 5])` = 1 + `contar_pares([5])` (4 es par, se cuenta)
5. `contar_pares([5])` = `contar_pares([])` (5 es impar, no se cuenta)
6. `contar_pares([])` = 0

Por lo tanto, `Listas.contar_pares([1, 2, 3, 4, 5])` = 1 + 1 + 0 = 2.

**Ejemplo 3: Encontrar el máximo en una lista**

En este caso se encuentra el valor máximo en una lista de números, se utiliza un enfoque recursivo para comparar los elementos de la lista.

```elixir
defmodule Listas do
  def maximo([head | tail]), do: maximo(tail, head) # Se inicia la búsqueda con el primer elemento como el mayor

  defp maximo([], mayor), do: mayor # Caso base: si la lista está vacía, se devuelve el mayor encontrado
  defp maximo([head | tail], mayor) when head > mayor, do: maximo(tail, head) # Si el head es mayor, se actualiza el mayor
  defp maximo([_head | tail], mayor), do: maximo(tail, mayor) # Si no, se sigue con el mismo mayor y se sigue recorriendo la lista
end
```

Este es un ejemplo de cómo se require un parámetro adicional para mantener el estado del mayor valor encontrado hasta el momento y evitar el uso de variables globales.

**Prueba de escritorio:**

Se quiere calcular `Listas.maximo([3, 1, 4, 1, 5, 9])`. El paso a paso sería el siguiente:

1. `Listas.maximo([3, 1, 4, 1, 5, 9])` = `maximo([1, 4, 1, 5, 9], 3)` (3 es el mayor inicial)
2. `maximo([1, 4, 1, 5, 9], 3)` = `maximo([4, 1, 5, 9], 3)` (3 es mayor que 1, no se actualiza)
3. `maximo([4, 1, 5, 9], 3)` = `maximo([1, 5, 9], 4)` (4 es mayor que 3, se actualiza)
4. `maximo([1, 5, 9], 4)` = `maximo([5, 9], 4)` (4 es mayor que 1, no se actualiza)
5. `maximo([5, 9], 4)` = `maximo([9], 5)` (5 es mayor que 4, se actualiza)
6. `maximo([9], 5)` = `maximo([], 9)` (9 es mayor que 5, se actualiza)
7. `maximo([], 9)` = 9 (caso base)

Por lo tanto, `Listas.maximo([3, 1, 4, 1, 5, 9])` = 9.

---

# Recursividad de cola

La **recursividad de cola** (*tail recursion*) es un tipo de recursión en la que la llamada recursiva es la **última instrucción** que realiza la función. Esto permite que el compilador o intérprete haga una optimización especial llamada *tail call optimization* (TCO). Gracias a esta optimización, no se crean nuevos espacios en la pila para cada llamada, sino que se reutiliza el mismo. De esta forma se evita que la pila crezca demasiado y se produzca un desbordamiento en casos de recursión muy profunda.

Lenguajes como **Elixir** y **Erlang** aplican esta optimización de forma automática. Otros lenguajes, como **Python** o **Java**, no la implementan, por lo que es importante tener en cuenta las limitaciones de cada lenguaje.

## Ejemplos de recursividad de cola

A continuación, se presentan ejemplos de recursividad de cola para las funciones que ya hemos visto.

### Factorial

Usando recursividad de cola, podemos implementar la función factorial de la siguiente manera:

```elixir
defmodule Matematicas do
  def factorial(n), do: factorial(n, 1)

  defp factorial(0, acumulado), do: acumulado
  defp factorial(n, acumulado), do: factorial(n - 1, n * acumulado)
end
```

Observe que se ha utilizado un parámetro `acumulado` para mantener los cálculos intermedios, luego, en el caso base, simplemente devolvemos el valor acumulado. No hay operaciones pendientes después de la llamada recursiva, lo que permite la **optimización de cola**.

**Prueba de escritorio:**

Se quiere calcular `factorial(5)`. El paso a paso sería el siguiente:

1. `factorial(5)` = `factorial(5, 1)`
2. `factorial(5, 1)` = `factorial(4, 5)`
3. `factorial(4, 5)` = `factorial(3, 20)`
4. `factorial(3, 20)` = `factorial(2, 60)`
5. `factorial(2, 60)` = `factorial(1, 120)`
6. `factorial(1, 120)` = `factorial(0, 120)`
7. `factorial(0, 120)` = 120

Por lo tanto, `factorial(5)` = 120. Al llegar al caso base ya se tiene el resultado final.

Lo interesante de la recursividad de cola es que **no se acumulan llamadas en la pila**, ya que cada llamada puede reutilizar el espacio de la llamada anterior. Esto hace que la recursividad de cola sea más eficiente en términos de uso de memoria.

### Fibonacci

El algoritmo de Fibonacci que ya vimos tiene un problema, es muy ineficiente para valores grandes de `n`. Sin embargo, se puede implementar utilizando recursividad de cola de la siguiente manera:

```elixir
defmodule Matematicas do
  def fibonacci(n), do: fibonacci(n, 0, 1) # Se inician los dos primeros números de la secuencia

  defp fibonacci(0, a, _b), do: a # Caso base: si n es 0, se devuelve el primer número
  defp fibonacci(n, a, b), do: fibonacci(n - 1, b, a + b) # Se avanza en la secuencia, actualizando los dos últimos números
end
```

**Prueba de escritorio:**

Se quiere calcular `fibonacci(5)`. El paso a paso sería el siguiente:

1. `fibonacci(5)` = `fibonacci(5, 0, 1)`
2. `fibonacci(5, 0, 1)` = `fibonacci(4, 1, 1)`
3. `fibonacci(4, 1, 1)` = `fibonacci(3, 1, 2)`
4. `fibonacci(3, 1, 2)` = `fibonacci(2, 2, 3)`
5. `fibonacci(2, 2, 3)` = `fibonacci(1, 3, 5)`
6. `fibonacci(1, 3, 5)` = `fibonacci(0, 5, 8)`
7. `fibonacci(0, 5, 8)` = 5

Por lo tanto, `fibonacci(5)` = 5. En esta implementación no se recalculan valores intermedios, por lo que es más eficiente.

### Listas

Un ejemplo de recursividad de cola es la función que suma los elementos de una lista acumulando el resultado en un parámetro adicional:

```elixir
defmodule Listas do
  def sumar(lista), do: sumar(lista, 0)

  defp sumar([], acumulado), do: acumulado
  defp sumar([head | tail], acumulado), do: sumar(tail, head + acumulado)
end
```

**Prueba de escritorio:**

Se quiere calcular `Listas.sumar([1, 2, 3])`. El paso a paso sería el siguiente:

1. `Listas.sumar([1, 2, 3])` = `Listas.sumar([1, 2, 3], 0)`
2. `Listas.sumar([1, 2, 3], 0)` = `Listas.sumar([2, 3], 1)`
3. `Listas.sumar([2, 3], 1)` = `Listas.sumar([3], 3)`
4. `Listas.sumar([3], 3)` = `Listas.sumar([], 6)`
5. `Listas.sumar([], 6)` = 6

Por lo tanto, `Listas.sumar([1, 2, 3])` = 6.

---

## Ejercicios prácticos

Escriba un método recursivo en elixir para cada uno de los siguientes casos:

1. Aplique recursividad de cola para los ejercicios de la potencia, mutiplicación y el de invertir una cadena. 
2. División entera entre dos números mediante restas sucesivas. Devuelva una tupla, `{cociente, residuo}` o `{:error, "División por cero"}`.
3. Sumar todos los números primos de una lista. Debe programar una función auxiliar que determine si un número es primo o no recursivamente.
4. Contar cuántas veces está un elemento dentro de una lista.
5. Determinar si una cadena de caracteres es palíndroma o no.
6. Contar el número de vocales en una cadena de caracteres.
7. Indicar si un número es perfecto. Un número es perfecto si es igual a la suma de sus divisores propios (excluyendo el mismo número). Por ejemplo, 6 es perfecto porque sus divisores propios son 1, 2 y 3, y 1 + 2 + 3 = 6.
8. Retornar en una cadena los números ubicados en las posiciones pares de una lista. Por ejemplo, para la lista `[1, 2, 3, 4, 5]`, la función debería retornar `"135"`. 
9. Contar el número de dígitos de un número. Se asume que el número es positivo. No puede convertir el número a `string`.
10. Implemente una función que le pida al usuario una contraseña y verifique si una contraseña cumple con los siguientes criterios, si no los cumple, debe indicarle al usuario qué criterio no se cumple y pedirle que ingrese una nueva contraseña hasta que se ingrese una contraseña segura y retorne `:ok`. Criterios:
    - Tiene al menos 6 caracteres.
    - Contiene al menos una letra mayúscula.
    - Contiene al menos un dígito.
    - Contiene al menos uno de estos caracteres especiales: `!@#$%&`.
    
---

## Consideraciones finales

La recursividad es una técnica poderosa, pero debe usarse con cuidado. Asegúrese de siempre definir un caso base y considera el uso de la recursión de cola (tail recursion) para evitar desbordamientos de pila en casos de recursión profunda.

## Recursividad en la naturaleza

La recursividad no es un concepto exclusivo de la programación; de hecho, es un patrón ampliamente presente en la naturaleza. Un claro ejemplo son los **árboles**, donde el tronco se divide en ramas, estas en ramas más pequeñas y, finalmente, en hojas, manteniendo siempre una estructura semejante en cada nivel. De forma parecida, los **ríos** se ramifican en afluentes que a su vez se subdividen, y los **pulmones** se organizan en bronquios y bronquiolos que replican la misma forma en escalas progresivamente menores.

Este fenómeno se conoce como **autosimilaridad**, es decir, la repetición de un mismo patrón en diferentes escalas. Gracias a ella, la naturaleza logra construir estructuras complejas a partir de reglas simples, generando eficiencia y equilibrio en los sistemas vivos.

Un paralelo interesante aparece en las **matemáticas** y en los **fractales**, donde una misma figura se repite infinitamente al aumentar o reducir la escala, mostrando un orden escondido dentro de lo que a primera vista parece caótico.

La recursividad, por tanto, no solo es una técnica de programación, sino también un principio universal que conecta el mundo natural, la matemática y la informática bajo una misma idea: **resolver lo complejo repitiendo lo simple**.

---

## Para la próxima clase

- Investigar por qué la recursividad de cola es más eficiente en términos de uso de memoria que la recursividad normal.
- Por qué los lenguajes funcionales tienden a utilizar la recursión en lugar de bucles.
- Qué problemas pueden surgir al utilizar la recursión en lugar de bucles.
