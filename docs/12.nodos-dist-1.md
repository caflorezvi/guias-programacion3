<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script> 
<script> 
  document.addEventListener("DOMContentLoaded", function() { mermaid.initialize({ startOnLoad: true }); }); 
</script>

```
Universidad del Quind칤o
Programa de Ingenier칤a de Sistemas y Computaci칩n
Programaci칩n III - Aplicaciones Distribuidas y Concurrentes
Docente: Carlos Andr칠s Florez V.
```

# Aplicaciones distribuidas (Parte 1)

En los ejemplos vistos en las clases anteriores, **todos los procesos se ejecutaban en un mismo nodo** dentro de la m치quina virtual BEAM. Sin embargo, Elixir tambi칠n permite crear **aplicaciones distribuidas**, donde los procesos pueden ejecutarse en **nodos diferentes**, ya sea dentro de una misma m치quina o en equipos distintos conectados por red.

Esta capacidad de distribuci칩n se logra mediante el m칩dulo `Node`, que proporciona las herramientas necesarias para **gestionar y comunicar nodos** dentro del entorno distribuido de Elixir.

## Requisitos previos para la comunicaci칩n distribuida

Antes de trabajar con aplicaciones distribuidas en Elixir, es importante entender tres conceptos fundamentales que hacen posible la comunicaci칩n entre nodos:

### 1. El demonio EPMD (Erlang Port Mapper Daemon)

**EPMD** es un servicio que act칰a como un directorio de nodos en la m치quina virtual BEAM. Su funci칩n principal es:

- **Registrar nodos**: Cuando se inicia un nodo distribuido, este se registra autom치ticamente en `epmd`.
- **Resolver nombres**: Permite que los nodos se encuentren entre s칤, mapeando nombres de nodos a puertos de red.
- **Facilitar conexiones**: Act칰a como intermediario para establecer la comunicaci칩n inicial entre nodos.

**Verificar si EPMD est치 corriendo:**

```bash
epmd -names
```

Si no est치 corriendo, ver치 un mensaje de error. Puede iniciarlo manualmente con:

```bash
epmd -daemon
```

Sin embargo, en la mayor칤a de los casos, **EPMD se inicia autom치ticamente** cuando se ejecuta el primer nodo distribuido. Es importante verificar que est칠 activo antes de comenzar a trabajar con aplicaciones distribuidas.

### 2. Cookies de autenticaci칩n

Las **cookies** son un mecanismo de seguridad simple que asegura que solo los nodos autorizados puedan comunicarse entre s칤. Funcionan como una contrase침a compartida:

- **Todos los nodos que deseen comunicarse deben tener la misma cookie**.
- Si las cookies no coinciden, la conexi칩n ser치 rechazada.
- Se establecen mediante `Node.set_cookie/1` o con la bandera `--cookie` al iniciar `iex`.

>**丘멆잺 Importante:** Las cookies NO son un mecanismo de seguridad robusto. En entornos de producci칩n, se deben implementar medidas adicionales como firewalls, VPNs o TLS.

### 3. Requisitos de red

Para que dos nodos se comuniquen, deben cumplirse las siguientes condiciones de red:

- **Conectividad de red**: Los nodos deben poder alcanzarse mutuamente a trav칠s de la red.
- **Puertos abiertos**: 
  - EPMD escucha en el puerto **4369** por defecto.
  - Cada nodo usa un puerto din치mico adicional para la comunicaci칩n directa.
- **Resoluci칩n de nombres**: Los nodos deben poder resolver los nombres de host de los dem치s (usando DNS, `/etc/hosts`, o direcciones IP directamente).
- **Firewall**: Aseg칰rese de que el firewall no est칠 bloqueando los puertos necesarios.

**Para nodos en la misma m치quina:** Estos requisitos se cumplen autom치ticamente usando `localhost`.

**Para nodos en m치quinas diferentes:** Debe verificar la conectividad con herramientas como `ping` y asegurarse de que los puertos est칠n abiertos.

---

## M칩dulo Node

El m칩dulo `Node` ofrece funciones para trabajar con **nodos distribuidos** y facilitar la comunicaci칩n entre ellos. Algunas de las m치s utilizadas son:

- `Node.start/1` o `Node.start/2`: inicia un nodo con un nombre espec칤fico.
- `Node.connect/1`: establece una conexi칩n con otro nodo en la red.
- `Node.list/0`: devuelve la lista de nodos actualmente conectados.
- `Node.self/0`: obtiene el nombre del nodo actual.
- `Node.set_cookie/1`: establece la cookie de autenticaci칩n para la comunicaci칩n entre nodos.
- `Node.spawn_link/2`: permite crear un proceso en un nodo remoto y enlazarlo con el proceso local.

> **游눠 Nota:** Aunque m치s adelante veremos ejemplos pr치cticos, es recomendable consultar la documentaci칩n oficial para explorar todas las funciones disponibles en el m칩dulo `Node`.

Gracias a estas funciones, es posible construir **sistemas distribuidos** en Elixir donde los procesos se comunican y colaboran de forma transparente, sin importar si se encuentran en el mismo equipo o en distintos dispositivos conectados a la red.

### Nombres de nodos

Cada nodo debe tener un nombre que lo identifica de forma 칰nica en el cl칰ster, y este nombre puede ser **corto** o **completo** (tambi칠n llamados *shortnames* y *longnames*).

#### Nombres cortos (shortnames)

Se utilizan cuando los nodos se ejecutan **en la misma m치quina**. Son m치s simples y c칩modos para entornos locales o de desarrollo.

**Formato:** `:nombre_nodo` o `:nombre_nodo@localhost`

**Ejemplos:**
```elixir
# Impl칤cito: se asume el hostname de la m치quina
Node.start(:nodo1, :shortnames)
# Resultado: :nodo1@nombre_de_tu_maquina

# Expl칤cito con localhost
Node.start(:nodo1@localhost, :shortnames)
# Resultado: :nodo1@localhost
```

**Al iniciar con iex:**
```bash
iex --sname nodo1
# Esto crea autom치ticamente :nodo1@nombre_de_tu_maquina
```

#### Nombres completos (longnames)

Se utilizan cuando los nodos se ejecutan **en m치quinas diferentes** conectadas por red. La parte despu칠s del `@` corresponde al **nombre del host** o la **direcci칩n IP** de cada m치quina.

**Formato:** `:nombre_nodo@hostname` o `:nombre_nodo@direccion_ip`

**Ejemplos:**
```elixir
# Con nombre de host
Node.start(:servidor@miservidor.local, :longnames)

# Con direcci칩n IP
Node.start(:"servidor@192.168.1.100", :longnames)
# Nota: Se usa :"..." cuando hay caracteres especiales como puntos
```

**Al iniciar con iex:**
```bash
# Con nombre de host
iex --name servidor@miservidor.local

# Con direcci칩n IP
iex --name servidor@192.168.1.100
```

**Regla importante:** No se pueden conectar nodos con shortnames a nodos con longnames. Todos los nodos del cl칰ster deben usar el mismo tipo de nombre.

---

## Comunicaci칩n entre nodos con `send/2` y `receive`

Vamos a crear dos nodos en la misma m치quina y establecer una conexi칩n entre ambos. La idea es tener un nodo que env칤a un mensaje y otro que lo recibe. La diferencia respecto a los ejemplos anteriores es que ahora los procesos se pueden ejecutar de manera distribuida.

### Topolog칤a de Nodos

A nivel alto, la comunicaci칩n entre los dos nodos se puede representar de la siguiente manera:

<div class="mermaid" style="text-align: center;">
flowchart LR
    subgraph N1 [Nodo 1]
        P1[Proceso Cliente]
    end
    subgraph N2 [Nodo 2]
        P2[Proceso Servidor :proceso_en_nodo2]
        M2[(Mailbox)]
    end
    P1 -- "send({:proceso_en_nodo2, :nodo2@localhost}, msg)" --> P2
    P2 -.-> M2
    style N1 fill:#fff3e0,stroke:#f57c00
    style N2 fill:#e8f5e9,stroke:#2e7d32
</div>

El `Proceso Cliente` en `Nodo 1` env칤a un mensaje al proceso registrado `:proceso_en_nodo2` en `Nodo 2`. El proceso receptor recibe el mensaje en su *mailbox* y lo procesa.

Este es un ejemplo t칤pico de comunicaci칩n distribuida en Elixir, en donde se tiene un Servidor que escucha mensajes y un Cliente que los env칤a.

### Versi칩n 1 (iex)

En esta versi칩n, abrimos iex en dos terminales independientes y escribimos los comandos directamente en cada una. **No es lo m치s pr치ctico**, pero es 칰til para entender c칩mo funciona la comunicaci칩n entre nodos.

#### 1. Iniciar el nodo receptor

En una terminal, ejecutamos:

```bash
iex --sname nodo2 --cookie mi_cookie 
```

La bandera `--sname` permite asignar un nombre corto al nodo (*shortname*), que es 칰til para nodos en la misma m치quina. Si los nodos est치n en diferentes m치quinas, se puede usar `--name` para asignar un nombre completo con el formato `nombre@host`. 

La cookie es opcional, pero como se mencion칩 anteriormente, es recomendable establecerla para asegurar que solo los nodos con la misma cookie puedan comunicarse.

#### 2. Creaci칩n del proceso que recibe mensajes

En la terminal donde est치 `nodo2`, ejecutamos el siguiente c칩digo para recibir el mensaje:

```elixir
# Se crea un proceso con un nombre propio en este nodo
Process.register(self(), :proceso_en_nodo2)

IO.puts("Nodo iniciado correctamente: #{Node.self()}")
IO.puts("Esperando mensajes...")

# Esperar y recibir mensajes
receive do
  {:mensaje, msg} -> IO.puts("Recibido en nodo 2: #{msg}")
end
```

El `nodo2` ser치 un receptor de mensajes. El proceso creado se registra con el nombre `:proceso_en_nodo2` para que pueda ser referenciado desde otros nodos.

#### 3. Iniciar el nodo emisor

En otra terminal diferente, ejecutamos:

```bash
iex --sname nodo1 --cookie mi_cookie
```

Es importante que los nombres de los nodos sean 칰nicos en la red para evitar conflictos.

#### 4. Enviar un mensaje desde otro nodo

En la nueva terminal (`nodo1`) ejecutamos el siguiente c칩digo para conectarnos a `nodo2` y enviarle un mensaje:

```elixir
# Primero, conectarse al nodo2
Node.connect(:nodo2@tu_maquina) # Reemplaza 'tu_maquina' con el nombre de tu m치quina

# Enviar el mensaje al proceso registrado en nodo2
send({:proceso_en_nodo2, :nodo2@tu_maquina}, {:mensaje, "Hola desde nodo 1"})
``` 

La comunicaci칩n entre nodos se establece usando el nombre completo del nodo receptor. Siguiendo el formato `nombre@host`, donde `host` es el nombre de la m치quina donde se est치 ejecutando el nodo receptor.

**Para saber el nombre de `tu_maquina`:** F칤jese en la consola del `nodo2`, donde dice: `Nodo iniciado correctamente: nodo2@tu_maquina`.

> 丘멆잺 **Importante:** En este caso, la funci칩n `send/2` tiene un formato especial para referenciar procesos en nodos remotos: se usa una tupla con el nombre del proceso y el nombre del nodo: `{nombre_proceso, nombre_nodo}`.

#### 5. Verificar la comunicaci칩n

En la terminal de `nodo2`, deber칤a ver el mensaje recibido:

```
Recibido en nodo 2: Hola desde nodo 1
```

El `nodo2` solo recibe un mensaje y luego termina. Si desea enviar m치s mensajes, debe ejecutar nuevamente el bloque `receive` o crear un bucle para mantener el proceso activo.

Tenga en cuenta que, para que esto funcione, **ambos nodos deben estar en la misma red** y ser capaces de comunicarse entre s칤. No necesariamente deben estar en la misma m치quina, pero s칤 deben poder resolver los nombres de los nodos entre s칤.

### Versi칩n 2 (scripts)

En lugar de escribir los comandos directamente en la consola, podemos crear archivos `.exs` para cada nodo y ejecutarlos. Adem치s, se mejora la recepci칩n de mensajes para que el nodo receptor pueda seguir escuchando indefinidamente.

#### 1. C칩digo para nodo1 (`nodo1.exs`)

Cree un archivo llamado `nodo1.exs` con el siguiente contenido:

```elixir
defmodule Cliente do
  def main do
    # Inicia el nodo en modo distribuido con un nombre corto
    {:ok, _} = Node.start(:nodo1@localhost, :shortnames)

    # Establece la cookie (debe coincidir con la del nodo2)
    Node.set_cookie(:mi_cookie)

    # Intentar conectarse al nodo2
    case Node.connect(:nodo2@localhost) do
      true ->
        IO.puts("Conectado a nodo2@localhost correctamente")
        # Enviar mensaje al proceso remoto
        send({:proceso_en_nodo2, :nodo2@localhost}, {:mensaje, "Hola desde nodo1"})
        IO.puts("Mensaje enviado a nodo2")

      false ->
        IO.puts("No se pudo conectar al nodo remoto")
    end
  end
end

Cliente.main()
``` 

Se organiza el c칩digo dentro de un m칩dulo `Cliente` con una funci칩n `main` para mayor claridad. No es obligatorio, pero es una buena pr치ctica.

#### 2. C칩digo para nodo2 (`nodo2.exs`)

Cree un archivo llamado `nodo2.exs` con el siguiente contenido:

```elixir
defmodule Servidor do
  def main do
    # Inicia el nodo en modo distribuido con un nombre corto
    {:ok, _} = Node.start(:nodo2@localhost, :shortnames)

    # Establece la cookie para la autenticaci칩n entre nodos
    Node.set_cookie(:mi_cookie)

    # Registrar el proceso con un nombre en este nodo
    Process.register(self(), :proceso_en_nodo2)

    IO.puts("Nodo iniciado correctamente: #{Node.self()}")
    IO.puts("Esperando mensajes...")

    # Bloquea el proceso principal
    loop()

    # Nunca se llega aqu칤 debido al loop infinito
    IO.puts("Nodo finalizado")
  end

  # Funci칩n recursiva para recibir mensajes indefinidamente
  defp loop do
    receive do
      {:mensaje, msg} ->
        IO.puts("Recibido en nodo 2: #{msg}")
        loop()
    end
  end
end

Servidor.main()
```

Se define un m칩dulo `Servidor` con una funci칩n `main` que inicia el nodo y crea un proceso que escucha mensajes de forma indefinida utilizando una funci칩n recursiva `loop`.

#### 3. Ejecutar los nodos

**Primero**, aseg칰rese de que `epmd` est칠 corriendo:

```bash
epmd -names
```

Si no est치 activo, in칤cielo con:

```bash
epmd -daemon
```

**Luego**, en terminales independientes, ejecute:

```bash
# Terminal 1
elixir nodo2.exs
```

```bash
# Terminal 2
elixir nodo1.exs
```

#### 4. Verificar la comunicaci칩n

En la terminal donde se ejecuta `nodo2.exs`, deber칤a ver el mensaje recibido:

```
Nodo iniciado correctamente: nodo2@localhost
Esperando mensajes...
Recibido en nodo 2: Hola desde nodo1
```

Y dicho nodo permanecer치 activo, esperando m치s mensajes de manera indefinida.

#### 5. Mejoras opcionales

- Use constantes a nivel de m칩dulo para definir el nombre del nodo y la cookie, evitando repetirlos en varias partes del c칩digo.
- Agregue manejo de errores para las conexiones fallidas.
- Implemente un mecanismo de *shutdown* con mensajes especiales como `:shutdown`. El mecanimo shutdown se puede implementar enviando un mensaje especial al proceso receptor que haga que este salga del loop y termine.

---

## Problemas comunes y soluciones

A continuaci칩n, se presentan los problemas m치s comunes al trabajar con aplicaciones distribuidas en Elixir y c칩mo resolverlos:

### 1. Cookies que no coinciden

**S칤ntoma:** Los nodos no pueden conectarse entre s칤, aunque est치n en la misma red.
**Causa:** Las cookies de autenticaci칩n no coinciden entre los nodos.

**Soluci칩n:**
```elixir
# Verificar la cookie actual
Node.get_cookie()

# Establecer la misma cookie en todos los nodos
Node.set_cookie(:mi_cookie_secreta)
```

**Al usar iex:**
```bash
iex --sname nodo1 --cookie mi_cookie
```

### 2. Nombres de nodos duplicados

**S칤ntoma:** Error al iniciar un nodo: `{:error, {:already_started, :...}}`
**Causa:** Ya existe un nodo con el mismo nombre en la m치quina.

**Soluci칩n:**
- Cierre el nodo existente antes de iniciar uno nuevo con el mismo nombre.
- Use nombres 칰nicos para cada nodo.
- Verifique los nodos activos con: `epmd -names`

### 3. EPMD no est치 corriendo

**S칤ntoma:** Error: `Protocol 'inet_tcp': register/listen error: econnrefused`
**Causa:** El demonio EPMD no est치 activo.

**Soluci칩n:**
```bash
# Verificar si est치 corriendo
epmd -names

# Iniciarlo manualmente
epmd -daemon

# Verificar que est칠 activo
epmd -names
```

### 4. Problemas de firewall

**S칤ntoma:** Los nodos no pueden conectarse entre m치quinas diferentes, pero s칤 funcionan en localhost.
**Causa:** El firewall est치 bloqueando los puertos necesarios.

**Soluci칩n:**
- Abra el puerto **4369** (EPMD) en el firewall.
- Abra un rango de puertos din치micos para la comunicaci칩n entre nodos (por ejemplo, 9000-9100).
- En Linux (usando `ufw`):
  ```bash
  sudo ufw allow 4369/tcp
  sudo ufw allow 9000:9100/tcp
  ```

### 5. No se puede resolver el nombre del host

**S칤ntoma:** `Node.connect/1` devuelve `false` o error de resoluci칩n de nombres.
**Causa:** El sistema no puede resolver el nombre del host al que intenta conectarse.

**Soluci칩n:**
- Use direcciones IP en lugar de nombres de host:
  ```elixir
  Node.connect(:"nodo@192.168.1.100")
  ```
- O agregue el nombre del host a `/etc/hosts` (Linux/Mac) o `C:\Windows\System32\drivers\etc\hosts` (Windows):
  ```
  192.168.1.100  servidor
  ```

### 6. Mezcla de shortnames y longnames

**S칤ntoma:** Los nodos no pueden conectarse aunque todo parece estar bien configurado.
**Causa:** Un nodo usa shortnames y otro usa longnames.

**Soluci칩n:**
- Todos los nodos deben usar el mismo tipo de nombre.
- Para nodos en la misma m치quina: use `--sname` (shortnames).
- Para nodos en diferentes m치quinas: use `--name` (longnames).

### 7. Proceso no registrado

**S칤ntoma:** Error al enviar mensajes: el proceso receptor no existe.
**Causa:** El proceso no se registr칩 correctamente o ya finaliz칩.

**Soluci칩n:**
```elixir
# Verificar si el proceso est치 registrado localmente
Process.whereis(:nombre_proceso)
```

### 8. Timeout en comunicaci칩n remota

**S칤ntoma:** El cliente no recibe respuesta del servidor.
**Causa:** El servidor est치 ocupado, no est치 escuchando, o la red es lenta.

**Soluci칩n:**
- Aumente el timeout en el bloque `receive`:
  ```elixir
  receive do
    {:respuesta, msg} -> IO.puts(msg)
  after
    10_000 -> IO.puts("Timeout: no se recibi칩 respuesta")
  end
  ```
- Verifique que el servidor est칠 activo y escuchando mensajes.

### 9. Verificaci칩n r치pida de conectividad

**Comandos 칰tiles para diagnosticar problemas:**

```elixir
# Ver el nombre del nodo actual
Node.self()

# Ver nodos conectados
Node.list()

# Ver todos los nodos (incluyendo el actual)
[Node.self() | Node.list()]

# Ping a un nodo remoto
Node.ping(:nodo@host)
# Devuelve :pong si est치 conectado, :pang si no

# Ver procesos registrados localmente
Process.registered()
```

---

## Ejercicio 1

Cree una aplicaci칩n distribuida en Elixir que permita a un nodo cliente enviar una lista de n칰meros a un nodo servidor. El nodo servidor debe recibir la lista y realizar las siguientes operaciones:
- Calcular la suma de los n칰meros en la lista.
- Calcular el promedio de los n칰meros en la lista.
- Filtrar los n칰meros pares de la lista.
- Simular una tarea costosa que tome 50 segundos en completarse (por ejemplo, usando `:timer.sleep/1`).

En el cliente, los n칰meros se le piden al usuario a trav칠s de la consola. El cliente env칤a la lista al servidor y espera la respuesta para cada operaci칩n.

### 1. Crear el servidor

Cree un archivo llamado `servidor.exs` con el siguiente contenido:

```elixir
defmodule Servidor do
  # Inicia el nodo servidor y espera peticiones
  def main do
    Node.start(:servidor@localhost, :shortnames)
    Node.set_cookie(:cookie)
    Process.register(self(), :principal) # Registrar el proceso principal con un nombre

    IO.puts("Servidor iniciado en #{node()}")
    IO.puts("Esperando conexiones...\n")

    loop() # Iniciar el bucle de recepci칩n de mensajes
  end

  def loop do
    # Se reciben los diferentes tipos de mensajes posibles y se responde adecuadamente
    # Los mensajes deben coincidir con los enviados por el cliente
    receive do
      {:sumar_numeros, pid, lista} ->
        IO.puts("[#{timestamp()}] Petici칩n: sumar_numeros")
        resultado = sumar_numeros(lista)
        send(pid, {:resultado_suma, resultado})

      {:calcular_promedio, pid, lista} ->
        IO.puts("[#{timestamp()}] Petici칩n: calcular_promedio")
        resultado = calcular_promedio(lista)
        send(pid, {:resultado_promedio, resultado})

      {:filtrar_pares, pid, lista} ->
        IO.puts("[#{timestamp()}] Petici칩n: filtrar_pares")
        resultado = filtrar_pares(lista)
        send(pid, {:lista_filtrada, resultado})

      {:tarea_costosa, pid} ->
        IO.puts("[#{timestamp()}] Petici칩n: tarea_costosa (50s)")

        # Se crea un proceso separado para no bloquear el proceso principal del servidor
        spawn(fn ->
            hacer_tarea_costosa()
            send(pid, :tarea_completada)
            IO.puts("[#{timestamp()}] Tarea costosa completada")
        end)

      mensaje ->
        IO.puts("[#{timestamp()}] Mensaje desconocido: #{inspect(mensaje)}")
    end

    loop()
  end

  # Funciones auxiliares para las operaciones solicitadas

  defp filtrar_pares(lista), do: Enum.filter(lista, fn el -> rem(el, 2) == 0 end)
  defp sumar_numeros(lista), do: Enum.sum(lista)
  defp calcular_promedio([]), do: :error
  defp calcular_promedio(lista), do: Enum.sum(lista) / length(lista)
  defp hacer_tarea_costosa(), do: :timer.sleep(50000)

  # Obtener la hora actual en formato legible
  defp timestamp do
    Time.utc_now() |> Time.to_string() |> String.slice(0..7)
  end
end

Servidor.main()
```

Revise detalladamente el c칩digo para entender c칩mo se manejan las peticiones y respuestas entre el cliente y el servidor. Recuerde que el bloque `receive` bloquea el proceso hasta que llega un mensaje, por lo que es importante manejar cada tipo de mensaje adecuadamente, y en el caso de la tarea costosa, crear un proceso separado para no bloquear el servidor.

### 2. Crear el cliente

Cree un archivo llamado `cliente.exs` con el siguiente contenido:

```elixir
defmodule Cliente do
  # Se definen constantes para el nombre del servidor, proceso y timeout
  @nombre_servidor :servidor@localhost
  @nombre_proceso :principal
  @timeout 10000

  # Funci칩n principal del cliente 
  def main do
    Node.start(crear_nombre_nodo() |> String.to_atom(), :shortnames)
    Node.set_cookie(:cookie)

    IO.puts("Cliente iniciado en #{node()}")
    IO.puts("Intentando conectar al servidor...")

    # Intentar conectar al servidor
    conectar_servidor(Node.connect(@nombre_servidor))

    IO.puts("Conexi칩n finalizada")
  end

  # Crear un nombre 칰nico para el nodo del cliente (ya que puede haber m칰ltiples clientes)
  def crear_nombre_nodo do
    uuid = :crypto.strong_rand_bytes(8) |> Base.encode16(case: :lower)
    "cliente_#{uuid}@localhost"
  end

  # Si la conexi칩n es exitosa, pedir n칰meros y enviar petici칩n
  def conectar_servidor(true) do
    IO.puts("Conexi칩n exitosa")
    pedir_numeros() |> enviar_peticion()
    esperar_respuesta()
  end

  # Si la conexi칩n falla, mostrar mensaje de error
  def conectar_servidor(false), do: IO.puts("No se pudo conectar al servidor")

  # Mostrar men칰 y pedir n칰meros al usuario
  def pedir_numeros do
    IO.puts("\nBienvenido cliente")
    IO.puts("Opciones disponibles:")
    IO.puts("1 - Sumar los n칰meros")
    IO.puts("2 - Calcular el promedio")
    IO.puts("3 - Filtrar n칰meros pares")
    IO.puts("4 - Ejecutar tarea costosa\n")

    opcion = IO.gets("Seleccione una opci칩n (1-4): ") |> String.trim()
    {opcion, crear_lista([])}
  end

  # Manejo de las diferentes peticiones seg칰n la opci칩n seleccionada por el usuario

  def enviar_peticion({"1", lista}) do
    # Dado que el servidor est치 en otro nodo, se usa una tupla con el nombre del proceso y el nombre del nodo
    send({@nombre_proceso, @nombre_servidor}, {:sumar_numeros, self(), lista})
  end

  def enviar_peticion({"2", lista}) do
    send({@nombre_proceso, @nombre_servidor}, {:calcular_promedio, self(), lista})
  end

  def enviar_peticion({"3", lista}) do
    send({@nombre_proceso, @nombre_servidor}, {:filtrar_pares, self(), lista})
  end

  def enviar_peticion({"4", _lista}) do
    send({@nombre_proceso, @nombre_servidor}, {:tarea_costosa, self()})
  end

  def enviar_peticion({opcion, _lista}) do
    IO.puts("Opci칩n inv치lida: #{opcion}")
  end

  # Bloque que espera la respuesta del servidor seg칰n la petici칩n realizada
  def esperar_respuesta do
    receive do
      {:resultado_suma, suma} ->
        IO.puts("\nResultado recibido:")
        IO.puts("  Suma: #{suma}")

      {:resultado_promedio, :error} ->
        IO.puts("\nError: No se puede procesar una lista vac칤a")

      {:lista_filtrada, lista} ->
        IO.puts("\nN칰meros pares filtrados:")
        IO.inspect(lista)

      :tarea_completada ->
        IO.puts("\nLa tarea costosa termin칩 exitosamente")

    # Manejo de timeout en caso de que el servidor no responda a tiempo
    after 
      @timeout ->
        IO.puts("\nTimeout: El servidor no respondi칩 en #{@timeout}ms")
    end
  end

  # Funci칩n recursiva para crear la lista de n칰meros ingresados por el usuario
  def crear_lista(lista) do
    valor = IO.gets("Ingrese un n칰mero (o 'fin' para terminar): ") |> String.trim()

    case valor do
      "fin" ->
        Enum.reverse(lista)
      _ ->
        case Integer.parse(valor) do
          {num, _} ->
            crear_lista([num | lista])
          :error ->
            IO.puts("Error: Solo se aceptan n칰meros enteros")
            crear_lista(lista)
        end
    end
  end
end

Cliente.main()
```

Lea detenidamente el c칩digo para entender c칩mo se manejan las peticiones y respuestas entre el cliente y el servidor. Note que el cliente crea un nombre 칰nico para su nodo, ya que puede haber m칰ltiples clientes conect치ndose al mismo servidor.

### 3. Ejecutar y probar la aplicaci칩n

Primero, aseg칰rese de que `epmd` est칠 corriendo:

```bash
epmd -names
```

Si no est치 activo, in칤cielo con:

```bash
epmd -daemon
```

Luego, en una terminal, ejecute el servidor:

```bash
elixir servidor.exs
```

En otras dos terminales independientes, ejecute dos clientes diferentes:

```bash
elixir cliente.exs
```

Siga las instrucciones en la consola del cliente para ingresar n칰meros y seleccionar las operaciones a realizar. Verifique que el servidor procese las solicitudes correctamente y que el cliente reciba las respuestas esperadas.

Env칤e diferentes tipos de mensajes desde cada cliente y observe c칩mo el servidor maneja las peticiones concurrentemente.

### 4. Ejecuci칩n en m치quinas diferentes

Para ejecutar los nodos en m치quinas diferentes, primero necesita conocer las direcciones IP de cada m치quina:

**En Linux/macOS:**
```bash
ifconfig
# Busque su direcci칩n IP en la secci칩n de su interfaz de red activa
```

**En Windows:**
```bash
ipconfig
# Busque "Direcci칩n IPv4" en la secci칩n de su adaptador de red activo
```

**Modificar los archivos:**

Supongamos que:
- La IP del servidor es `192.168.1.20`
- La IP del cliente es `192.168.1.21`

**En `servidor.exs`**, cambie:
```elixir
# De:
Node.start(:servidor@localhost, :shortnames)

# A:
Node.start( :"servidor@192.168.1.20", :longnames)
```

**En `cliente.exs`**, cambie:
```elixir
# Constante del servidor
@nombre_servidor :"servidor@192.168.1.20"

# Y en crear_nombre_nodo():
def crear_nombre_nodo do
  uuid = :crypto.strong_rand_bytes(8) |> Base.encode16(case: :lower)
  "cliente_#{uuid}@192.168.1.21"  # Use la IP del cliente
end

# Y al iniciar el nodo:
Node.start(crear_nombre_nodo() |> String.to_atom(), :longnames)
```

> **丘멆잺 Importante:** Aseg칰rese de que:
>  - Ambas m치quinas est칠n en la misma red.
>  - El firewall permita las conexiones en el puerto 4369 (EPMD) y los puertos din치micos.
>  - Las cookies coincidan en ambos nodos.

Esta es una forma pr치ctica de entender c칩mo funcionan las aplicaciones distribuidas en Elixir.

---

## Ejercicio 2

Se desea desarrollar una aplicaci칩n distribuida en Elixir que permita la comunicaci칩n entre m칰ltiples nodos clientes y un **nodo servidor central**. Los clientes podr치n conectarse simult치neamente al servidor y enviarle mensajes con el siguiente formato:

* `{:mayusculas, msg}`: Convierte el mensaje a may칰sculas y lo devuelve.
* `{:minusculas, msg}`: Convierte el mensaje a min칰sculas y lo devuelve.
* `{:palindroma, msg}`: Verifica si el mensaje es un pal칤ndromo y devuelve `true` o `false`.
* `{:contar_vocales, msg}`: Cuenta el n칰mero de vocales en el mensaje y lo devuelve.
* `{:guardar, msg}`: Guarda el mensaje en un archivo de texto en el servidor.
* `{:consultar}`: Devuelve la lista de mensajes guardados en el archivo.

El nodo servidor debe procesar m칰ltiples solicitudes de forma concurrente y responder a cada cliente de manera independiente. Los nodos clientes, por su parte, deben poder enviar mensajes y recibir respuestas de forma as칤ncrona.

Adem치s, hay un mensaje especial que finaliza la comunicaci칩n: `:fin`. Cuando el nodo servidor recibe este mensaje, le responde al nodo cliente con `:adios` y termina la comunicaci칩n con ese cliente.

Pruebe la aplicaci칩n creando al menos dos nodos clientes (si puede en m치quinas diferentes) que env칤en diferentes tipos de mensajes al nodo servidor y muestren las respuestas recibidas.

---

## Para la pr칩xima clase

Leer sobre `:rpc` y `:global` en la documentaci칩n oficial de Elixir y qu칠 facilitan en aplicaciones distribuidas respecto al m칩dulo `Node` con `send` y `receive` que estudiamos en esta clase.