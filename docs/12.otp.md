```
Universidad del Quindío
Programa de Ingeniería de Sistemas y Computación
Programación III - OTP (Open Telecom Platform)
Docente: Carlos Andrés Florez V.
```

# Introducción a OTP

Antes de entrar en detalles sobre OTP, es importante entender el concepto de **Agentes** en Elixir, ya que son una forma sencilla de manejar el estado compartido y mutable en aplicaciones concurrentes.

# Agent

El módulo `Agent` en Elixir proporciona una forma sencilla de crear y manejar procesos que mantienen un estado compartido. Los agentes son útiles cuando se necesita un proceso que almacene y gestione un estado mutable de manera concurrente. El módulo `Agent` ofrece una interfaz simple para crear, actualizar y leer el estado del agente. Entre las funciones más comunes del módulo `Agent` se encuentran:

- `Agent.start_link/2`: Inicia un nuevo agente con un estado inicial.
- `Agent.get/2`: Obtiene el estado actual del agente.
- `Agent.update/2`: Actualiza el estado del agente utilizando una función.
- `Agent.get_and_update/2`: Obtiene y actualiza el estado del agente en una sola operación.
- `Agent.stop/1`: Detiene el agente.

En el proyecto que hicimos previamente (Gimnasio), podemos usar un `Agent` para mantener el estado del gimnasio y su mapa de miembros. Para esto, podemos escribir lo siguiente:

```elixir
defmodule Gimnasio do

  use Agent # Importar el módulo Agent

  def start_link do
    # Iniciar el agente con un mapa vacío como estado inicial
    Agent.start_link(fn -> %{} end, name: __MODULE__)
  end

  defp agregar_socio(cedula, socio) do
    # Agregar un nuevo socio al mapa, actualizando el estado del agente
    Agent.update(__MODULE__, fn socios -> Map.put(socios, cedula, socio) end)
  end

  defp obtener_socio(cedula) do
    # Obtener un socio del mapa por su cédula
    Agent.get(__MODULE__, fn socios -> Map.get(socios, cedula) end)
  end

  defp eliminar_socio(cedula) do
    # Eliminar un socio del mapa por su cédula
    Agent.update(__MODULE__, fn socios -> Map.delete(socios, cedula) end)
  end

  defp listar_socios do
    # Listar todos los socios en el mapa
    Agent.get(__MODULE__, fn socios -> socios end)
  end

  defp inscribir_clase(cedula, clase) do
    # Se actualiza el estado del agente para inscribir una clase a un socio
    Agent.update(__MODULE__, fn socios ->
      case Map.get(socios, cedula) do
        nil -> socios  # Si el socio no existe, no hacer nada
        socio ->
          actualizado = %{socio | clases: [clase | socio.clases]}
          Map.put(socios, cedula, actualizado)
      end
    end)
  end

  def main do
    start_link() # Iniciar el agente (es importante hacerlo antes de usarlo)

    agregar_socio("123", %Socio{nombre: "Juan", edad: 30, clases: []})
    agregar_socio("456", %Socio{nombre: "Ana", edad: 25, clases: []})

    IO.inspect(obtener_socio("123"))
    IO.inspect(listar_socios())

    inscribir_clase("123", "Yoga")
    IO.inspect(obtener_socio("123"))

    eliminar_socio("456")
    IO.inspect(listar_socios())
  end
  
end

Gimnasio.main()
```

Dado que el `Agent` maneja su propio proceso, no es necesario preocuparse por la concurrencia al acceder o modificar el estado del gimnasio. El `Agent` se encarga de sincronizar el acceso al estado interno, lo que facilita la implementación de aplicaciones concurrentes. Además, **no es necesario pasar el mapa de socios** entre funciones, ya que el `Agent` mantiene el estado internamente. 

Elixir facilita el manejo del estado compartido y mutable mediante el uso de agentes, lo que permite construir aplicaciones concurrentes de manera más sencilla y segura.

Para más información sobre el módulo `Agent`, se recomienda consultar la [documentación oficial](https://hexdocs.pm/elixir/1.12/Agent.html).

---

# OTP (Open Telecom Platform)

En Elixir, **OTP (Open Telecom Platform)** es un conjunto de bibliotecas y herramientas que facilitan la creación de **aplicaciones concurrentes, distribuidas y tolerantes a fallos**.

OTP ofrece una serie de **comportamientos predefinidos** (*behaviours*) que proporcionan estructuras y patrones para organizar procesos y manejar tareas comunes en sistemas concurrentes.

### Componentes principales de OTP

* **GenServer:** Es un comportamiento que simplifica la implementación de **procesos con comportamiento de servidor**. Permite recibir y responder mensajes síncronos o asíncronos, mantener un estado interno y manejar la concurrencia de manera estructurada.

* **Supervisor:** Es un proceso responsable de **vigilar otros procesos** (como GenServers). Si alguno falla, el supervisor puede reiniciarlo automáticamente, ayudando a construir sistemas **tolerantes a fallos**.

* **Árbol de supervisión:** Es una estructura jerárquica compuesta por supervisores y procesos trabajadores. Permite **organizar, reiniciar y escalar** los distintos componentes de una aplicación OTP de forma controlada.

A continuación, profundizaremos en el comportamiento **GenServer**, que es uno de los componentes más utilizados en OTP.

## GenServer

GenServer (*Generic Server*) define una plantilla para crear procesos que **mantienen estado y responden a peticiones**. Un módulo que implementa un `GenServer` define una serie de funciones de *callback* que controlan su ciclo de vida y su comportamiento:

* **`start_link/3`**: Inicia un nuevo proceso GenServer y lo vincula al proceso que lo creó (para que se detenga automáticamente si este termina).
* **`init/1`**: Se ejecuta al iniciar el servidor; se usa para establecer el estado inicial.
* **`handle_call/3`**: Atiende *llamadas síncronas* (`GenServer.call/2` o `/3`), devolviendo una respuesta al proceso cliente.
* **`handle_cast/2`**: Atiende *mensajes asíncronos* (`GenServer.cast/2`), sin enviar respuesta al cliente.

También dispone de funciones auxiliares para interactuar con el servidor:

* **`call/2`** y **`call/3`**: Envían una solicitud síncrona al GenServer y esperan una respuesta.
* **`cast/2`**: Envía un mensaje asíncrono; no espera respuesta.
* **`reply/2`**: Permite enviar una respuesta manual a una llamada previamente recibida en un `handle_call`.
* **`stop/1`**: Detiene el GenServer de forma controlada.

---

### Ejemplo de uso

A continuación se muestra un ejemplo básico de cómo implementar un GenServer en Elixir:

```elixir
defmodule Contador do
  use GenServer

  # Función principal para iniciar el GenServer
  def start_link(valor_inicial) do
    # Se registra el GenServer con un nombre para facilitar su acceso y un estado inicial
    GenServer.start_link(__MODULE__, valor_inicial, name: __MODULE__)
  end

  # Funciones públicas para interactuar con el GenServer
  def valor(), do: GenServer.call(__MODULE__, :valor)
  def incrementar(), do: GenServer.cast(__MODULE__, :incrementar)

  # Callback para inicializar el estado del GenServer
  def init(valor_inicial), do: {:ok, valor_inicial}

  # Callback para manejar llamadas síncronas (el cliente espera una respuesta)
  def handle_call(:valor, _from, estado) do
    {:reply, estado, estado} # La respuesta siempre es una tupla {:reply, respuesta, nuevo_estado}
  end

  # Callback para manejar mensajes asíncronos (el cliente no espera respuesta)
  def handle_cast(:incrementar, estado) do
    {:noreply, estado + 1} # La respuesta siempre es una tupla {:noreply, nuevo_estado}
  end
end
```

Este ejemplo define un GenServer llamado `Contador` que mantiene un valor numérico. Proporciona dos funciones públicas: `valor/0` para obtener el valor actual y `incrementar/0` para aumentar el valor en 1. Internamente, el GenServer maneja las llamadas síncronas y los mensajes asíncronos mediante los callbacks `handle_call/3` y `handle_cast/2`, respectivamente.

Para usar este GenServer puede ejecutar el siguiente código:

```elixir
# Iniciar el GenServer con un valor inicial de 0
{:ok, _pid} = Contador.start_link(0)

# Incrementar el valor en 1
Contador.incrementar()

# Incrementar el valor en 1 nuevamente
Contador.incrementar()

# Obtener el valor actual
IO.puts("El contador vale: #{Contador.valor()}")
```

Para más información sobre GenServer, se recomienda consultar la [documentación oficial](https://hexdocs.pm/elixir/1.12/GenServer.html).

### Diferencias entre Agent y GenServer

La diferencia principal entre `Agent` y `GenServer` es que `GenServer` ofrece una mayor flexibilidad y control sobre el manejo de mensajes y el ciclo de vida del proceso. Mientras que `Agent` está diseñado para casos simples de manejo de estado, `GenServer` es más adecuado para aplicaciones más complejas que requieren lógica personalizada para manejar diferentes tipos de mensajes y estados.

En la siguiente tabla se resumen las diferencias clave entre `Agent` y `GenServer`:

| Característica      | **Agent**                             | **GenServer**                                                       |
| ------------------- | ------------------------------------- | ------------------------------------------------------------------- |
| Complejidad         | Simple                                | Complejo                                                            |
| Propósito principal | Almacenar y actualizar estado         | Controlar la comunicación y la lógica del proceso                   |
| Manejo de mensajes  | Automático (transparente)             | Manual (`handle_call`, `handle_cast`, etc.)                         |
| Ideal para          | Contadores, cachés, datos compartidos | Servidores, coordinadores, procesos con múltiples tipos de mensajes |
| Flexibilidad        | Limitada                              | Muy alta                                                            |

Para más información sobre GenServer y aplicaciones distribuidas en Elixir, se recomienda consultar [Concurrencia con OTP](https://elixirschool.com/en/lessons/advanced/otp_concurrency) y [Distribución con OTP](https://elixirschool.com/en/lessons/advanced/otp_distribution).

---

## Ejemplo 1

Se requiere crear un sistema de gestión de tareas donde los usuarios pueden agregar, eliminar y listar tareas. Cada tarea tiene un título y una descripción. El sistema debe manejar múltiples usuarios y sus respectivas listas de tareas. Debe usar `GenServer` como servidor para manejar las tareas de cada usuario.

En este caso, se quiere tener un servidor y múltiples clientes que se conecten a este servidor para gestionar sus tareas. A continuación, se muestra cómo se puede implementar esto utilizando `GenServer` y la funcionalidad de distribución de Elixir.

### 1. Crear la estructura de la tarea

Cree un archivo llamado `tareas.exs` y defina la estructura de una tarea:

```elixir
# Definición de la estructura de una tarea
defmodule Tarea do
  defstruct [:titulo, :descripcion]
end
```

Puede compilar el código anterior usando `elixirc tareas.exs` en la terminal para que esté disponible en el entorno de Elixir y pueda ser utilizado en otros archivos.

### 2. Crear el servidor

Cree un nuevo archivo llamado `servidor.exs` y defina el servidor de tareas utilizando `GenServer`:

```elixir
# Módulo del servidor de tareas
defmodule TareasServidor do
  use GenServer

  # Iniciar el GenServer con un estado inicial (un mapa vacío)
  def start_link do
    GenServer.start_link(__MODULE__, %{}, name: __MODULE__)
  end

  def init(state) do
    {:ok, state}
  end

  # Manejar la adición de una tarea
  def handle_cast({:agregar_tarea, usuario, tarea}, state) do
    tareas_usuario = Map.get(state, usuario, [])
    nuevas_tareas = [tarea | tareas_usuario]
    nuevo_estado = Map.put(state, usuario, nuevas_tareas)
    {:noreply, nuevo_estado}
  end

  # Manejar la eliminación de una tarea
  def handle_cast({:eliminar_tarea, usuario, titulo}, state) do
    tareas_usuario = Map.get(state, usuario, [])
    nuevas_tareas = Enum.filter(tareas_usuario, fn %Tarea{titulo: t} -> t != titulo end)
    nuevo_estado = Map.put(state, usuario, nuevas_tareas)
    {:noreply, nuevo_estado}
  end

  # Manejar la solicitud de listar tareas
  def handle_call({:listar_tareas, usuario}, _from, state) do
    tareas_usuario = Map.get(state, usuario, [])
    {:reply, tareas_usuario, state}
  end
end
```

El servidor `TareasServidor` mantiene un estado que es un mapa donde las claves son los nombres de usuario y los valores son listas de tareas. Proporciona funciones para agregar, eliminar y listar tareas. 

Dado que el servidor maneja su propio proceso, no es necesario preocuparse por la concurrencia al acceder o modificar el estado interno.

Además, el servidor puede ser iniciado en un nodo de Elixir, lo que permite que otros nodos (clientes) se conecten a él para gestionar sus tareas.

### 3. Crear el cliente

Cree un nuevo archivo llamado `cliente.exs` y defina el cliente de tareas utilizando `GenServer`:

```elixir
# Módulo del cliente
defmodule TareasCliente do

  @server_name TareasServidor  # Nombre del módulo del servidor
  @server_node :servidor_tareas@localhost  # Nombre del nodo donde se encuentra el servidor

  # ----------  Funciones públicas para interactuar con el servidor ----------  

  # Agregar una tarea al servidor
  def agregar_tarea(usuario, %Tarea{} = tarea) do
    GenServer.cast({@server_name, @server_node}, {:agregar_tarea, usuario, tarea})
  end

  # Eliminar una tarea del servidor
  def eliminar_tarea(usuario, titulo) do
    GenServer.cast({@server_name, @server_node}, {:eliminar_tarea, usuario, titulo})
  end

  # Retorna la lista de tareas del usuario desde el servidor
  def listar_tareas(usuario) do
    GenServer.call({@server_name, @server_node}, {:listar_tareas, usuario})
  end 

end
```

El cliente `TareasCliente` se conecta al servidor de tareas en un nodo específico. Proporciona funciones para agregar, eliminar y listar tareas, que internamente envían mensajes al servidor. Este cliente también maneja su propio proceso, lo que permite que múltiples clientes se conecten al mismo servidor de manera concurrente.

### 4. Configuración de nodos

Para probar la funcionalidad distribuida, es necesario iniciar dos nodos de Elixir. En uno de los nodos, se ejecuta el servidor de tareas, y en el otro nodo, se ejecuta el cliente que se conecta al servidor. Asegúrese de que ambos nodos puedan comunicarse entre sí.

**Nodo del servidor:**

En el módulo `TareasServidor`, puede agregar una función `main` para configurar el nodo del servidor:

```elixir
def main do
  # Se inicia el nodo del servidor
  {:ok, _} = Node.start(:servidor_tareas@localhost, :shortnames)

  # Establece la cookie
  Node.set_cookie(:mi_cookie)

  # Iniciar el servidor de tareas
  {:ok, _} = start_link()

  IO.puts("Servidor de tareas iniciado")
  IO.puts("Esperando conexiones de clientes...")

  # Mantener vivo el proceso principal
  :timer.sleep(:infinity)
end
```

No olvide llamar a `TareasServidor.main()` al final del archivo `servidor.exs` para iniciar el servidor cuando se ejecute el archivo.

**Nodo del cliente:**

En el módulo `TareasCliente`, puede agregar una función `main` para iniciar el nodo del cliente y conectarse al servidor:

```elixir
def main do
  # Se inicia el nodo del cliente
  {:ok, _} = Node.start(:cliente_tareas@localhost, :shortnames)

  # Establece la cookie
  Node.set_cookie(:mi_cookie)

  # Intenta conectarse al nodo del servidor
  case Node.connect(@server_node) do
    true ->
      IO.puts("Conectado al servidor de tareas")

      # Ejecutar algunas operaciones de ejemplo
      agregar_tarea("usuario1", %Tarea{titulo: "Comprar leche", descripcion: "Ir al supermercado"})
      agregar_tarea("usuario1", %Tarea{titulo: "Estudiar Elixir", descripcion: "Leer la guía oficial"})
      IO.inspect(listar_tareas("usuario1"))

    false ->
      IO.puts("No se pudo conectar al servidor de tareas")
  end
end
```

No olvide llamar a `TareasCliente.main()` al final del archivo `cliente.exs` para iniciar el cliente cuando se ejecute el archivo.

### 5. Ejecutar los nodos

Para ejecutar los nodos, abra dos terminales. En la primera terminal, inicie el nodo del servidor:

```bash
elixir servidor.exs
```

En la segunda terminal, inicie el nodo del cliente:

```bash
elixir cliente.exs
```

Al ejecutar ambos nodos, el cliente se conectará al servidor y podrá agregar, eliminar y listar tareas de manera distribuida.

### 6. Interactuar con el cliente

Modifique la función `main` del cliente para permitir la interacción del usuario a través de la terminal. Puede utilizar `IO.gets/1` para leer entradas del usuario y realizar acciones en consecuencia. Piense en un menú simple que permita al usuario elegir entre agregar, eliminar o listar tareas hasta que decida salir.

### 7. Probar con varios clientes

Puede abrir más terminales y ejecutar más instancias del cliente para simular múltiples usuarios conectándose al mismo servidor. Cada cliente podrá gestionar sus propias tareas de manera independiente.

Incluso, si un cliente falla o se desconecta, el servidor seguirá funcionando y manteniendo el estado de las tareas de los demás clientes ya que cada nodo maneja su propio proceso.

### 8. Usar varias máquinas (opcional)

Si desea probar la funcionalidad distribuida en varias máquinas, asegúrese de que ambas máquinas estén en la misma red y puedan comunicarse entre sí. Inicie el servidor en una máquina y el cliente en otra, utilizando las direcciones IP correspondientes en lugar de `localhost`. Además, al cambiar `localhost` por la IP de la máquina del servidor, debe usar `:longnames` en lugar de `:shortnames` al iniciar los nodos.

Recuerde que en la guía de **Aplicaciones Distribuidas** (clase anterior) se explica cómo configurar nodos en diferentes máquinas.

---

## Ejemplo 2

Cree un sistema de chat simple donde los usuarios pueden enviar y recibir mensajes. Cada usuario debe tener su propio proceso que maneje la recepción de mensajes. Utilice `GenServer` para implementar tanto el servidor de chat como los clientes.

### 1. Estructura de archivos

La aplicación se puede organizar en tres archivos principales:

```
ChatApp/
├── chat_server.exs   # El orquestador: salas, usuarios y mensajes
├── chat_room.exs     # Cada sala es un GenServer independiente
└── chat_client.exs   # Lógica de usuario (interfaz del cliente)
```

### 2. Implementación de la sala de chat

Cree un archivo llamado `chat_room.exs` y defina el módulo `ChatRoom` utilizando `GenServer`:

```elixir
defmodule ChatRoom do
  use GenServer

  # Estado: %{name: String, users: %{pid => username}, messages: [String]}

  ## --- API pública ---

  def start_link(name) do
    GenServer.start_link(__MODULE__, %{name: name, users: %{}, messages: []})
  end

  def join(pid, user_pid, username), do: GenServer.cast(pid, {:join, user_pid, username})
  def leave(pid, user_pid), do: GenServer.cast(pid, {:leave, user_pid})
  def send_message(pid, user_pid, msg), do: GenServer.cast(pid, {:message, user_pid, msg})

  ## Callbacks

  @impl true
  def init(state), do: {:ok, state}

  @impl true
  def handle_cast({:join, pid, username}, state) do
    Process.monitor(pid) # Monitorear el proceso del usuario para detectar desconexiones
    IO.puts("#{username} se unió a #{state.name}")
    {:noreply, %{state | users: Map.put(state.users, pid, username)}}
  end

  def handle_cast({:leave, pid}, state) do
    {username, users} = Map.pop(state.users, pid) # Eliminar al usuario
    IO.puts("#{username} salió de #{state.name}")
    {:noreply, %{state | users: users}}
  end

  def handle_cast({:message, from_pid, msg}, state) do
    username = Map.get(state.users, from_pid, "Desconocido")
    full = "#{username}: #{msg}"
    Enum.each(state.users, fn {pid, _} -> send(pid, {:chat, state.name, full}) end)
    {:noreply, %{state | messages: [full | state.messages]}}
  end

  @impl true
  def handle_info({:DOWN, _ref, :process, pid, _}, state) do
    {username, users} = Map.pop(state.users, pid) # Eliminar al usuario desconectado cuando su proceso muere
    IO.puts("#{username} desconectado de #{state.name}")
    {:noreply, %{state | users: users}}
  end
end
```

Cada sala de chat es un `GenServer` independiente que mantiene su propio estado, incluyendo los usuarios conectados y los mensajes enviados. Los usuarios pueden unirse, salir y enviar mensajes a la sala. 

El pid del usuario se monitorea para detectar desconexiones y eliminar automáticamente al usuario de la sala.

### 3. Implementación del servidor de chat

Cree un archivo llamado `chat_server.exs` y defina el módulo `ChatServer` utilizando `GenServer`:

```elixir
defmodule ChatServer do
  use GenServer

  ## --- API pública ---

  def start_link(_opts \\ []) do
    GenServer.start_link(__MODULE__, %{}, name: __MODULE__)
  end

  def create_room(name), do: GenServer.call(__MODULE__, {:create_room, name})
  def list_rooms(), do: GenServer.call(__MODULE__, :list_rooms)
  def get_room_pid(name), do: GenServer.call(__MODULE__, {:get_room, name})

  ## --- Callbacks ---

  @impl true
  def init(_) do
    {:ok, sup} = DynamicSupervisor.start_link(strategy: :one_for_one) # Supervisor dinámico para las salas de chat
    {:ok, %{rooms: %{}, sup: sup}}
  end

  @impl true
  def handle_call({:create_room, name}, _from, state) do
    if Map.has_key?(state.rooms, name) do
      {:reply, {:error, :exists}, state}
    else
      {:ok, pid} = DynamicSupervisor.start_child(state.sup, {ChatRoom, name}) # Iniciar una nueva sala
      {:reply, {:ok, pid}, %{state | rooms: Map.put(state.rooms, name, pid)}}
    end
  end

  def handle_call(:list_rooms, _from, state) do
    {:reply, Map.keys(state.rooms), state}
  end

  def handle_call({:get_room, name}, _from, state) do
    {:reply, Map.get(state.rooms, name), state}
  end
end
```

`DynamicSupervisor` se utiliza para gestionar las salas de chat, permitiendo crear y eliminar salas de manera dinámica. Esto facilita la escalabilidad y la gestión de múltiples salas de chat.

La diferencia entre `start_link` y `start_child` es que `start_link` se utiliza para iniciar un proceso supervisado (como el servidor principal), mientras que `start_child` se utiliza para iniciar procesos hijos bajo un supervisor dinámico (como las salas de chat).

### 4. Implementación del cliente de chat

Cree un archivo llamado `chat_client.exs` y defina el módulo `ChatClient` así:

```elixir
defmodule ChatClient do
  def start(username) do
    spawn(fn -> loop(username, %{}) end)
  end

  defp loop(username, joined_rooms) do
    receive do
      {:chat, room, msg} ->
        IO.puts("[#{room}] #{msg}")
        loop(username, joined_rooms)

      {:join, server_pid, room_name} ->
        case ChatServer.get_room_pid(room_name) do
          nil ->
            IO.puts("La sala #{room_name} no existe")
            loop(username, joined_rooms)

          room_pid ->
            ChatRoom.join(room_pid, self(), username)
            loop(username, Map.put(joined_rooms, room_name, room_pid))
        end

      {:send, room_name, msg} ->
        case Map.get(joined_rooms, room_name) do
          nil -> IO.puts("No estás en la sala #{room_name}")
          room_pid -> ChatRoom.send_message(room_pid, self(), msg)
        end
        loop(username, joined_rooms)

      {:leave, room_name} ->
        case Map.pop(joined_rooms, room_name) do
          {nil, _} -> IO.puts("No estás en #{room_name}")
          {pid, rest} -> ChatRoom.leave(pid, self()); loop(username, rest)
        end
    end
  end
end
```

El cliente cuenta con un bucle de recepción que maneja mensajes entrantes del servidor y permite al usuario unirse a salas, enviar mensajes y salir de salas.

### 5. Ejecutar la aplicación de chat

Una vez que tenga los tres archivos (`chat_server.exs`, `chat_room.exs`, `chat_client.exs`), puede probar la funcionalidad en `iex` de la siguiente manera:

```elixir
iex> ChatServer.start_link()
{:ok, pid}

iex> ChatServer.create_room("general")
{:ok, #PID<0.130.0>}

iex> ChatServer.create_room("random")
{:ok, #PID<0.132.0>}

iex> alice = ChatClient.start("Alice")
iex> bob = ChatClient.start("Bob")

# Unirse
iex> send(alice, {:join, ChatServer, "general"})
iex> send(bob, {:join, ChatServer, "general"})

# Enviar mensajes
iex> send(alice, {:send, "general", "Hola Bob!"})
iex> send(bob, {:send, "general", "Hola Alice!"})

# Salir de una sala
iex> send(bob, {:leave, "general"})
```

Tenga que para que esto funcione, debe tener los tres archivos cargados en el entorno de `iex` o compilados previamente.

### 6. Mejoras y consideraciones

Con base en el ejemplo anterior, puede mejorar la aplicación de chat separando el servidor y los clientes en **nodos diferentes** para aprovechar la capacidad de distribución de Elixir. Haga que el cliente también sea un `GenServer` para manejar mejor la comunicación y el estado del cliente.

Además, haga que los clientes puedan interactuar a través de la terminal, permitiendo a los usuarios ingresar comandos para unirse a salas, enviar mensajes y salir.

---

## Para la próxima clase

- Profundice en el concepto y funcionamiento de los Supervisores en OTP y cómo se utilizan para gestionar y recuperar procesos ante fallos
- Qué es Mix y cómo se utiliza para gestionar proyectos en Elixir.
- Qué es ExUnit y cómo se utiliza para escribir y ejecutar pruebas en Elixir.



