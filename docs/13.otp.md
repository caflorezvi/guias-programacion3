```
Universidad del Quindío
Programa de Ingeniería de Sistemas y Computación
Programación III - OTP (Open Telecom Platform)
Docente: Carlos Andrés Florez V.
```

# Introducción a OTP

**OTP (Open Telecom Platform)** es mucho más que un conjunto de bibliotecas: es una **plataforma completa** para construir sistemas concurrentes, distribuidos y tolerantes a fallos. Aunque su nombre sugiere que está orientado a telecomunicaciones, OTP es utilizado en una amplia variedad de aplicaciones, desde servidores web hasta sistemas de mensajería y bases de datos distribuidas.

## ¿Por qué necesitamos OTP?

En las clases anteriores, aprendimos a crear procesos manualmente usando `spawn`, `send` y `receive`. Si bien estos son los bloques fundamentales, construir aplicaciones robustas solo con ellos presenta varios desafíos:

1. **Manejo manual del estado**: Debemos implementar bucles recursivos para mantener el estado del proceso.
2. **Gestión de errores compleja**: ¿Qué pasa si un proceso falla? ¿Cómo lo reiniciamos?
3. **Código repetitivo**: Patrones como "servidor con estado" se repiten constantemente.
4. **Supervisión manual**: Debemos escribir código para monitorear y reiniciar procesos.
5. **Sin estándares**: Cada desarrollador implementa estos patrones de manera diferente.

**OTP resuelve estos problemas** proporcionando abstracciones probadas y estandarizadas que encapsulan patrones comunes de concurrencia.

## La filosofía "Let it crash"

Uno de los principios fundamentales de OTP es **"déjalo fallar"** (let it crash). En lugar de programar defensivamente para prevenir todos los errores posibles, OTP promueve:

1. **Aislamiento**: Los procesos están aislados, un fallo no afecta a otros.
2. **Supervisión**: Los supervisores detectan y reinician procesos fallidos.
3. **Recuperación rápida**: El sistema se recupera automáticamente a un estado conocido.

Este enfoque simplifica el código al eliminar la necesidad de manejar todos los casos de error, permitiendo que los supervisores se encarguen de la recuperación.

## Arquitectura de OTP

OTP proporciona tres componentes principales para construir aplicaciones robustas:

### 1. **Behaviours (Comportamientos)**

Son plantillas que definen interfaces estándar para crear procesos con funcionalidades específicas. Los más comunes son:

- **GenServer**: Servidor genérico (mantiene estado, responde peticiones), permite crear procesos con lógica compleja de manera sencilla.
- **Supervisor**: Supervisa y reinicia procesos hijos, ideal para implementar la filosofía "let it crash".
- **Agent**: Estado compartido simple, útil para casos donde solo se necesita almacenar y recuperar datos.

### 2. **Supervisores**

Procesos especiales que vigilan procesos hijos, los reinician automáticamente si fallan, implementan estrategias de recuperación y forman árboles jerárquicos.

### 3. **Aplicaciones**

Componentes empaquetados que agrupan módulos relacionados, definen dependencias, configuran el árbol de supervisión inicial y pueden iniciarse o detenerse como una unidad. Es la unidad de despliegue en sistemas OTP. La estudiaremos en detalle más adelante cuando hablemos de **Mix**.

---

# Agent

Antes de profundizar en GenServer, es importante entender **Agent**, que es la abstracción más simple de OTP para manejar estado.

## ¿Qué es un Agent?

El módulo `Agent` en Elixir proporciona una forma sencilla de crear y manejar procesos que mantienen un estado compartido. Los agentes son útiles cuando se necesita un proceso que almacene y gestione un estado mutable de manera concurrente. El módulo `Agent` ofrece una interfaz simple para crear, actualizar y leer el estado del agente. 

Es ideal para casos donde solo se necesita almacenar y recuperar datos sin la complejidad de manejar múltiples tipos de mensajes o lógica de negocio compleja.

## Funciones principales

Entre las funciones más utilizadas del módulo `Agent` se encuentran:

- `Agent.start_link/2`: Inicia un agente con estado inicial
- `Agent.get/2`: Lee el estado (puede transformarlo)
- `Agent.update/2`: Modifica el estado
- `Agent.get_and_update/2`: Lee y modifica en una operación atómica
- `Agent.stop/1`: Detiene el agente

## Ejemplo básico

A continuación, un ejemplo simple de uso de `Agent` para mantener el estado de un contador:

```elixir
# Iniciar un agente con un contador en 0
{:ok, contador} = Agent.start_link(fn -> 0 end)

# Incrementar el contador
Agent.update(contador, fn n -> n + 1 end)

# Obtener el valor actual
valor = Agent.get(contador, fn n -> n end)
IO.puts("Contador: #{valor}")  # Contador: 1

# Obtener y actualizar en una operación
{valor_anterior, nuevo_valor} = Agent.get_and_update(contador, fn n -> {n, n + 5} end)
IO.puts("Antes: #{valor_anterior}, Ahora: #{nuevo_valor}")  # Antes: 1, Ahora: 6
```

El estado del agente es seguro para el acceso concurrente, lo que significa que múltiples procesos pueden leer y escribir al mismo tiempo sin riesgo de corrupción de datos.

## Ejemplo con el gimnasio

En el proyecto del gimnasio que hicimos previamente, podemos usar un `Agent` para mantener el estado. A continuación, un ejemplo simplificado:

```elixir
defmodule Gimnasio do
  use Agent

  # Estructura de un socio
  defmodule Socio do
    defstruct [:nombre, :edad, :clases]
  end

  def start_link do
    Agent.start_link(fn -> %{} end, name: __MODULE__)
  end

  def agregar_socio(cedula, nombre, edad) do
    socio = %Socio{nombre: nombre, edad: edad, clases: []}
    Agent.update(__MODULE__, fn socios -> 
      Map.put(socios, cedula, socio) 
    end)
  end

  def obtener_socio(cedula) do
    Agent.get(__MODULE__, fn socios -> Map.get(socios, cedula) end)
  end

  def eliminar_socio(cedula) do
    Agent.update(__MODULE__, fn socios -> Map.delete(socios, cedula) end)
  end

  def listar_socios do
    Agent.get(__MODULE__, fn socios -> socios end)
  end

  def inscribir_clase(cedula, clase) do
    Agent.update(__MODULE__, fn socios ->
      case Map.get(socios, cedula) do
        nil -> 
          IO.puts("Socio no encontrado")
          socios
        socio ->
          actualizado = %{socio | clases: [clase | socio.clases]}
          Map.put(socios, cedula, actualizado)
      end
    end)
  end

  def main do
    start_link()

    agregar_socio("123", "Juan", 30)
    agregar_socio("456", "Ana", 25)

    IO.inspect(obtener_socio("123"), label: "Socio 123")
    IO.inspect(listar_socios(), label: "Todos los socios")

    inscribir_clase("123", "Yoga")
    IO.inspect(obtener_socio("123"), label: "Socio 123 después de inscribir")

    eliminar_socio("456")
    IO.inspect(listar_socios(), label: "Socios después de eliminar")
  end
end

Gimnasio.main()
```

**Ventajas del Agent aquí:**
- No necesitamos pasar el mapa de socios entre funciones
- El estado está protegido contra condiciones de carrera
- Múltiples procesos pueden acceder concurrentemente de forma segura

Para más información sobre Agent: [Documentación oficial](https://hexdocs.pm/elixir/Agent.html)

---

# GenServer

**GenServer** (Generic Server) es el behaviour más utilizado en OTP. Define una plantilla para crear procesos que mantienen estado y responden a peticiones. Un módulo que implementa un `GenServer` define una serie de funciones de callback que controlan su ciclo de vida y su comportamiento.

## Características principales de GenServer

Entre las características clave de GenServer se incluyen:

- Mantienen **estado interno**
- Responden a **peticiones síncronas** (call)
- Manejan **mensajes asíncronos** (cast)
- Ejecutan **código de inicialización y terminación**

## ¿Cuándo usar GenServer?

Se recomienda usar `GenServer` cuando se necesita:

- **Lógica de negocio compleja**: Más que solo almacenar/leer estado
- **Múltiples tipos de mensajes**: Con diferentes comportamientos
- **Callbacks personalizados**: Para inicialización, limpieza, etc.
- **Integración con supervisores**: Para tolerancia a fallos

## Anatomía de un GenServer

Un `GenServer` típico consta de dos partes principales, cada una con su propio conjunto de funciones:

### 1. API del Cliente (funciones públicas)

Estas funciones son llamadas por otros procesos y ocultan los detalles de comunicación:

```elixir
def valor(), do: GenServer.call(__MODULE__, :valor)
def incrementar(), do: GenServer.cast(__MODULE__, :incrementar)
```

### 2. Callbacks del Servidor (funciones privadas)

Estas funciones son ejecutadas por el proceso del `GenServer`:

```elixir
def handle_call(:valor, _from, estado) do
  {:reply, estado, estado}
end

def handle_cast(:incrementar, estado) do
  {:noreply, estado + 1}
end
```

Estas funciones manejan la lógica interna y el estado del servidor. Son invocadas automáticamente por el `GenServer` cuando recibe mensajes.

## Callbacks principales

### `init/1` - Inicialización

Se ejecuta cuando el `GenServer` arranca. Define el estado inicial:

```elixir
@impl true
def init(valor_inicial) do
  # Puede realizar configuración aquí
  {:ok, valor_inicial}
end
```

**Valores de retorno:**
- `{:ok, estado}`: Inicialización exitosa
- `{:ok, estado, timeout}`: Con timeout de inactividad
- `:ignore`: No iniciar el servidor
- `{:stop, razón}`: Fallo en la inicialización

### `handle_call/3` - Peticiones síncronas

Maneja peticiones que **esperan respuesta**:

```elixir
@impl true
def handle_call(:obtener_datos, _from, estado) do
  {:reply, estado.datos, estado}
end
```

**Parámetros:**
- `mensaje`: El mensaje enviado
- `from`: Tupla `{pid, ref}` del proceso cliente
- `estado`: Estado actual del servidor

**Valores de retorno:**
- `{:reply, respuesta, nuevo_estado}`: Responde inmediatamente
- `{:noreply, nuevo_estado}`: Respuesta diferida (usar `GenServer.reply/2`)
- `{:stop, razón, respuesta, nuevo_estado}`: Responde y detiene el servidor

### `handle_cast/2` - Mensajes asíncronos

Maneja mensajes que **no esperan respuesta**:

```elixir
@impl true
def handle_cast({:actualizar, valor}, estado) do
  {:noreply, %{estado | valor: valor}}
end
```

**Valores de retorno:**
- `{:noreply, nuevo_estado}`: Continúa con nuevo estado
- `{:stop, razón, nuevo_estado}`: Detiene el servidor

### `handle_info/2` - Mensajes no esperados

Maneja mensajes enviados directamente con `send/2` (no a través de call/cast):

```elixir
@impl true
def handle_info(:tick, estado) do
  # Ejecutar tarea periódica
  {:noreply, estado}
end

def handle_info({:DOWN, _ref, :process, pid, _reason}, estado) do
  # Manejar muerte de proceso monitoreado
  {:noreply, actualizar_estado_sin_proceso(estado, pid)}
end
```

### `terminate/2` - Limpieza

Se ejecuta antes de que el proceso termine:

```elixir
@impl true
def terminate(razon, estado) do
  # Limpiar recursos, cerrar conexiones, etc.
  IO.puts("Servidor detenido: #{inspect(razon)}")
  :ok
end
```
---

## Diferencias entre Agent y GenServer

Tanto `Agent` como `GenServer` son herramientas poderosas para manejar estado en Elixir, pero tienen diferencias clave en términos de complejidad y casos de uso.

| Característica      | **Agent**                             | **GenServer**                                                       |
| ------------------- | ------------------------------------- | ------------------------------------------------------------------- |
| **Complejidad**     | Simple                                | Complejo                                                            |
| **Propósito**       | Almacenar y actualizar estado         | Controlar lógica de negocio y comunicación                          |
| **Manejo de mensajes** | Automático (transparente)          | Manual (`handle_call`, `handle_cast`, `handle_info`)                |
| **Callbacks**       | No disponibles                        | `init`, `terminate`, `code_change`, etc.                            |
| **Ideal para**      | Contadores, cachés, configuraciones   | Servicios, coordinadores, procesos con lógica compleja              |
| **Flexibilidad**    | Limitada                              | Muy alta                                                            |
| **Bajo el capó**    | Es un GenServer simplificado          | Implementación completa de behaviour                                |

**Regla general:** Comience con `Agent`. Si necesita más control o lógica compleja, migre a `GenServer`.

---

## Ejemplo 1. Contador

Ahora, un ejemplo completo de un `GenServer` que implementa un contador simple. Compare este ejemplo con el que hicimos usando `Agent` anteriormente.

```elixir
defmodule Contador do
  use GenServer

  # ========== API del Cliente ==========

  def start_link(valor_inicial) do
    GenServer.start_link(__MODULE__, valor_inicial, name: __MODULE__)
  end

  def valor(), do: GenServer.call(__MODULE__, :valor)
  def incrementar(), do: GenServer.cast(__MODULE__, :incrementar)
  def decrementar(), do: GenServer.cast(__MODULE__, :decrementar)
  def sumar(n), do: GenServer.cast(__MODULE__, {:sumar, n})
  def reiniciar(), do: GenServer.cast(__MODULE__, :reiniciar)
  def detener(), do: GenServer.stop(__MODULE__)

  # ========== Callbacks del Servidor ==========

  @impl true
  def init(valor_inicial) do
    IO.puts("Contador iniciado con valor: #{valor_inicial}")
    {:ok, valor_inicial}
  end

  @impl true
  def handle_call(:valor, _from, estado) do
    {:reply, estado, estado} # Responde con el estado actual pero no lo modifica
  end

  @impl true
  def handle_cast(:incrementar, estado) do
    {:noreply, estado + 1} # Modifica el estado incrementándolo en 1
  end

  def handle_cast(:decrementar, estado) do
    {:noreply, estado - 1} # Modifica el estado decrementándolo en 1
  end

  def handle_cast({:sumar, n}, estado) do
    {:noreply, estado + n} # Suma n al estado actual
  end

  def handle_cast(:reiniciar, _estado) do
    {:noreply, 0} # Modifica el estado reiniciándolo a 0
  end

  @impl true
  def terminate(razon, estado) do
    IO.puts("Contador detenido. Razón: #{inspect(razon)}, Valor final: #{estado}")
    :ok
  end
end

# Uso
{:ok, _pid} = Contador.start_link(0)
Contador.incrementar()
Contador.incrementar()
Contador.sumar(5)
IO.puts("Valor: #{Contador.valor()}")  # Valor: 7
Contador.detener()
```

## `call` vs `cast`: ¿Cuándo usar cada uno?

En `GenServer`, `call` y `cast` son dos formas diferentes de comunicarse con el servidor, cada una con sus propias características y casos de uso.

| Característica | `call` (síncrono) | `cast` (asíncrono) |
|----------------|-------------------|-------------------|
| **Espera respuesta** | Sí, bloquea hasta recibir | No, retorna inmediatamente |
| **Garantías** | El mensaje se procesó | El mensaje se envió |
| **Rendimiento** | Más lento (espera) | Más rápido (fire and forget) |
| **Cuándo usar** | Se espera el resultado | Actualizar estado sin respuesta |
| **Ejemplo** | Leer datos, validaciones | Logs, actualizaciones, notificaciones |

## Ejemplo 2. Carrito de compras

En este ejemplo, implementamos un `GenServer` que maneja un carrito de compras con múltiples productos, cantidades y descuentos:

```elixir
defmodule CarritoCompras do
  use GenServer

  defmodule Estado do
    defstruct productos: %{}, total: 0, descuento: 0
  end

  # ========== API ==========

  def start_link(_opts) do
    GenServer.start_link(__MODULE__, %Estado{}, name: __MODULE__)
  end

  def agregar(producto_id, precio, cantidad \\ 1) do
    GenServer.cast(__MODULE__, {:agregar, producto_id, precio, cantidad})
  end

  def eliminar(producto_id) do
    GenServer.cast(__MODULE__, {:eliminar, producto_id})
  end

  def aplicar_descuento(porcentaje) do
    GenServer.cast(__MODULE__, {:descuento, porcentaje})
  end

  def obtener_total() do
    GenServer.call(__MODULE__, :total)
  end

  def ver_carrito() do
    GenServer.call(__MODULE__, :ver_carrito)
  end

  # ========== Callbacks ==========

  @impl true
  def init(estado) do
    {:ok, estado}
  end

  @impl true
  def handle_cast({:agregar, id, precio, cantidad}, estado) do
    # Se crea un nuevo producto
    producto = %{precio: precio, cantidad: cantidad}
    # Actualiza o agrega el producto en el carrito
    productos = Map.update(estado.productos, id, producto, fn p ->
      %{p | cantidad: p.cantidad + cantidad}
    end)
    # Calcula el nuevo total considerando el descuento
    nuevo_total = calcular_total(productos, estado.descuento)
    # Actualiza el estado con los nuevos productos y total pero no responde al cliente
    {:noreply, %{estado | productos: productos, total: nuevo_total}}
  end

  def handle_cast({:eliminar, id}, estado) do
    # Elimina el producto del carrito
    productos = Map.delete(estado.productos, id)
    # Calcula el nuevo total considerando el descuento
    nuevo_total = calcular_total(productos, estado.descuento)
    # Actualiza el estado con los nuevos productos y total pero no responde al cliente
    {:noreply, %{estado | productos: productos, total: nuevo_total}}
  end

  def handle_cast({:descuento, porcentaje}, estado) do
    # Aplica el descuento y recalcula el total
    nuevo_total = calcular_total(estado.productos, porcentaje)
    # Actualiza el estado con el nuevo descuento y total pero no responde al cliente
    {:noreply, %{estado | descuento: porcentaje, total: nuevo_total}}
  end

  @impl true
  def handle_call(:total, _from, estado) do
    {:reply, estado.total, estado} # Responde con el total actual
  end

  def handle_call(:ver_carrito, _from, estado) do
    {:reply, estado, estado} # Responde con el estado completo del carrito
  end

  # ========== Helpers ==========

  defp calcular_total(productos, descuento) do
    subtotal = Enum.reduce(productos, 0, fn {_id, %{precio: p, cantidad: c}}, acc ->
      acc + (p * c)
    end)
    
    subtotal * (1 - descuento / 100)
  end
end
```

## Ejemplo 3: Sistema de gestión de tareas distribuido

Se requiere crear un sistema de gestión de tareas donde los usuarios pueden agregar, eliminar y listar tareas. Cada tarea tiene un título y una descripción. El sistema debe manejar múltiples usuarios y sus respectivas listas de tareas usando `GenServer` como servidor.

### 1. Crear la estructura de la tarea

Cree un archivo llamado `tarea.exs`:

```elixir
defmodule Tarea do
  defstruct [:titulo, :descripcion, :completada]
  
  def nueva(titulo, descripcion) do
    %__MODULE__{titulo: titulo, descripcion: descripcion, completada: false}
  end
end
```

Compile con: `elixirc tarea.exs`

### 2. Crear el servidor

Cree `servidor.exs`:

```elixir
defmodule TareasServidor do
  use GenServer

  # Estado: %{usuario => [%Tarea{}]}

  def start_link do
    GenServer.start_link(__MODULE__, %{}, name: __MODULE__)
  end

  # ========== API pública ==========

  def agregar_tarea(usuario, tarea) do
    GenServer.cast(__MODULE__, {:agregar, usuario, tarea})
  end

  def eliminar_tarea(usuario, titulo) do
    GenServer.cast(__MODULE__, {:eliminar, usuario, titulo})
  end

  def completar_tarea(usuario, titulo) do
    GenServer.cast(__MODULE__, {:completar, usuario, titulo})
  end

  def listar_tareas(usuario) do
    GenServer.call(__MODULE__, {:listar, usuario})
  end

  def estadisticas(usuario) do
    GenServer.call(__MODULE__, {:stats, usuario})
  end

  # ========== Callbacks ==========

  @impl true
  def init(state) do
    IO.puts("[Servidor] Iniciado")
    {:ok, state}
  end

  @impl true
  def handle_cast({:agregar, usuario, tarea}, state) do
    tareas = Map.get(state, usuario, [])
    nuevo_estado = Map.put(state, usuario, [tarea | tareas])
    IO.puts("[Servidor] Tarea agregada para #{usuario}")
    {:noreply, nuevo_estado}
  end

  def handle_cast({:eliminar, usuario, titulo}, state) do
    tareas = Map.get(state, usuario, [])
    nuevas_tareas = Enum.reject(tareas, fn t -> t.titulo == titulo end)
    {:noreply, Map.put(state, usuario, nuevas_tareas)}
  end

  def handle_cast({:completar, usuario, titulo}, state) do
    tareas = Map.get(state, usuario, [])
    nuevas_tareas = Enum.map(tareas, fn t ->
      if t.titulo == titulo, do: %{t | completada: true}, else: t
    end)
    {:noreply, Map.put(state, usuario, nuevas_tareas)}
  end

  @impl true
  def handle_call({:listar, usuario}, _from, state) do
    tareas = Map.get(state, usuario, [])
    {:reply, tareas, state}
  end

  def handle_call({:stats, usuario}, _from, state) do
    tareas = Map.get(state, usuario, [])
    total = length(tareas)
    completadas = Enum.count(tareas, & &1.completada)
    pendientes = total - completadas
    
    {:reply, %{total: total, completadas: completadas, pendientes: pendientes}, state}
  end

  @impl true
  def terminate(razon, _state) do
    IO.puts("[Servidor] Detenido: #{inspect(razon)}")
    :ok
  end

  # ========== Main ==========

  def main do
    {:ok, _} = Node.start(:servidor_tareas@localhost, :shortnames)
    Node.set_cookie(:mi_cookie)
    {:ok, _} = start_link()

    IO.puts("Servidor de tareas iniciado en #{Node.self()}")
    IO.puts("Esperando conexiones...")
    :timer.sleep(:infinity)
  end
end

TareasServidor.main()
```

### 3. Crear el cliente

Cree `cliente.exs`:

```elixir
defmodule TareasCliente do
  @server_name TareasServidor
  @server_node :servidor_tareas@localhost

  def agregar_tarea(usuario, titulo, descripcion) do
    tarea = Tarea.nueva(titulo, descripcion)
    GenServer.cast({@server_name, @server_node}, {:agregar, usuario, tarea})
  end

  def eliminar_tarea(usuario, titulo) do
    GenServer.cast({@server_name, @server_node}, {:eliminar, usuario, titulo})
  end

  def completar_tarea(usuario, titulo) do
    GenServer.cast({@server_name, @server_node}, {:completar, usuario, titulo})
  end

  def listar_tareas(usuario) do
    GenServer.call({@server_name, @server_node}, {:listar, usuario})
  end

  def estadisticas(usuario) do
    GenServer.call({@server_name, @server_node}, {:stats, usuario})
  end

  def menu_principal(usuario) do
    IO.puts("\n=== Sistema de Tareas ===")
    IO.puts("Usuario: #{usuario}")
    IO.puts("1. Agregar tarea")
    IO.puts("2. Listar tareas")
    IO.puts("3. Completar tarea")
    IO.puts("4. Eliminar tarea")
    IO.puts("5. Ver estadísticas")
    IO.puts("6. Salir")
    
    opcion = IO.gets("Seleccione una opción: ") |> String.trim()
    procesar_opcion(opcion, usuario)
  end

  defp procesar_opcion("1", usuario) do
    titulo = IO.gets("Título: ") |> String.trim()
    descripcion = IO.gets("Descripción: ") |> String.trim()
    agregar_tarea(usuario, titulo, descripcion)
    IO.puts("Tarea agregada")
    menu_principal(usuario)
  end

  defp procesar_opcion("2", usuario) do
    tareas = listar_tareas(usuario)
    IO.puts("\n=== Tus Tareas ===")
    Enum.each(tareas, fn t ->
      estado = if t.completada, do: "✓", else: "☐"
      IO.puts("#{estado} #{t.titulo}: #{t.descripcion}")
    end)
    menu_principal(usuario)
  end

  defp procesar_opcion("3", usuario) do
    titulo = IO.gets("Título de la tarea a completar: ") |> String.trim()
    completar_tarea(usuario, titulo)
    IO.puts("Tarea completada")
    menu_principal(usuario)
  end

  defp procesar_opcion("4", usuario) do
    titulo = IO.gets("Título de la tarea a eliminar: ") |> String.trim()
    eliminar_tarea(usuario, titulo)
    IO.puts("Tarea eliminada")
    menu_principal(usuario)
  end

  defp procesar_opcion("5", usuario) do
    stats = estadisticas(usuario)
    IO.puts("\n=== Estadísticas ===")
    IO.puts("Total: #{stats.total}")
    IO.puts("Completadas: #{stats.completadas}")
    IO.puts("Pendientes: #{stats.pendientes}")
    menu_principal(usuario)
  end

  defp procesar_opcion("6", _usuario) do
    IO.puts("¡Hasta luego!")
    :ok
  end

  defp procesar_opcion(_, usuario) do
    IO.puts("Opción inválida")
    menu_principal(usuario)
  end

  def main do
    {:ok, _} = Node.start(:cliente_tareas@localhost, :shortnames)
    Node.set_cookie(:mi_cookie)

    case Node.connect(@server_node) do
      true ->
        IO.puts("Conectado al servidor")
        usuario = IO.gets("Ingrese su nombre de usuario: ") |> String.trim()
        menu_principal(usuario)
      false ->
        IO.puts("Error: No se pudo conectar al servidor")
    end
  end
end

TareasCliente.main()
```

### 4. Ejecutar

```bash
# Terminal 1
elixir servidor.exs

# Terminal 2
elixir cliente.exs
```

---

## Supervisores (Introducción básica)

Los **Supervisores** son procesos especiales que vigilan a otros procesos (sus "hijos") y los reinician automáticamente si fallan. Son fundamentales para la tolerancia a fallos en OTP.

### Estrategias de supervisión

Cuando un proceso hijo falla, el supervisor puede usar diferentes estrategias:

1. **`:one_for_one`**: Solo reinicia el proceso que falló
2. **`:one_for_all`**: Reinicia todos los procesos hijos
3. **`:rest_for_one`**: Reinicia el proceso fallido y todos los que se iniciaron después de él

### Ejemplo básico de Supervisor

Vamos a crear un supervisor que gestione dos procesos hijos: un contador y un servidor de tareas.

```elixir
defmodule MiApp.Supervisor do
  use Supervisor

  def start_link(opts) do
    Supervisor.start_link(__MODULE__, :ok, opts)
  end

  @impl true
  def init(:ok) do
    children = [
      {Contador, 0},           # Worker 1
      {TareasServidor, []}     # Worker 2
    ]

    # Si un hijo falla, solo ese se reinicia
    Supervisor.init(children, strategy: :one_for_one)
  end
end

# Iniciar el supervisor
{:ok, _pid} = MiApp.Supervisor.start_link([])
```

En caso de que uno de los procesos falle, el supervisor lo reiniciará automáticamente según la estrategia definida.

---

## Buenas prácticas

Al implementar GenServers, es importante seguir ciertas buenas prácticas para garantizar que el código sea mantenible, eficiente y robusto.

### 1. Separar API de Callbacks

Definir claramente las funciones públicas (API) y las funciones de callback:

```elixir
defmodule MiServidor do
  use GenServer

  # ========== API (funciones públicas) ==========
  def start_link(arg), do: GenServer.start_link(__MODULE__, arg, name: __MODULE__)
  def operacion(), do: GenServer.call(__MODULE__, :operacion)

  # ========== Callbacks (funciones privadas) ==========
  @impl true
  def init(arg), do: {:ok, arg}
  
  @impl true
  def handle_call(:operacion, _from, state), do: {:reply, :ok, state}
end
```

### 2. Usar `@impl true`

Marca explícitamente qué funciones son callbacks de OTP:

```elixir
@impl true
def init(state), do: {:ok, state}

@impl true
def handle_call(:msg, _from, state), do: {:reply, :ok, state}
```

### 3. Documentar el estado

Una buena práctica es documentar la estructura del estado mantenido por el GenServer:

```elixir
defmodule MiServidor do
  use GenServer

  # Estado: %{
  #   contador: integer(),
  #   usuarios: map(),
  #   config: keyword()
  # }
end
```

### 4. Manejar mensajes inesperados

Usar `handle_info/2` para capturar mensajes no esperados (que no son `call` o `cast`):

```elixir
@impl true
def handle_info(msg, state) do
  IO.warn("Mensaje inesperado: #{inspect(msg)}")
  {:noreply, state}
end
```

### 5. Usar timeouts apropiados

Se recomienda establecer timeouts adecuados para llamadas `call` y en la inicialización:

```elixir
# Call con timeout de 10 segundos
GenServer.call(servidor, :operacion_lenta, 10_000)

# Init con timeout de hibernación
def init(state) do
  {:ok, state, {:continue, :load_data}}
end
```

---

## Recursos adicionales

- **Documentación oficial de GenServer**: [https://hexdocs.pm/elixir/GenServer.html](https://hexdocs.pm/elixir/GenServer.html)
- **Documentación oficial de Agent**: [https://hexdocs.pm/elixir/Agent.html](https://hexdocs.pm/elixir/Agent.html)
- **Elixir School - OTP Concurrency**: [https://elixirschool.com/en/lessons/advanced/otp_concurrency](https://elixirschool.com/en/lessons/advanced/otp_concurrency)
- **Elixir School - OTP Supervisors**: [https://elixirschool.com/en/lessons/advanced/otp_supervisors](https://elixirschool.com/en/lessons/advanced/otp_supervisors)
- **Learn You Some Erlang - OTP**: [https://learnyousomeerlang.com/what-is-otp](https://learnyousomeerlang.com/what-is-otp)

---

## Para la próxima clase

1. **Profundizar en Supervisores**:
   - Estrategias de supervisión (`:one_for_one`, `:one_for_all`, `:rest_for_one`)
   - Árboles de supervisión jerárquicos
   - `DynamicSupervisor` en detalle
   - Configuración de reintentos y tiempos de espera

2. **Mix - Gestión de proyectos**:
   - Crear proyectos con `mix new`
   - Estructura de un proyecto Mix
   - Configuración en `mix.exs`
   - Dependencias y compilación

3. **ExUnit - Testing en Elixir**:
   - Escribir tests con `ExUnit`
   - Tests de GenServers
   - Coverage de código

4. **Aplicaciones OTP completas**:
   - Definir una aplicación OTP
   - Configurar el árbol de supervisión principal
   - Ciclo de vida de aplicaciones