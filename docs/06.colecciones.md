<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script> 
<script> 
  document.addEventListener("DOMContentLoaded", function() { mermaid.initialize({ startOnLoad: true }); }); 
</script>

```
Universidad del Quind√≠o
Programa de Ingenier√≠a de Sistemas y Computaci√≥n
Programaci√≥n III - Colecciones en Elixir
Docente: Carlos Andr√©s Florez V.
```

# Colecciones en Elixir

Una colecci√≥n es un conjunto de elementos que se agrupan bajo una misma estructura. En Elixir, las colecciones son fundamentales para manejar y organizar datos de manera eficiente. Existen varios tipos de colecciones en Elixir, cada una con sus propias caracter√≠sticas y usos espec√≠ficos. 

## Caracter√≠sticas fundamentales

Todas las colecciones en Elixir comparten estas propiedades:

1. **Inmutabilidad**: Una vez creadas, no se pueden modificar. Las operaciones crean nuevas colecciones. En lugar de alterar un valor existente, cualquier operaci√≥n que parezca "modificar" un dato, en realidad, **crea una nueva versi√≥n del dato original** con los cambios aplicados.
2. **Persistencia**: Las versiones anteriores siguen disponibles (*structural sharing*). Esto significa que las colecciones comparten partes no modificadas para optimizar el uso de memoria.
3. **Tipos de datos mixtos**: Pueden contener cualquier tipo de dato.
4. **Pattern matching**: Se pueden desestructurar para extraer valores.
5. **Funciones puras**: Las transformaciones no tienen efectos secundarios.

---

# Colecciones principales

En este apartado, exploraremos las tres colecciones principales en Elixir: Listas, Tuplas y Mapas. Veremos c√≥mo se definen, sus caracter√≠sticas y ejemplos de uso.

## Listas

Una **lista** es una colecci√≥n ordenada de elementos, que puede contener cualquier tipo de dato, incluyendo otras listas. Las listas se definen utilizando corchetes `[]` y los elementos se separan por comas. Por ejemplo:

```elixir
mi_lista = [1, 2, 3, 4, 5]
```

Las listas son estructuras de datos muy vers√°tiles y se utilizan com√∫nmente en Elixir. Las operaciones principales con listas se realizan mediante funciones y a menudo aprovechan el **Pattern Matching**.

Una de las formas m√°s potentes de trabajar con listas es a trav√©s del **Pattern Matching** utilizando la sintaxis `[head | tail]`. Esto permite desestructurar una lista en su primer elemento (`head`) y el resto de la lista (`tail`).

```elixir
# Lista original
lista = [1, 2, 3, 4, 5]

# Desestructurar con Pattern Matching
[cabeza | cola] = lista
IO.puts("Cabeza: #{cabeza}") # => Cabeza: 1
IO.puts("Cola: #{inspect(cola)}") # => Cola: [2, 3, 4, 5]

# Otro ejemplo: solo obtener los dos primeros elementos y el resto
[primero, segundo | resto] = [10, 20, 30, 40]
IO.puts("Primero: #{primero}")   # => Primero: 10
IO.puts("Segundo: #{segundo}")   # => Segundo: 20
IO.puts("Resto: #{inspect(resto)}") # => Resto: [30, 40]

# Intentar desestructurar una lista vac√≠a producir√° un error
# [cabeza | cola] = [] # ** (MatchError) no match of right hand side value: []
```

Adem√°s de la desestructuraci√≥n, existen varias operaciones y funciones √∫tiles para trabajar con listas, a continuaci√≥n se muestran algunos ejemplos:

```elixir
# Lista original
lista = [1, 2, 3]

# Tama√±o de la lista
length(lista)  # => 3

# Obtener el primer elemento (head)
hd(lista)  # => 1

# Obtener la lista sin el primer elemento (tail)
tl(lista)  # => [2, 3]

# Agregar un elemento al inicio (no modifica la original, crea una nueva). 
# Aqu√≠ se usa structural sharing para optimizar memoria, usando la cola existente (esto es transparente, elixir lo maneja autom√°ticamente)
nueva = [0 | lista]  
# => [0, 1, 2, 3]

# Concatenar dos listas (crea una nueva lista)
otra = lista ++ [4, 5]  
# => [1, 2, 3, 4, 5]

# Quitar elementos (tambi√©n crea una nueva lista)
menos = lista -- [2]   
# => [1, 3]

# La lista original sigue igual
lista
# => [1, 2, 3]
```

## Tuplas

Una **tupla** es similar a una lista, pero a diferencia de las listas, las tuplas son de tama√±o fijo y se definen utilizando llaves `{}`. Las tuplas son √∫tiles para agrupar datos relacionados. Por ejemplo:

```elixir
mi_tupla = {1, "hola", :atom}
```

Las tuplas se usan com√∫nmente para **devolver m√∫ltiples valores** de una funci√≥n (como `{:ok, value}` o `{:error, reason}`) o para agrupar datos relacionados de manera estructurada.

El **Pattern Matching** es extremadamente √∫til con las tuplas para desestructurar sus valores y asignarlos a variables.

```elixir
# Tupla original
persona = {"Ana", 25, "M√©xico"}

# Desestructurar la tupla usando Pattern Matching
{nombre, edad, pais} = persona

IO.puts("Nombre: #{nombre}") # => Nombre: Ana
IO.puts("Edad: #{edad}")     # => Edad: 25
IO.puts("Pa√≠s: #{pais}")     # => Pa√≠s: M√©xico

# Ejemplo de Pattern Matching en asignaci√≥n
{estado, valor} = {:ok, "√âxito"}
IO.puts("Estado: #{estado}, Valor: #{valor}") # => Estado: ok, Valor: √âxito

# Si el Pattern Matching falla, se produce un error
# {estado, valor} = {:error, "Fallo"} # ** (MatchError) no match of right hand side value: {:error, "Fallo"}

# Podemos usar el operador _ para ignorar valores que no nos interesan
{_, edad, _} = persona
IO.puts("Edad sin desestructurar todo: #{edad}") # => Edad sin desestructurar todo: 25
```

Otras operaciones comunes con tuplas incluyen:

```elixir
# Tupla original
persona = {"Ana", 25, "M√©xico"}

# Tama√±o de la tupla
tuple_size(persona)  # => 3

# Acceder por √≠ndice
elem(persona, 0)   # => "Ana"
elem(persona, 1)   # => 25
```

## Mapas

Un **mapa** es una colecci√≥n de **pares clave-valor**, donde cada clave es √∫nica. Los mapas se definen utilizando `%{}` y los pares se separan por comas. Por ejemplo:

```elixir
mi_mapa = %{"nombre" => "Juan", "edad" => 30, "ciudad" => "Armenia"}
```

Una forma m√°s concisa de definir un mapa es utilizando la sintaxis de clave: valor, donde las claves son √°tomos. Por ejemplo:

```elixir
mi_mapa = %{nombre: "Juan", edad: 30, ciudad: "Armenia"}
```

La utilidad de los mapas radica en su capacidad para asociar valores a claves, lo que permite un acceso r√°pido y eficiente a los datos. B√°sicamente, los mapas son ideales para representar "objetos" o "registros" con atributos y valores. Cada valor puede ser de cualquier tipo de dato, incluyendo listas, tuplas y otros mapas.

El **Pattern Matching** es una herramienta poderosa para extraer valores de los mapas de forma concisa y tambi√©n para definir comportamientos diferentes en funciones.

```elixir
# Mapa original
usuario = %{nombre: "Carlos", edad: 30, ciudad: "Armenia"}

# Acceder a los valores usando pattern matching (desestructuraci√≥n)
%{nombre: nombre_usuario, edad: edad_usuario} = usuario

IO.puts("Nombre: #{nombre_usuario}") # => Nombre: Carlos
IO.puts("Edad: #{edad_usuario}")     # => Edad: 30

# El orden de las claves no importa en el Pattern Matching de mapas
%{edad: edad, nombre: nombre} = usuario
IO.puts("Nombre (orden diferente): #{nombre}") # => Nombre (orden diferente): Carlos

# Se pueden ignorar claves no deseadas con el operador _
%{nombre: nombre, edad: _, ciudad: _} = usuario
IO.puts("Solo el nombre: #{nombre}") # => Solo el nombre: Carlos

# Tambi√©n es posible hacer Pattern Matching en par√°metros de funci√≥n
def es_mayor_de_edad?(%{edad: edad}) when edad >= 18, do: true
def es_mayor_de_edad?(_), do: false

IO.puts("¬øEs Carlos mayor de edad? #{es_mayor_de_edad?(usuario)}") # => ¬øEs Carlos mayor de edad? true
IO.puts("¬øEs un menor de edad? #{es_mayor_de_edad?(%{edad: 16})}") # => ¬øEs un menor de edad? false
```

Otras operaciones comunes con mapas incluyen:

```elixir
# Mapa original
usuario = %{nombre: "Carlos", edad: 30}

# Acceso por clave
usuario.nombre  # => "Carlos" 
usuario[:nombre]  # => "Carlos"

# Actualizar un valor en el mapa (siempre crea un nuevo mapa)
mayor = %{usuario | edad: 31}
# => %{nombre: "Carlos", edad: 31}

# El mapa original sigue igual
usuario
# => %{nombre: "Carlos", edad: 30}
```

Un uso com√∫n de los mapas es guardar informaci√≥n de tal manera que se pueda acceder f√°cilmente a los datos mediante claves descriptivas, como por ejemplo la c√©dula de una persona, el ID de un producto, etc.

Ejemplo: Supongamos que queremos guardar informaci√≥n de personas que compran en una tienda, usando su c√©dula como clave en un mapa. El mapa podr√≠a verse as√≠:

```elixir
# Mapa con informaci√≥n de personas usando c√©dula como clave
personas = %{
  "123456789" => %{nombre: "Ana", edad: 28},
  "987654321" => %{nombre: "Luis", edad: 35}
}
```

Al buscar una persona por su c√©dula, se puede acceder r√°pidamente a su informaci√≥n, es una forma eficiente de organizar y recuperar datos.

Para m√°s informaci√≥n sobre las estructuras de datos en Elixir se puede consultar en:

- [Documentaci√≥n listas y tuplas](https://hexdocs.pm/elixir/lists-and-tuples.html)
- [Documentaci√≥n mapas](https://hexdocs.pm/elixir/Map.html)

---

# M√≥dulos para manipular Colecciones

Elixir proporciona varios m√≥dulos principales para trabajar con colecciones: `List`, `Map` y `Enum`. Estos m√≥dulos ofrecen funciones para manipular listas y otras estructuras de datos de manera eficiente.

Todas las funciones en Elixir que operan sobre colecciones son **funciones puras**. Esto significa que:

1.  Dada la misma entrada, siempre producir√°n la misma salida.
2.  No tienen efectos secundarios (como modificar datos fuera de su √°mbito o realizar operaciones de E/S inesperadas).

Esto es fundamental en la programaci√≥n funcional y garantiza que las operaciones sobre colecciones sean predecibles y seguras.

## M√≥dulo List y Map

El m√≥dulo `List` se centra en operaciones espec√≠ficas para **listas**. Algunas funciones √∫tiles incluyen:

- `first/1`: Devuelve el primer elemento de una lista.
- `last/1`: Devuelve el √∫ltimo elemento de una lista.
- `delete/2`: Elimina la primera ocurrencia de un elemento en una lista.
- `delete_at/2`: Elimina un elemento en una posici√≥n espec√≠fica de la lista.
- `insert_at/3`: Inserta un elemento en una posici√≥n espec√≠fica de la lista.
- `replace_at/3`: Reemplaza un elemento en una posici√≥n espec√≠fica de la lista.

Por otro lado, el m√≥dulo `Map` se utiliza para trabajar con **mapas**. Algunas funciones √∫tiles incluyen:

- `get/2`: Obtiene el valor asociado a una clave en un mapa.
- `put/3`: Agrega o actualiza una clave en un mapa.
- `delete/2`: Elimina una clave de un mapa.
- `keys/1`: Devuelve una lista con todas las claves de un mapa.
- `values/1`: Devuelve una lista con todos los valores de un mapa.
- `merge/2`: Combina dos mapas.

## M√≥dulo Enum

El m√≥dulo `Enum` es m√°s general y se puede utilizar con **cualquier colecci√≥n enumerable**, no solo listas. Este m√≥dulo es el que m√°s se utiliza para trabajar con colecciones. Algunas funciones √∫tiles incluyen:

- `map/2`: Aplica una funci√≥n a cada elemento de la colecci√≥n y devuelve una nueva colecci√≥n con los resultados.
- `filter/2`: Filtra los elementos de la colecci√≥n seg√∫n una funci√≥n de predicado.
- `reduce/3`: Reduce la colecci√≥n a un solo valor utilizando una funci√≥n acumuladora.
- `each/2`: Aplica una funci√≥n a cada elemento de la colecci√≥n sin devolver un resultado. Itera sobre cada elemento.
- `reverse/1`: Invierte el orden de los elementos en la colecci√≥n.
- `count/1`: Devuelve el n√∫mero de elementos en la colecci√≥n.
- `count/2`: Cuenta el n√∫mero de elementos que cumplen con una condici√≥n.
- `member?/2`: Verifica si un elemento est√° presente en la colecci√≥n.
- `sort/1`: Ordena los elementos de la colecci√≥n.
- `sort_by/2`: Ordena los elementos de la colecci√≥n seg√∫n una funci√≥n.
- `min/1` y `max/1`: Devuelve el valor m√≠nimo o m√°ximo de la colecci√≥n.
- `group_by/2`: Agrupa los elementos de la colecci√≥n seg√∫n una funci√≥n.

> üí° **Nota**: M√°s adelante usaremos algunas de estas funciones, pero es recomendable familiarizarse con la documentaci√≥n oficial para explorar todas las posibilidades que ofrecen.

## Map, Filter, Reduce: Los pilares de la Programaci√≥n Funcional

Tres de las funciones m√°s comunes y poderosas del m√≥dulo `Enum` son `map/2`, `filter/2` y `reduce/3`. Estas funciones permiten transformar, filtrar y acumular datos en colecciones de manera eficiente.

### Map

La funci√≥n `Enum.map/2` la podemos explicar con el siguiente diagrama:

<div class="mermaid" style="text-align: center;">
flowchart TD
    subgraph Transform["Transformaciones"]
        direction LR
        F1["f(1) = 1*1 = 1"] --- F2["f(2) = 2*2 = 4"]
        F2 --- F3["f(3) = 3*3 = 9"]
        F3 --- F4["f(4) = 4*4 = 16"]
        F4 --- F5["f(5) = 5*5 = 25"]
    end

    %% nodos externos
    Input["Lista Original<br/>[1, 2, 3, 4, 5]"]
    Code["Enum.map(list, fn x -> x * x end)"]
    Output["Lista Transformada<br/>[1, 4, 9, 16, 25]"]

    %% enlaces externos (estos quedan despu√©s en la cuenta de links)
    Input --> Code
    Code --> Transform
    Transform --> Output

    %% estilos nodos
    style Input fill:#e3f2fd
    style Code fill:#f3e5f5
    style Output fill:#e8f5e8
    style F1 fill:#fff3e0
    style F2 fill:#fff3e0
    style F3 fill:#fff3e0
    style F4 fill:#fff3e0
    style F5 fill:#fff3e0

    linkStyle 0,1,2,3 stroke-width:0px,stroke-opacity:0,opacity:0
</div>

Al aplicar la funci√≥n `f(x) = x * x` a cada elemento de la lista original, obtenemos una nueva lista con los resultados de la funci√≥n aplicada a cada elemento.

### Filter

La funci√≥n `Enum.filter/2` la podemos explicar con el siguiente diagrama:

<div class="mermaid" style="text-align: center;">
flowchart TD
    Input["Lista Original<br/>[10, 15, 8, 23, 4, 17, 12]"]

    Code["Enum.filter(list, fn x -> x > 10 end)"]
    
    %% subgraph con conexiones internas primero
    subgraph Filter["Filtros"]
        direction LR
        C1["10 > 10? ‚ùå<br/>Descartado"] --- C2["15 > 10? ‚úÖ<br/>Incluido"]
        C2 --- C3["8 > 10? ‚ùå<br/>Descartado"]
        C3 --- C4["23 > 10? ‚úÖ<br/>Incluido"] 
        C4 --- C5["4 > 10? ‚ùå<br/>Descartado"]
        C5 --- C6["17 > 10? ‚úÖ<br/>Incluido"]
        C6 --- C7["12 > 10? ‚úÖ<br/>Incluido"]
    end
    
    Output["Lista Filtrada<br/>[15, 23, 17, 12]"]
    
    %% enlaces externos
    Input --> Code
    Code --> Filter
    Filter --> Output
    
    %% estilos
    style Input fill:#e3f2fd
    style Code fill:#f3e5f5
    style Output fill:#e8f5e8
    style C1 fill:#ffebee
    style C2 fill:#e8f5e8
    style C3 fill:#ffebee
    style C4 fill:#e8f5e8
    style C5 fill:#ffebee
    style C6 fill:#e8f5e8
    style C7 fill:#e8f5e8

    linkStyle 0,1,2,3,4,5 stroke-width:0px,stroke-opacity:0,opacity:0
</div>

Al aplicar el filtro `x > 10`, obtenemos una nueva lista que solo contiene los elementos que cumplen con esta condici√≥n.

### Reduce

La funci√≥n `Enum.reduce/3` la podemos explicar con el siguiente diagrama:

<div class="mermaid" style="text-align: center;">
graph LR
    Input["Lista Original<br/>[2, 4, 6, 8]"]
    Acc0["Acumulador Inicial<br/>acc = 0"]
    
    subgraph Reduce["Enum.reduce(list, 0, fn x, acc -> acc + x end)"]
        Step1["Paso 1:<br/>x=2, acc=0<br/>0 + 2 = 2"]
        Step2["Paso 2:<br/>x=4, acc=2<br/>2 + 4 = 6"] 
        Step3["Paso 3:<br/>x=6, acc=6<br/>6 + 6 = 12"]
        Step4["Paso 4:<br/>x=8, acc=12<br/>12 + 8 = 20"]
    end
    
    Output["Resultado Final<br/>20"]
    
    Input --> Reduce
    Acc0 --> Step1
    Step1 --> Step2
    Step2 --> Step3 
    Step3 --> Step4
    Step4 --> Output
    
    style Input fill:#e3f2fd
    style Acc0 fill:#f3e5f5
    style Output fill:#e8f5e8
    style Step1 fill:#fff3e0
    style Step2 fill:#fff3e0
    style Step3 fill:#fff3e0
    style Step4 fill:#fff3e0
</div>

En este ejemplo, comenzamos con un acumulador inicial de `0` y vamos sumando cada elemento de la lista al acumulador. Al final, obtenemos el resultado total de la suma de todos los elementos. A diferencia de `map` y `filter`, que devuelven una nueva colecci√≥n, `reduce` devuelve un solo valor acumulado.

## ¬øCu√°ndo usar cada colecci√≥n?

Dado que cada tipo de colecci√≥n tiene sus propias caracter√≠sticas y ventajas, es importante saber cu√°ndo usar cada una:

- **Listas**: Son ideales para colecciones de tama√±o variable donde se realizan muchas operaciones de adici√≥n o eliminaci√≥n de elementos. Son √∫tiles cuando el orden de los elementos es importante y se necesita iterar sobre ellos con frecuencia.
- **Tuplas**: Son adecuadas para agrupar un n√∫mero fijo y peque√±o de elementos. Son eficientes en t√©rminos de acceso y uso de memoria, por lo que son ideales para devolver m√∫ltiples valores desde una funci√≥n o para representar registros con un n√∫mero conocido de campos.
- **Mapas**: Son perfectos para colecciones de pares clave-valor. Son ideales para representar datos estructurados, como registros o configuraciones, donde se necesita un acceso r√°pido a los valores mediante claves descriptivas.

---

## Ejercicio 1

Un profesor tiene una lista con las notas finales de sus estudiantes. Cada nota est√° entre 0 y 5. El profesor necesita un programa que le permita calcular ciertas cosas:

- La nota promedio de la clase.
- Contar cu√°ntos estudiantes est√°n por encima y por debajo de la nota promedio. Retorne una tupla con ambos valores.
- Encontrar la nota m√°s alta y la nota m√°s baja.
- Contar cu√°ntos estudiantes aprobaron (`nota >= 3`) y cu√°ntos reprobaron.

### Versi√≥n 1

```elixir
defmodule Estudiantes do
  def main do
    lista = [3, 4, 4.6, 1.6, 2.3, 4.5, 1]

    promedio = calcular_promedio(lista)
    Util.imprimir_mensaje("El promedio es #{promedio}")

    {menores, mayores} = total_segun_promedio(lista, promedio)
    Util.imprimir_mensaje("Hay #{menores} por debajo del promedio y #{mayores} por encima")

    {menor, mayor} = min_max_nota(lista)
    Util.imprimir_mensaje("La nota m√°s baja es #{menor} y la m√°s alta #{mayor}")

    {aprobados, reprobados} = aprobados_reprobados(lista)
    Util.imprimir_mensaje("Aprobaron #{aprobados} estudiantes y reprobaron #{reprobados}")
  end

  defp calcular_promedio(lista), do: Enum.sum(lista) / length(lista)

  defp min_max_nota(lista), do: Enum.min_max(lista)

  defp total_segun_promedio(lista, promedio) do
    menores = Enum.count(lista, &(&1 < promedio))
    mayores = Enum.count(lista, &(&1 > promedio))
    {menores, mayores}
  end

  defp aprobados_reprobados(lista) do
    total = length(lista)
    aprobados = Enum.count(lista, &(&1 >= 3))
    reprobados = total - aprobados
    {aprobados, reprobados}
  end
end

Estudiantes.main()
```

Se define una lista con notas de prueba y sobre ella se realizan diferentes c√°lculos cuyos resultados se imprimen en pantalla. N√≥tese el uso de `Enum` para procesar la colecci√≥n de notas y de tuplas para devolver m√∫ltiples valores desde una funci√≥n.

Cabe destacar que las funciones lambda tambi√©n se pueden escribir usando `fn` y `->`, como se ha mencionado previamente. Por ejemplo, en el caso de la funci√≥n `aprobados_reprobados/1` podemos hacer lo siguiente:

```elixir
aprobados = Enum.count(lista, fn nota -> nota >= 3 end)
```

> **‚ö†Ô∏è Investigar** c√≥mo mejorar la funci√≥n `total_segun_promedio/2` para que no tenga que recorer la lista dos veces. Que halle la cantidad de estudiantes por encima y por debajo del promedio en una sola pasada.

### Versi√≥n 2

Modifique la lista para que no solo contenga las notas, sino tambi√©n el nombre del estudiante correspondiente, debe usar **mapas**. Luego, en el caso de la nota m√°s baja y la m√°s alta, debe mostrar tambi√©n el nombre del estudiante.

```elixir
defmodule Estudiantes do
  def main do
    # Ahora tenemos una lista de mapas
    lista = [
      %{nombre: "pepe", nota: 3},
      %{nombre: "maria", nota: 4},
      %{nombre: "juan", nota: 4.6},
      %{nombre: "luisa", nota: 1.6},
      %{nombre: "carlos", nota: 2.3},
      %{nombre: "ana", nota: 4.5},
      %{nombre: "marcos", nota: 1},
    ]

    promedio = calcular_promedio(lista)
    Util.imprimir_mensaje("El promedio es #{promedio}")

    {menores, mayores} = total_segun_promedio(lista, promedio)
    Util.imprimir_mensaje("Hay #{menores} por debajo del promedio y #{mayores} por encima")

    {menor, mayor} = min_max_nota(lista)
    Util.imprimir_mensaje("La nota m√°s baja es de #{menor.nombre} (#{menor.nota}) y la m√°s alta es de #{mayor.nombre} (#{mayor.nota})")

    {aprobados, reprobados} = aprobados_reprobados(lista)
    Util.imprimir_mensaje("Aprobaron #{aprobados} estudiantes y reprobaron #{reprobados}")

  end

  defp calcular_promedio(lista) do
    Enum.map(lista, &(&1.nota)) # Es necesario extraer la nota de cada estudiante
    |> Enum.sum()
    |> then( &(&1/length(lista)) ) # then() permite encadenar operaciones
  end

  defp min_max_nota(lista) do
    peor = Enum.min_by(lista, &(&1.nota)) # Enum.min_by permite asociar una funci√≥n para acceder a la nota
    mejor = Enum.max_by(lista, &(&1.nota))
    {peor, mejor}
  end

  defp total_segun_promedio(lista, promedio) do
    menores = Enum.count(lista, &(&1.nota < promedio))
    mayores = Enum.count(lista, &(&1.nota > promedio))
    {menores, mayores}
  end

  defp aprobados_reprobados(lista) do
    total = length(lista)
    aprobados = Enum.count(lista, &(&1.nota >= 3))
    {aprobados, total - aprobados}
  end
end

Estudiantes.main()
```

### Versi√≥n 3

Se requiere una nueva funci√≥n que devuelva la lista de estudiantes como una tupla que contenga el nombre del estudiante y su estado (`:aprobado` o `:reprobado`).

```elixir
defp agregar_estado(lista) do
  Enum.map(lista, fn estudiante ->

    estado = cond do
      estudiante.nota >= 3 -> :aprobado
      true -> :reprobado # Cuando no se cumple la condici√≥n anterior
    end

    {estudiante.nombre, estado }
  end)
end
```

Tambi√©n podemos usar **pattern matching** para desestructurar el mapa del estudiante, as√≠:

```elixir
defp agregar_estado(lista) do
  Enum.map(lista, fn %{nombre: nombre, nota: nota} ->

    estado = cond do
      nota >= 3 -> :aprobado
      true -> :reprobado
    end

    {nombre, estado}
  end)
end
```
O tambi√©n as√≠ (usando `&`):

```elixir
defp agregar_estado(lista) do
  Enum.map(lista, &( {&1.nombre, if(&1.nota >= 3, do: :aprobado, else: :reprobado)} ))
end
```

Las tres versiones hacen lo mismo, se recomienda usar la que le resulte m√°s legible.

> **‚ö†Ô∏è Importante:** Para imprimir la lista no podemos usar `IO.puts/1`, ya que esto intentar√≠a convertir la lista de tuplas en una cadena, lo cual no es posible directamente. En su lugar, podemos usar `IO.inspect/1` para imprimir la lista de manera m√°s legible.

### Versi√≥n 4

Se requiere ordenar la lista de estudiantes por su nota de manera descendente, de modo que el estudiante con la nota m√°s alta aparezca primero. En la salida, se debe mostrar el nombre del estudiante junto con su nota.

```elixir
defp ordenar_lista(lista) do
  Enum.sort_by(lista, fn estudiante -> estudiante.nota end, :desc)
end
```

O tambi√©n as√≠ (usando `&`):

```elixir
defp ordenar_lista(lista) do
  Enum.sort_by(lista, &(&1.nota), :desc)
end
```

La funci√≥n `Enum.sort_by/3` permite especificar una funci√≥n para acceder al valor por el cual se desea ordenar (en este caso, la nota) y el orden (`:asc` para ascendente o `:desc` para descendente).

---

## Ejercicio 2

Una tienda en l√≠nea guarda la informaci√≥n de sus productos en una lista de mapas. Cada mapa representa un producto. Cada producto tiene el siguiente formato:

```elixir
%{id: entero, nombre: cadena, precio: n√∫mero, stock: entero, categoria: cadena}
```

Se necesita un programa que haga lo siguiente:

- Calcular el valor total del inventario de la tienda (precio * stock de cada producto).
- Generar una lista solo con los nombres de los productos sin stock (stock == 0).
- Filtrar los productos de la categor√≠a "Accesorios" y mostrarlos ordenados por precio ascendente.
- Encontrar el producto m√°s caro y el m√°s barato, devolviendo ambos como tuplas del tipo: `{:mas_caro, nombre, precio}` y `{:mas_barato, nombre, precio}`.
- Agrupar los productos por categor√≠a (usar `Enum.group_by`).
- Contar cu√°ntos productos hay en cada categor√≠a.
- Calcular el promedio de precios por categor√≠a.

---

## Ejercicio 3

Una biblioteca digital guarda su cat√°logo en una lista de mapas como la siguiente:

```elixir
libros = [
  %{titulo: "El Quijote", autor: "Cervantes", categoria: "novela", disponible: true},
  %{titulo: "Cien a√±os de soledad", autor: "Garc√≠a M√°rquez", categoria: "novela", disponible: false},
  %{titulo: "El Principito", autor: "Saint-Exup√©ry", categoria: "infantil", disponible: true},
  %{titulo: "Clean Code", autor: "Robert C. Martin", categoria: "tecnolog√≠a", disponible: true},
  %{titulo: "El alquimista", autor: "Paulo Coelho", categoria: "novela", disponible: false},
  %{titulo: "El coronel no tiene quien le escriba", autor: "Garc√≠a M√°rquez", categoria: "novela", disponible: false},
]
```

Se necesita un programa que permita:
- Filtrar los libros que est√°n disponibles para pr√©stamo.
- Generar una lista de t√≠tulos de todos los libros en una categor√≠a dada (por ejemplo "novela").
- Listar los autores √∫nicos que hay en el cat√°logo.
- Ordenar la lista de libros alfab√©ticamente por t√≠tulo.
- Crear un mapa de disponibilidad donde la clave sea el t√≠tulo y el valor un booleano (true/false).
- Contar cuantos libros hay por categor√≠a.

---

## Ejercicio 4

Supongamos que trabajamos con esta lista de productos:

```elixir
productos = [
  %{nombre: "Manzana", categoria: "Fruta", precio: 3000},
  %{nombre: "Pera", categoria: "Fruta", precio: 2500},
  %{nombre: "Zanahoria", categoria: "Verdura", precio: 1800},
  %{nombre: "Lechuga", categoria: "Verdura", precio: 2000},
  %{nombre: "Pollo", categoria: "Carne", precio: 8000},
  %{nombre: "Res", categoria: "Carne", precio: 10000}
]
```

Se requieren las siguientes operaciones:

- **Lista de categor√≠as √∫nicas:** Obtener todas las categor√≠as sin repetir.
- **Agrupar nombres por categor√≠a:** Crear un mapa donde cada clave sea una categor√≠a y el valor sea la lista de nombres de productos de esa categor√≠a.
- **Producto m√°s caro:** Encontrar el producto con mayor precio.
- **Suma total de precios:** Calcular cu√°nto cuestan todos los productos juntos.
- **Promedio de precios por categor√≠a:** Obtener el precio promedio de los productos en cada categor√≠a.
- **Filtrar productos econ√≥micos:** Crear una lista con los productos cuyo precio sea menor a 3000.
- **Convertir nombres a may√∫sculas y ordenarlos:** Generar una lista de nombres en may√∫scula, ordenada alfab√©ticamente.
- **Separar frutas y no frutas:** Dividir la lista en dos: frutas y los dem√°s productos.
- **Verificar si todos los productos tienen precio mayor que 1000:** Devolver `true` o `false`.
- **Mapear categor√≠as con la cantidad de letras en sus productos:** Crear un mapa donde la clave sea la categor√≠a y el valor sea la suma de la longitud de los nombres de los productos de esa categor√≠a.

---

## Para la pr√≥xima clase

- Investigar sobre recursividad, qu√© es y c√≥mo se utiliza en Elixir.
- Por qu√© la recursividad es importante en la programaci√≥n funcional.
- Ejemplos de problemas que se pueden resolver de manera m√°s eficiente utilizando recursividad.