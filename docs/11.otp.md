```
Universidad del Quind√≠o
Programa de Ingenier√≠a de Sistemas y Computaci√≥n
Programaci√≥n III - OTP (Open Telecom Platform)
Docente: Carlos Andr√©s Florez V.
```

# Introducci√≥n a OTP

Antes de entrar en detalles sobre OTP, es importante entender el concepto de **Agentes** en Elixir, ya que son una forma sencilla de manejar el estado compartido y mutable en aplicaciones concurrentes.

# Agent

El m√≥dulo `Agent` en Elixir proporciona una forma sencilla de crear y manejar procesos que mantienen un estado compartido. Los agentes son √∫tiles cuando se necesita un proceso que almacene y gestione un estado mutable de manera concurrente. El m√≥dulo `Agent` ofrece una interfaz simple para crear, actualizar y leer el estado del agente. Entre las funciones m√°s comunes del m√≥dulo `Agent` se encuentran:

- `Agent.start_link/2`: Inicia un nuevo agente con un estado inicial.
- `Agent.get/2`: Obtiene el estado actual del agente.
- `Agent.update/2`: Actualiza el estado del agente utilizando una funci√≥n.
- `Agent.get_and_update/2`: Obtiene y actualiza el estado del agente en una sola operaci√≥n.
- `Agent.stop/1`: Detiene el agente.

En el proyecto que hicimos previamente (Gimnasio), podemos usar un `Agent` para mantener el estado del gimnasio y su mapa de miembros. Para esto, podemos escribir lo siguiente:

```elixir
defmodule Gimnasio do

  use Agent # Importar el m√≥dulo Agent

  def start_link do
    # Iniciar el agente con un mapa vac√≠o como estado inicial
    Agent.start_link(fn -> %{} end, name: __MODULE__)
  end

  defp agregar_socio(cedula, socio) do
    # Agregar un nuevo socio al mapa, actualizando el estado del agente
    Agent.update(__MODULE__, fn socios -> Map.put(socios, cedula, socio) end)
  end

  defp obtener_socio(cedula) do
    # Obtener un socio del mapa por su c√©dula
    Agent.get(__MODULE__, fn socios -> Map.get(socios, cedula) end)
  end

  defp eliminar_socio(cedula) do
    # Eliminar un socio del mapa por su c√©dula
    Agent.update(__MODULE__, fn socios -> Map.delete(socios, cedula) end)
  end

  defp listar_socios do
    # Listar todos los socios en el mapa
    Agent.get(__MODULE__, fn socios -> socios end)
  end

  defp inscribir_clase(cedula, clase) do
    # Se actualiza el estado del agente para inscribir una clase a un socio
    Agent.update(__MODULE__, fn socios ->
      case Map.get(socios, cedula) do
        nil -> socios  # Si el socio no existe, no hacer nada
        socio ->
          actualizado = %{socio | clases: [clase | socio.clases]}
          Map.put(socios, cedula, actualizado)
      end
    end)
  end

  def main do
    start_link() # Iniciar el agente (es importante hacerlo antes de usarlo)

    agregar_socio("123", %Socio{nombre: "Juan", edad: 30, clases: []})
    agregar_socio("456", %Socio{nombre: "Ana", edad: 25, clases: []})

    IO.inspect(obtener_socio("123"))
    IO.inspect(listar_socios())

    inscribir_clase("123", "Yoga")
    IO.inspect(obtener_socio("123"))

    eliminar_socio("456")
    IO.inspect(listar_socios())
  end
  
end

Gimnasio.main()
```

Dado que el `Agent` maneja su propio proceso, no es necesario preocuparse por la concurrencia al acceder o modificar el estado del gimnasio. El `Agent` se encarga de sincronizar el acceso al estado interno, lo que facilita la implementaci√≥n de aplicaciones concurrentes. Adem√°s, **no es necesario pasar el mapa de socios** entre funciones, ya que el `Agent` mantiene el estado internamente. 

Elixir facilita el manejo del estado compartido y mutable mediante el uso de agentes, lo que permite construir aplicaciones concurrentes de manera m√°s sencilla y segura.

Para m√°s informaci√≥n sobre el m√≥dulo `Agent`, puedes consultar la [documentaci√≥n oficial](https://hexdocs.pm/elixir/1.12/Agent.html).

---

# OTP (Open Telecom Platform)

En elixir, OTP (Open Telecom Platform) es un conjunto de bibliotecas y herramientas que facilitan la construcci√≥n de aplicaciones concurrentes, distribuidas y tolerantes a fallos. OTP proporciona una serie de comportamientos (behaviours) predefinidos que ayudan a estructurar el c√≥digo y manejar tareas comunes en sistemas concurrentes. 

Algunos de los componentes clave de OTP incluyen:

- **GenServer**: Un comportamiento que facilita la creaci√≥n de servidores gen√©ricos. Permite manejar llamadas s√≠ncronas y as√≠ncronas, mantener estado y gestionar la concurrencia de manera sencilla.
- **Supervisor**: Un comportamiento que supervisa otros procesos (como GenServers) y los reinicia autom√°ticamente en caso de fallos. Esto ayuda a construir sistemas tolerantes a fallos.
- **Arbol de Supervisi√≥n**: Una estructura jer√°rquica de supervisores que permite organizar y gestionar m√∫ltiples procesos y supervisores de manera eficiente.

## GenServer

GenServer (Generic Server) es un comportamiento en OTP que facilita la creaci√≥n de servidores gen√©ricos. Proporciona una interfaz para manejar llamadas s√≠ncronas y as√≠ncronas, mantener estado y gestionar la concurrencia.

### Ejemplo de uso

A continuaci√≥n se muestra un ejemplo b√°sico de c√≥mo implementar un GenServer en Elixir:

```elixir
defmodule MiGenServer do
  use GenServer

  # Callback para iniciar el GenServer
  def start_link(initial_state) do
    # Registrar el GenServer con un nombre. Similar a Agent ya que maneja su propio proceso y estado
    GenServer.start_link(__MODULE__, initial_state, name: __MODULE__) 
  end

  # Callback para manejar la inicializaci√≥n
  def init(initial_state) do
    {:ok, initial_state}
  end

  # Callback para manejar llamadas s√≠ncronas
  def handle_call(:get_state, _from, state) do
    {:reply, state, state}
  end

  # Callback para manejar mensajes as√≠ncronos
  def handle_cast({:set_state, new_state}, _old_state) do
    {:noreply, new_state}
  end
end
```

En este ejemplo, `MiGenServer` es un GenServer simple que mantiene un estado interno. Proporciona una llamada s√≠ncrona para obtener el estado y una llamada as√≠ncrona para establecer un nuevo estado.

La diferencia entre `handle_call` y `handle_cast` es que el primero es para **llamadas s√≠ncronas** (el cliente espera una respuesta), mientras que el segundo es para **mensajes as√≠ncronos** (el cliente no espera una respuesta).

Ambos pueden modificar el estado del servidor, pero en la pr√°ctica, `handle_call` suele usarse para leer o devolver informaci√≥n, y `handle_cast` para actualizar el estado sin necesidad de respuesta inmediata.

Para m√°s informaci√≥n sobre GenServer, se recomienda consultar la [documentaci√≥n oficial](https://hexdocs.pm/elixir/1.12/GenServer.html).

### Diferencias entre Agent y GenServer

La diferencia principal entre `Agent` y `GenServer` es que `GenServer` ofrece una mayor flexibilidad y control sobre el manejo de mensajes y el ciclo de vida del proceso. Mientras que `Agent` est√° dise√±ado para casos simples de manejo de estado, `GenServer` es m√°s adecuado para aplicaciones m√°s complejas que requieren l√≥gica personalizada para manejar diferentes tipos de mensajes y estados.

En la siguiente tabla se resumen las diferencias clave entre `Agent` y `GenServer`:

| Caracter√≠stica      | **Agent**                             | **GenServer**                                                       |
| ------------------- | ------------------------------------- | ------------------------------------------------------------------- |
| Complejidad         | Simple                                | Complejo                                                            |
| Prop√≥sito principal | Almacenar y actualizar estado         | Controlar la comunicaci√≥n y la l√≥gica del proceso                   |
| Manejo de mensajes  | Autom√°tico (transparente)             | Manual (`handle_call`, `handle_cast`, etc.)                         |
| Ideal para          | Contadores, cach√©s, datos compartidos | Servidores, coordinadores, procesos con m√∫ltiples tipos de mensajes |
| Flexibilidad        | Limitada                              | Muy alta                                                            |


---

## Ejemplo 1

Se requiere crear un sistema de gesti√≥n de tareas donde los usuarios pueden agregar, eliminar y listar tareas. Cada tarea tiene un t√≠tulo y una descripci√≥n. El sistema debe manejar m√∫ltiples usuarios y sus respectivas listas de tareas. Debe usar `GenServer` como servidor para manejar las tareas de cada usuario.

En este caso, se quiere tener un servidor y m√∫ltiples clientes que se conecten a este servidor para gestionar sus tareas. A continuaci√≥n, se muestra c√≥mo se puede implementar esto utilizando `GenServer` y la funcionalidad de distribuci√≥n de Elixir.

### 1. Crear la estructura de la tarea

Cree un archivo llamado `tareas.exs` y defina la estructura de una tarea:

```elixir
# Definici√≥n de la estructura de una tarea
defmodule Tarea do
  defstruct [:titulo, :descripcion]
end
```

Puede compilar el c√≥digo anterior usando `elixirc tareas.exs` en la terminal para que est√© disponible en el entorno de Elixir y pueda ser utilizado en los siguientes pasos.

### 2. Crear el servidor

Cree un nuevo archivo llamado `server.exs` y defina el servidor de tareas utilizando `GenServer`:

```elixir
# M√≥dulo del servidor de tareas
defmodule TareasServidor do
  use GenServer

  # Iniciar el GenServer con un estado inicial vac√≠o
  def start_link(_) do
    GenServer.start_link(__MODULE__, %{}, name: __MODULE__)
  end

  def init(state) do
    {:ok, state}
  end

  # Manejar la adici√≥n de una tarea
  def handle_cast({:agregar_tarea, usuario, tarea}, state) do
    tareas_usuario = Map.get(state, usuario, [])
    nuevas_tareas = [tarea | tareas_usuario]
    nuevo_estado = Map.put(state, usuario, nuevas_tareas)
    {:noreply, nuevo_estado}
  end

  # Manejar la eliminaci√≥n de una tarea
  def handle_cast({:eliminar_tarea, usuario, titulo}, state) do
    tareas_usuario = Map.get(state, usuario, [])
    nuevas_tareas = Enum.filter(tareas_usuario, fn %Tarea{titulo: t} -> t != titulo end)
    nuevo_estado = Map.put(state, usuario, nuevas_tareas)
    {:noreply, nuevo_estado}
  end

  # Manejar la solicitud de listar tareas
  def handle_call({:listar_tareas, usuario}, _from, state) do
    tareas_usuario = Map.get(state, usuario, [])
    {:reply, tareas_usuario, state}
  end
end
```

El servidor `TareasServidor` mantiene un estado que es un mapa donde las claves son los nombres de usuario y los valores son listas de tareas. Proporciona funciones para agregar, eliminar y listar tareas. 

Dado que el servidor maneja su propio proceso, no es necesario preocuparse por la concurrencia al acceder o modificar el estado interno.

Adem√°s, el servidor puede ser iniciado en un nodo de Elixir, lo que permite que otros nodos (clientes) se conecten a √©l para gestionar sus tareas.

### 3. Crear el cliente

Cree un nuevo archivo llamado `client.exs` y defina el cliente de tareas utilizando `GenServer`:

```elixir
# M√≥dulo del cliente
defmodule TareasCliente do
  use GenServer

  # Conectar al servidor de tareas
  def start_link(server_node) do
    GenServer.start_link(__MODULE__, server_node, name: __MODULE__)
  end

  def init(server_node) do
    {:ok, server_node}
  end

  # Agregar una tarea al servidor
  def agregar_tarea(usuario, %Tarea{} = tarea) do
    GenServer.cast(__MODULE__, {:agregar_tarea, usuario, tarea})
  end

  # Eliminar una tarea del servidor
  def eliminar_tarea(usuario, titulo) do
    GenServer.cast(__MODULE__, {:eliminar_tarea, usuario, titulo})
  end

  # Listar las tareas del servidor
  def listar_tareas(usuario) do
    GenServer.call(__MODULE__, {:listar_tareas, usuario})
  end 

  # Manejar la adici√≥n de una tarea
  def handle_cast({:agregar_tarea, usuario, tarea}, server_node) do
    GenServer.cast({TareasServidor, server_node}, {:agregar_tarea, usuario, tarea})
    {:noreply, server_node}
  end

  # Manejar la eliminaci√≥n de una tarea
  def handle_cast({:eliminar_tarea, usuario, titulo}, server_node) do
    GenServer.cast({TareasServidor, server_node}, {:eliminar_tarea, usuario, titulo})
    {:noreply, server_node}
  end

  # Manejar la solicitud de listar tareas
  def handle_call({:listar_tareas, usuario}, _from, server_node) do
    tareas = GenServer.call({TareasServidor, server_node}, {:listar_tareas, usuario})
    {:reply, tareas, server_node}
  end
end
```

El cliente `TareasCliente` se conecta al servidor de tareas en un nodo espec√≠fico. Proporciona funciones para agregar, eliminar y listar tareas, que internamente env√≠an mensajes al servidor. Este cliente tambi√©n maneja su propio proceso, lo que permite que m√∫ltiples clientes se conecten al mismo servidor de manera concurrente.

### 4. Configuraci√≥n de nodos

Para probar la funcionalidad distribuida, es necesario iniciar dos nodos de Elixir. En uno de los nodos, se ejecuta el servidor de tareas, y en el otro nodo, se ejecuta el cliente que se conecta al servidor. Aseg√∫rese de que ambos nodos puedan comunicarse entre s√≠.

En el m√≥dulo `TareasServidor`, puede agregar una funci√≥n `main` para iniciar el servidor:

```elixir
def main do
  # Iniciar el servidor de tareas
  {:ok, _} = TareasServidor.start_link()
  IO.puts("üöÄ Servidor de tareas iniciado")

  # Mantener el proceso principal vivo
  Process.sleep(:infinity)
end
```

No olvide llamar a `TareasServidor.main()` al final del archivo `server.exs` para iniciar el servidor cuando se ejecute el archivo.

En el m√≥dulo `TareasCliente`, puede agregar una funci√≥n `main` para iniciar el cliente y conectarse al servidor:

```elixir
def main do
  # Nombre del nodo servidor (ajustar seg√∫n sea necesario)
  server_node = :'servidor@tu_maquina'

  IO.puts("‚úÖ Nodo cliente iniciado")

  # Conectarse al servidor y arrancar el cliente
  {:ok, _pid} = start_link(server_node)

  # ====== Ejemplo autom√°tico de uso ======
  agregar_tarea("usuario1", %Tarea{titulo: "Comprar leche", descripcion: "Ir al supermercado"})
  agregar_tarea("usuario1", %Tarea{titulo: "Estudiar Elixir", descripcion: "Leer la gu√≠a oficial"})
  IO.inspect(listar_tareas("usuario1"))
end
```

No olvide llamar a `TareasCliente.main()` al final del archivo `client.exs` para iniciar el cliente cuando se ejecute el archivo.

> ‚ö†Ô∏è **Importante**: Aseg√∫rese de ajustar el nombre del nodo del servidor en el archivo `client.exs` para que coincida con el nombre utilizado al iniciar el nodo del servidor. Puede usar `Node.self()` en el servidor para verificar el nombre del nodo.

### 5. Ejecutar los nodos

Para ejecutar los nodos, abra dos terminales. En la primera terminal, inicie el nodo del servidor:

```bash
elixir --sname servidor --cookie mi_cookie server.exs
```

En la segunda terminal, inicie el nodo del cliente:

```bash
elixir --sname cliente --cookie mi_cookie client.exs
```

Al ejecutar ambos nodos, el cliente se conectar√° al servidor y podr√° agregar, eliminar y listar tareas de manera distribuida.

### 6. Probar con varios clientes

Puede abrir m√°s terminales y ejecutar m√°s instancias del cliente para simular m√∫ltiples usuarios conect√°ndose al mismo servidor. Cada cliente podr√° gestionar sus propias tareas de manera independiente.

Si cuenta con varias m√°quinas en la misma red, puede iniciar el servidor en una m√°quina y los clientes en otras, asegur√°ndose de que todos los nodos puedan comunicarse entre s√≠.

Incluso, si un cliente falla o se desconecta, el servidor seguir√° funcionando y manteniendo el estado de las tareas de los dem√°s usuarios, gracias a la naturaleza tolerante a fallos de OTP.

---

## Para la pr√≥xima clase

- Investigue sobre Supervisores en OTP y c√≥mo se utilizan para gestionar la recuperaci√≥n de procesos en caso de fallos.
- Qu√© es Mix y c√≥mo se utiliza para gestionar proyectos en Elixir.
- Investigue y lea c√≥mo hace elixir para manejar la concurrencia y el paralelismo.



