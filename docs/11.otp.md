```
Universidad del Quindío
Programa de Ingeniería de Sistemas y Computación
Programación III - OTP (Open Telecom Platform)
Docente: Carlos Andrés Florez V.
```

# Introducción a OTP

Antes de entrar en detalles sobre OTP, es importante entender el concepto de **Agentes** en Elixir, ya que son una forma sencilla de manejar el estado compartido y mutable en aplicaciones concurrentes.

# Agent

El módulo `Agent` en Elixir proporciona una forma sencilla de crear y manejar procesos que mantienen un estado compartido. Los agentes son útiles cuando se necesita un proceso que almacene y gestione un estado mutable de manera concurrente. El módulo `Agent` ofrece una interfaz simple para crear, actualizar y leer el estado del agente. Entre las funciones más comunes del módulo `Agent` se encuentran:

- `Agent.start_link/2`: Inicia un nuevo agente con un estado inicial.
- `Agent.get/2`: Obtiene el estado actual del agente.
- `Agent.update/2`: Actualiza el estado del agente utilizando una función.
- `Agent.get_and_update/2`: Obtiene y actualiza el estado del agente en una sola operación.
- `Agent.stop/1`: Detiene el agente.

En el proyecto que hicimos previamente (Gimnasio), podemos usar un `Agent` para mantener el estado del gimnasio y su mapa de miembros. Para esto, podemos escribir lo siguiente:

```elixir
defmodule Gimnasio do

  use Agent # Importar el módulo Agent

  def start_link do
    # Iniciar el agente con un mapa vacío como estado inicial
    Agent.start_link(fn -> %{} end, name: __MODULE__)
  end

  defp agregar_socio(cedula, socio) do
    # Agregar un nuevo socio al mapa, actualizando el estado del agente
    Agent.update(__MODULE__, fn socios -> Map.put(socios, cedula, socio) end)
  end

  defp obtener_socio(cedula) do
    # Obtener un socio del mapa por su cédula
    Agent.get(__MODULE__, fn socios -> Map.get(socios, cedula) end)
  end

  defp eliminar_socio(cedula) do
    # Eliminar un socio del mapa por su cédula
    Agent.update(__MODULE__, fn socios -> Map.delete(socios, cedula) end)
  end

  defp listar_socios do
    # Listar todos los socios en el mapa
    Agent.get(__MODULE__, fn socios -> socios end)
  end

  defp inscribir_clase(cedula, clase) do
    # Se actualiza el estado del agente para inscribir una clase a un socio
    Agent.update(__MODULE__, fn socios ->
      case Map.get(socios, cedula) do
        nil -> socios  # Si el socio no existe, no hacer nada
        socio ->
          actualizado = %{socio | clases: [clase | socio.clases]}
          Map.put(socios, cedula, actualizado)
      end
    end)
  end

  def main do
    start_link() # Iniciar el agente (es importante hacerlo antes de usarlo)

    agregar_socio("123", %Socio{nombre: "Juan", edad: 30, clases: []})
    agregar_socio("456", %Socio{nombre: "Ana", edad: 25, clases: []})

    IO.inspect(obtener_socio("123"))
    IO.inspect(listar_socios())

    inscribir_clase("123", "Yoga")
    IO.inspect(obtener_socio("123"))

    eliminar_socio("456")
    IO.inspect(listar_socios())
  end
  
end

Gimnasio.main()
```

Dado que el `Agent` maneja su propio proceso, no es necesario preocuparse por la concurrencia al acceder o modificar el estado del gimnasio. El `Agent` se encarga de sincronizar el acceso al estado interno, lo que facilita la implementación de aplicaciones concurrentes. Además, **no es necesario pasar el mapa de socios** entre funciones, ya que el `Agent` mantiene el estado internamente. 

Elixir facilita el manejo del estado compartido y mutable mediante el uso de agentes, lo que permite construir aplicaciones concurrentes de manera más sencilla y segura.

Para más información sobre el módulo `Agent`, puedes consultar la [documentación oficial](https://hexdocs.pm/elixir/1.12/Agent.html).

---

# OTP (Open Telecom Platform)

En elixir, OTP (Open Telecom Platform) es un conjunto de bibliotecas y herramientas que facilitan la construcción de aplicaciones concurrentes, distribuidas y tolerantes a fallos. OTP proporciona una serie de comportamientos (behaviours) predefinidos que ayudan a estructurar el código y manejar tareas comunes en sistemas concurrentes. 

Algunos de los componentes clave de OTP incluyen:

- **GenServer**: Un comportamiento que facilita la creación de servidores genéricos. Permite manejar llamadas síncronas y asíncronas, mantener estado y gestionar la concurrencia de manera sencilla.
- **Supervisor**: Un comportamiento que supervisa otros procesos (como GenServers) y los reinicia automáticamente en caso de fallos. Esto ayuda a construir sistemas tolerantes a fallos.
- **Arbol de Supervisión**: Una estructura jerárquica de supervisores que permite organizar y gestionar múltiples procesos y supervisores de manera eficiente.

## GenServer

GenServer (Generic Server) es un comportamiento en OTP que facilita la creación de servidores genéricos. Proporciona una interfaz para manejar llamadas síncronas y asíncronas, mantener estado y gestionar la concurrencia.

### Ejemplo de uso

A continuación se muestra un ejemplo básico de cómo implementar un GenServer en Elixir:

```elixir
defmodule MiGenServer do
  use GenServer

  # Callback para iniciar el GenServer
  def start_link(initial_state) do
    # Registrar el GenServer con un nombre. Similar a Agent ya que maneja su propio proceso y estado
    GenServer.start_link(__MODULE__, initial_state, name: __MODULE__) 
  end

  # Callback para manejar la inicialización
  def init(initial_state) do
    {:ok, initial_state}
  end

  # Callback para manejar llamadas síncronas
  def handle_call(:get_state, _from, state) do
    {:reply, state, state}
  end

  # Callback para manejar mensajes asíncronos
  def handle_cast({:set_state, new_state}, _old_state) do
    {:noreply, new_state}
  end
end
```

En este ejemplo, `MiGenServer` es un GenServer simple que mantiene un estado interno. Proporciona una llamada síncrona para obtener el estado y una llamada asíncrona para establecer un nuevo estado.

La diferencia entre `handle_call` y `handle_cast` es que el primero es para **llamadas síncronas** (el cliente espera una respuesta), mientras que el segundo es para **mensajes asíncronos** (el cliente no espera una respuesta).

Ambos pueden modificar el estado del servidor, pero en la práctica, `handle_call` suele usarse para leer o devolver información, y `handle_cast` para actualizar el estado sin necesidad de respuesta inmediata.

Para más información sobre GenServer, se recomienda consultar la [documentación oficial](https://hexdocs.pm/elixir/1.12/GenServer.html).

### Diferencias entre Agent y GenServer

La diferencia principal entre `Agent` y `GenServer` es que `GenServer` ofrece una mayor flexibilidad y control sobre el manejo de mensajes y el ciclo de vida del proceso. Mientras que `Agent` está diseñado para casos simples de manejo de estado, `GenServer` es más adecuado para aplicaciones más complejas que requieren lógica personalizada para manejar diferentes tipos de mensajes y estados.

En la siguiente tabla se resumen las diferencias clave entre `Agent` y `GenServer`:

| Característica      | **Agent**                             | **GenServer**                                                       |
| ------------------- | ------------------------------------- | ------------------------------------------------------------------- |
| Complejidad         | Simple                                | Complejo                                                            |
| Propósito principal | Almacenar y actualizar estado         | Controlar la comunicación y la lógica del proceso                   |
| Manejo de mensajes  | Automático (transparente)             | Manual (`handle_call`, `handle_cast`, etc.)                         |
| Ideal para          | Contadores, cachés, datos compartidos | Servidores, coordinadores, procesos con múltiples tipos de mensajes |
| Flexibilidad        | Limitada                              | Muy alta                                                            |


---

## Ejemplo 1

Se requiere crear un sistema de gestión de tareas donde los usuarios pueden agregar, eliminar y listar tareas. Cada tarea tiene un título y una descripción. El sistema debe manejar múltiples usuarios y sus respectivas listas de tareas. Debe usar `GenServer` como servidor para manejar las tareas de cada usuario.

En este caso, se quiere tener un servidor y múltiples clientes que se conecten a este servidor para gestionar sus tareas. A continuación, se muestra cómo se puede implementar esto utilizando `GenServer` y la funcionalidad de distribución de Elixir.

### 1. Crear la estructura de la tarea

Cree un archivo llamado `tareas.exs` y defina la estructura de una tarea:

```elixir
# Definición de la estructura de una tarea
defmodule Tarea do
  defstruct [:titulo, :descripcion]
end
```

Puede compilar el código anterior usando `elixirc tareas.exs` en la terminal para que esté disponible en el entorno de Elixir y pueda ser utilizado en los siguientes pasos.

### 2. Crear el servidor

Cree un nuevo archivo llamado `server.exs` y defina el servidor de tareas utilizando `GenServer`:

```elixir
# Módulo del servidor de tareas
defmodule TareasServidor do
  use GenServer

  # Iniciar el GenServer con un estado inicial vacío
  def start_link(_) do
    GenServer.start_link(__MODULE__, %{}, name: __MODULE__)
  end

  def init(state) do
    {:ok, state}
  end

  # Manejar la adición de una tarea
  def handle_cast({:agregar_tarea, usuario, tarea}, state) do
    tareas_usuario = Map.get(state, usuario, [])
    nuevas_tareas = [tarea | tareas_usuario]
    nuevo_estado = Map.put(state, usuario, nuevas_tareas)
    {:noreply, nuevo_estado}
  end

  # Manejar la eliminación de una tarea
  def handle_cast({:eliminar_tarea, usuario, titulo}, state) do
    tareas_usuario = Map.get(state, usuario, [])
    nuevas_tareas = Enum.filter(tareas_usuario, fn %Tarea{titulo: t} -> t != titulo end)
    nuevo_estado = Map.put(state, usuario, nuevas_tareas)
    {:noreply, nuevo_estado}
  end

  # Manejar la solicitud de listar tareas
  def handle_call({:listar_tareas, usuario}, _from, state) do
    tareas_usuario = Map.get(state, usuario, [])
    {:reply, tareas_usuario, state}
  end
end
```

El servidor `TareasServidor` mantiene un estado que es un mapa donde las claves son los nombres de usuario y los valores son listas de tareas. Proporciona funciones para agregar, eliminar y listar tareas. 

Dado que el servidor maneja su propio proceso, no es necesario preocuparse por la concurrencia al acceder o modificar el estado interno.

Además, el servidor puede ser iniciado en un nodo de Elixir, lo que permite que otros nodos (clientes) se conecten a él para gestionar sus tareas.

### 3. Crear el cliente

Cree un nuevo archivo llamado `client.exs` y defina el cliente de tareas utilizando `GenServer`:

```elixir
# Módulo del cliente
defmodule TareasCliente do
  use GenServer

  # Conectar al servidor de tareas
  def start_link(server_node) do
    GenServer.start_link(__MODULE__, server_node, name: __MODULE__)
  end

  def init(server_node) do
    {:ok, server_node}
  end

  # Agregar una tarea al servidor
  def agregar_tarea(usuario, %Tarea{} = tarea) do
    GenServer.cast(__MODULE__, {:agregar_tarea, usuario, tarea})
  end

  # Eliminar una tarea del servidor
  def eliminar_tarea(usuario, titulo) do
    GenServer.cast(__MODULE__, {:eliminar_tarea, usuario, titulo})
  end

  # Listar las tareas del servidor
  def listar_tareas(usuario) do
    GenServer.call(__MODULE__, {:listar_tareas, usuario})
  end 

  # Manejar la adición de una tarea
  def handle_cast({:agregar_tarea, usuario, tarea}, server_node) do
    GenServer.cast({TareasServidor, server_node}, {:agregar_tarea, usuario, tarea})
    {:noreply, server_node}
  end

  # Manejar la eliminación de una tarea
  def handle_cast({:eliminar_tarea, usuario, titulo}, server_node) do
    GenServer.cast({TareasServidor, server_node}, {:eliminar_tarea, usuario, titulo})
    {:noreply, server_node}
  end

  # Manejar la solicitud de listar tareas
  def handle_call({:listar_tareas, usuario}, _from, server_node) do
    tareas = GenServer.call({TareasServidor, server_node}, {:listar_tareas, usuario})
    {:reply, tareas, server_node}
  end
end
```

El cliente `TareasCliente` se conecta al servidor de tareas en un nodo específico. Proporciona funciones para agregar, eliminar y listar tareas, que internamente envían mensajes al servidor. Este cliente también maneja su propio proceso, lo que permite que múltiples clientes se conecten al mismo servidor de manera concurrente.

### 4. Configuración de nodos

Para probar la funcionalidad distribuida, es necesario iniciar dos nodos de Elixir. En uno de los nodos, se ejecuta el servidor de tareas, y en el otro nodo, se ejecuta el cliente que se conecta al servidor. Asegúrese de que ambos nodos puedan comunicarse entre sí.

En el módulo `TareasServidor`, puede agregar una función `main` para iniciar el servidor:

```elixir
def main do
  # Iniciar el servidor de tareas
  {:ok, _} = TareasServidor.start_link()
  IO.puts("🚀 Servidor de tareas iniciado")

  # Mantener el proceso principal vivo
  Process.sleep(:infinity)
end
```

No olvide llamar a `TareasServidor.main()` al final del archivo `server.exs` para iniciar el servidor cuando se ejecute el archivo.

En el módulo `TareasCliente`, puede agregar una función `main` para iniciar el cliente y conectarse al servidor:

```elixir
def main do
  # Nombre del nodo servidor (ajustar según sea necesario)
  server_node = :'servidor@tu_maquina'

  IO.puts("✅ Nodo cliente iniciado")

  # Conectarse al servidor y arrancar el cliente
  {:ok, _pid} = start_link(server_node)

  # ====== Ejemplo automático de uso ======
  agregar_tarea("usuario1", %Tarea{titulo: "Comprar leche", descripcion: "Ir al supermercado"})
  agregar_tarea("usuario1", %Tarea{titulo: "Estudiar Elixir", descripcion: "Leer la guía oficial"})
  IO.inspect(listar_tareas("usuario1"))
end
```

No olvide llamar a `TareasCliente.main()` al final del archivo `client.exs` para iniciar el cliente cuando se ejecute el archivo.

> ⚠️ **Importante**: Asegúrese de ajustar el nombre del nodo del servidor en el archivo `client.exs` para que coincida con el nombre utilizado al iniciar el nodo del servidor. Puede usar `Node.self()` en el servidor para verificar el nombre del nodo.

### 5. Ejecutar los nodos

Para ejecutar los nodos, abra dos terminales. En la primera terminal, inicie el nodo del servidor:

```bash
elixir --sname servidor --cookie mi_cookie server.exs
```

En la segunda terminal, inicie el nodo del cliente:

```bash
elixir --sname cliente --cookie mi_cookie client.exs
```

Al ejecutar ambos nodos, el cliente se conectará al servidor y podrá agregar, eliminar y listar tareas de manera distribuida.

### 6. Probar con varios clientes

Puede abrir más terminales y ejecutar más instancias del cliente para simular múltiples usuarios conectándose al mismo servidor. Cada cliente podrá gestionar sus propias tareas de manera independiente.

Si cuenta con varias máquinas en la misma red, puede iniciar el servidor en una máquina y los clientes en otras, asegurándose de que todos los nodos puedan comunicarse entre sí.

Incluso, si un cliente falla o se desconecta, el servidor seguirá funcionando y manteniendo el estado de las tareas de los demás usuarios, gracias a la naturaleza tolerante a fallos de OTP.

---

## Para la próxima clase

- Investigue sobre Supervisores en OTP y cómo se utilizan para gestionar la recuperación de procesos en caso de fallos.
- Qué es Mix y cómo se utiliza para gestionar proyectos en Elixir.
- Investigue y lea cómo hace elixir para manejar la concurrencia y el paralelismo.



