```
Universidad del Quindío
Programa de Ingeniería de Sistemas y Computación
Programación III - OTP (Open Telecom Platform)
Docente: Carlos Andrés Florez V.
```

# Introducción a OTP

Antes de entrar en detalles sobre OTP, es importante entender el concepto de **Agentes** en Elixir, ya que son una forma sencilla de manejar el estado compartido y mutable en aplicaciones concurrentes.

# Agent

El módulo `Agent` en Elixir proporciona una forma sencilla de crear y manejar procesos que mantienen un estado compartido. Los agentes son útiles cuando se necesita un proceso que almacene y gestione un estado mutable de manera concurrente. El módulo `Agent` ofrece una interfaz simple para crear, actualizar y leer el estado del agente. Entre las funciones más comunes del módulo `Agent` se encuentran:

- `Agent.start_link/2`: Inicia un nuevo agente con un estado inicial.
- `Agent.get/2`: Obtiene el estado actual del agente.
- `Agent.update/2`: Actualiza el estado del agente utilizando una función.
- `Agent.get_and_update/2`: Obtiene y actualiza el estado del agente en una sola operación.
- `Agent.stop/1`: Detiene el agente.

En el proyecto que hicimos previamente (Gimnasio), podemos usar un `Agent` para mantener el estado del gimnasio y su mapa de miembros. Para esto, podemos escribir lo siguiente:

```elixir
defmodule Gimnasio do

  use Agent # Importar el módulo Agent

  def start_link do
    # Iniciar el agente con un mapa vacío como estado inicial
    Agent.start_link(fn -> %{} end, name: __MODULE__)
  end

  defp agregar_socio(cedula, socio) do
    # Agregar un nuevo socio al mapa, actualizando el estado del agente
    Agent.update(__MODULE__, fn socios -> Map.put(socios, cedula, socio) end)
  end

  defp obtener_socio(cedula) do
    # Obtener un socio del mapa por su cédula
    Agent.get(__MODULE__, fn socios -> Map.get(socios, cedula) end)
  end

  defp eliminar_socio(cedula) do
    # Eliminar un socio del mapa por su cédula
    Agent.update(__MODULE__, fn socios -> Map.delete(socios, cedula) end)
  end

  defp listar_socios do
    # Listar todos los socios en el mapa
    Agent.get(__MODULE__, fn socios -> socios end)
  end

  defp inscribir_clase(cedula, clase) do
    # Se actualiza el estado del agente para inscribir una clase a un socio
    Agent.update(__MODULE__, fn socios ->
      case Map.get(socios, cedula) do
        nil -> socios  # Si el socio no existe, no hacer nada
        socio ->
          actualizado = %{socio | clases: [clase | socio.clases]}
          Map.put(socios, cedula, actualizado)
      end
    end)
  end

  def main do
    start_link() # Iniciar el agente (es importante hacerlo antes de usarlo)

    agregar_socio("123", %Socio{nombre: "Juan", edad: 30, clases: []})
    agregar_socio("456", %Socio{nombre: "Ana", edad: 25, clases: []})

    IO.inspect(obtener_socio("123"))
    IO.inspect(listar_socios())

    inscribir_clase("123", "Yoga")
    IO.inspect(obtener_socio("123"))

    eliminar_socio("456")
    IO.inspect(listar_socios())
  end
  
end

Gimnasio.main()
```

Dado que el `Agent` maneja su propio proceso, no es necesario preocuparse por la concurrencia al acceder o modificar el estado del gimnasio. El `Agent` se encarga de sincronizar el acceso al estado interno, lo que facilita la implementación de aplicaciones concurrentes. Además, **no es necesario pasar el mapa de socios** entre funciones, ya que el `Agent` mantiene el estado internamente. 

Elixir facilita el manejo del estado compartido y mutable mediante el uso de agentes, lo que permite construir aplicaciones concurrentes de manera más sencilla y segura.

Para más información sobre el módulo `Agent`, puedes consultar la [documentación oficial](https://hexdocs.pm/elixir/1.12/Agent.html).

---

# OTP (Open Telecom Platform)

En elixir, OTP (Open Telecom Platform) es un conjunto de bibliotecas y herramientas que facilitan la construcción de aplicaciones concurrentes, distribuidas y tolerantes a fallos. OTP proporciona una serie de comportamientos (behaviours) predefinidos que ayudan a estructurar el código y manejar tareas comunes en sistemas concurrentes. 

Algunos de los componentes clave de OTP incluyen:

- **GenServer**: Un comportamiento que facilita la creación de servidores genéricos. Permite manejar llamadas síncronas y asíncronas, mantener estado y gestionar la concurrencia de manera sencilla.
- **Supervisor**: Un comportamiento que supervisa otros procesos (como GenServers) y los reinicia automáticamente en caso de fallos. Esto ayuda a construir sistemas tolerantes a fallos.
- **Arbol de Supervisión**: Una estructura jerárquica de supervisores que permite organizar y gestionar múltiples procesos y supervisores de manera eficiente.

## GenServer

GenServer (Generic Server) es un comportamiento en OTP que facilita la creación de servidores genéricos. Proporciona una interfaz para manejar llamadas síncronas y asíncronas, mantener estado y gestionar la concurrencia.

### Ejemplo de uso

A continuación se muestra un ejemplo básico de cómo implementar un GenServer en Elixir:

```elixir
defmodule MiGenServer do
  use GenServer

  # Callback para iniciar el GenServer
  def start_link(initial_state) do
    # Registrar el GenServer con un nombre. Similar a Agent ya que maneja su propio proceso y estado
    GenServer.start_link(__MODULE__, initial_state, name: __MODULE__) 
  end

  # Callback para manejar la inicialización
  def init(initial_state) do
    {:ok, initial_state}
  end

  # Callback para manejar llamadas síncronas
  def handle_call(:get_state, _from, state) do
    {:reply, state, state}
  end

  # Callback para manejar mensajes asíncronos
  def handle_cast({:set_state, new_state}, _old_state) do
    {:noreply, new_state}
  end
end
```

En este ejemplo, `MiGenServer` es un GenServer simple que mantiene un estado interno. Proporciona una llamada síncrona para obtener el estado y una llamada asíncrona para establecer un nuevo estado.

La diferencia entre `handle_call` y `handle_cast` es que el primero es para **llamadas síncronas** (el cliente espera una respuesta), mientras que el segundo es para **mensajes asíncronos** (el cliente no espera una respuesta).

Ambos pueden modificar el estado del servidor, pero en la práctica, `handle_call` suele usarse para leer o devolver información, y `handle_cast` para actualizar el estado sin necesidad de respuesta inmediata.

Para más información sobre GenServer, se recomienda consultar la [documentación oficial](https://hexdocs.pm/elixir/1.12/GenServer.html).

### Diferencias entre Agent y GenServer

La diferencia principal entre `Agent` y `GenServer` es que `GenServer` ofrece una mayor flexibilidad y control sobre el manejo de mensajes y el ciclo de vida del proceso. Mientras que `Agent` está diseñado para casos simples de manejo de estado, `GenServer` es más adecuado para aplicaciones más complejas que requieren lógica personalizada para manejar diferentes tipos de mensajes y estados.

En la siguiente tabla se resumen las diferencias clave entre `Agent` y `GenServer`:

| Característica      | **Agent**                             | **GenServer**                                                       |
| ------------------- | ------------------------------------- | ------------------------------------------------------------------- |
| Complejidad         | Simple                                | Complejo                                                            |
| Propósito principal | Almacenar y actualizar estado         | Controlar la comunicación y la lógica del proceso                   |
| Manejo de mensajes  | Automático (transparente)             | Manual (`handle_call`, `handle_cast`, etc.)                         |
| Ideal para          | Contadores, cachés, datos compartidos | Servidores, coordinadores, procesos con múltiples tipos de mensajes |
| Flexibilidad        | Limitada                              | Muy alta                                                            |


---

## Ejemplo 1

Se requiere crear un sistema de gestión de tareas donde los usuarios pueden agregar, eliminar y listar tareas. Cada tarea tiene un título y una descripción. El sistema debe manejar múltiples usuarios y sus respectivas listas de tareas. Debe usar `GenServer` como servidor para manejar las tareas de cada usuario.

En este caso, se quiere tener un servidor y múltiples clientes que se conecten a este servidor para gestionar sus tareas. A continuación, se muestra cómo se puede implementar esto utilizando `GenServer` y la funcionalidad de distribución de Elixir.

### 1. Crear la estructura de la tarea

Cree un archivo llamado `tareas.exs` y defina la estructura de una tarea:

```elixir
# Definición de la estructura de una tarea
defmodule Tarea do
  defstruct [:titulo, :descripcion]
end
```

Puede compilar el código anterior usando `elixirc tareas.exs` en la terminal para que esté disponible en el entorno de Elixir y pueda ser utilizado en los siguientes pasos.

### 2. Crear el servidor

Cree un nuevo archivo llamado `server.exs` y defina el servidor de tareas utilizando `GenServer`:

```elixir
# Módulo del servidor de tareas
defmodule TareasServidor do
  use GenServer

  # Iniciar el GenServer con un estado inicial vacío
  def start_link(_) do
    GenServer.start_link(__MODULE__, %{}, name: __MODULE__)
  end

  def init(state) do
    {:ok, state}
  end

  # Manejar la adición de una tarea
  def handle_cast({:agregar_tarea, usuario, tarea}, state) do
    tareas_usuario = Map.get(state, usuario, [])
    nuevas_tareas = [tarea | tareas_usuario]
    nuevo_estado = Map.put(state, usuario, nuevas_tareas)
    {:noreply, nuevo_estado}
  end

  # Manejar la eliminación de una tarea
  def handle_cast({:eliminar_tarea, usuario, titulo}, state) do
    tareas_usuario = Map.get(state, usuario, [])
    nuevas_tareas = Enum.filter(tareas_usuario, fn %Tarea{titulo: t} -> t != titulo end)
    nuevo_estado = Map.put(state, usuario, nuevas_tareas)
    {:noreply, nuevo_estado}
  end

  # Manejar la solicitud de listar tareas
  def handle_call({:listar_tareas, usuario}, _from, state) do
    tareas_usuario = Map.get(state, usuario, [])
    {:reply, tareas_usuario, state}
  end
end
```

El servidor `TareasServidor` mantiene un estado que es un mapa donde las claves son los nombres de usuario y los valores son listas de tareas. Proporciona funciones para agregar, eliminar y listar tareas. 

Dado que el servidor maneja su propio proceso, no es necesario preocuparse por la concurrencia al acceder o modificar el estado interno.

Además, el servidor puede ser iniciado en un nodo de Elixir, lo que permite que otros nodos (clientes) se conecten a él para gestionar sus tareas.

### 3. Crear el cliente

Cree un nuevo archivo llamado `client.exs` y defina el cliente de tareas utilizando `GenServer`:

```elixir
# Módulo del cliente
defmodule TareasCliente do
  use GenServer

  # Conectar al servidor de tareas
  def start_link(server_node) do
    GenServer.start_link(__MODULE__, server_node, name: __MODULE__)
  end

  def init(server_node) do
    {:ok, server_node}
  end

  # Agregar una tarea al servidor
  def agregar_tarea(usuario, %Tarea{} = tarea) do
    GenServer.cast(__MODULE__, {:agregar_tarea, usuario, tarea})
  end

  # Eliminar una tarea del servidor
  def eliminar_tarea(usuario, titulo) do
    GenServer.cast(__MODULE__, {:eliminar_tarea, usuario, titulo})
  end

  # Listar las tareas del servidor
  def listar_tareas(usuario) do
    GenServer.call(__MODULE__, {:listar_tareas, usuario})
  end 

  # Manejar la adición de una tarea
  def handle_cast({:agregar_tarea, usuario, tarea}, server_node) do
    GenServer.cast({TareasServidor, server_node}, {:agregar_tarea, usuario, tarea})
    {:noreply, server_node}
  end

  # Manejar la eliminación de una tarea
  def handle_cast({:eliminar_tarea, usuario, titulo}, server_node) do
    GenServer.cast({TareasServidor, server_node}, {:eliminar_tarea, usuario, titulo})
    {:noreply, server_node}
  end

  # Manejar la solicitud de listar tareas
  def handle_call({:listar_tareas, usuario}, _from, server_node) do
    tareas = GenServer.call({TareasServidor, server_node}, {:listar_tareas, usuario})
    {:reply, tareas, server_node}
  end
end
```

El cliente `TareasCliente` se conecta al servidor de tareas en un nodo específico. Proporciona funciones para agregar, eliminar y listar tareas, que internamente envían mensajes al servidor. Este cliente también maneja su propio proceso, lo que permite que múltiples clientes se conecten al mismo servidor de manera concurrente.

### 4. Configuración de nodos

Para probar la funcionalidad distribuida, es necesario iniciar dos nodos de Elixir. En uno de los nodos, se ejecuta el servidor de tareas, y en el otro nodo, se ejecuta el cliente que se conecta al servidor. Asegúrese de que ambos nodos puedan comunicarse entre sí.

En el módulo `TareasServidor`, puede agregar una función `main` para iniciar el servidor:

```elixir
def main do
  # Iniciar el servidor de tareas
  {:ok, _} = TareasServidor.start_link()
  IO.puts("Servidor de tareas iniciado")

  # Mantener el proceso principal vivo
  Process.sleep(:infinity)
end
```

No olvide llamar a `TareasServidor.main()` al final del archivo `server.exs` para iniciar el servidor cuando se ejecute el archivo.

En el módulo `TareasCliente`, puede agregar una función `main` para iniciar el cliente y conectarse al servidor:

```elixir
def main do
  # Nombre del nodo servidor (ajustar según sea necesario)
  server_node = :'servidor@tu_maquina'

  IO.puts("Nodo cliente iniciado")

  # Conectarse al servidor y arrancar el cliente
  {:ok, _pid} = start_link(server_node)

  # Ejemplo automático de uso 
  agregar_tarea("usuario1", %Tarea{titulo: "Comprar leche", descripcion: "Ir al supermercado"})
  agregar_tarea("usuario1", %Tarea{titulo: "Estudiar Elixir", descripcion: "Leer la guía oficial"})
  IO.inspect(listar_tareas("usuario1"))
end
```

No olvide llamar a `TareasCliente.main()` al final del archivo `client.exs` para iniciar el cliente cuando se ejecute el archivo.

> ⚠️ **Importante**: Asegúrese de ajustar el nombre del nodo del servidor en el archivo `client.exs` para que coincida con el nombre utilizado al iniciar el nodo del servidor. Puede usar `Node.self()` en el servidor para verificar el nombre del nodo.

### 5. Ejecutar los nodos

Para ejecutar los nodos, abra dos terminales. En la primera terminal, inicie el nodo del servidor:

```bash
elixir --sname servidor --cookie mi_cookie server.exs
```

En la segunda terminal, inicie el nodo del cliente:

```bash
elixir --sname cliente --cookie mi_cookie client.exs
```

Al ejecutar ambos nodos, el cliente se conectará al servidor y podrá agregar, eliminar y listar tareas de manera distribuida.

### 6. Probar con varios clientes

Puede abrir más terminales y ejecutar más instancias del cliente para simular múltiples usuarios conectándose al mismo servidor. Cada cliente podrá gestionar sus propias tareas de manera independiente.

Si cuenta con varias máquinas en la misma red, puede iniciar el servidor en una máquina y los clientes en otras, asegurándose de que todos los nodos puedan comunicarse entre sí.

Incluso, si un cliente falla o se desconecta, el servidor seguirá funcionando y manteniendo el estado de las tareas de los demás usuarios, gracias a la naturaleza tolerante a fallos de OTP.

---

## Ejemplo 2

Cree un sistema de chat simple donde los usuarios pueden enviar y recibir mensajes. Cada usuario debe tener su propio proceso que maneje la recepción de mensajes. Utilice `GenServer` para implementar tanto el servidor de chat como los clientes.

### 1. Estructura de archivos

La aplicación se puede organizar en tres archivos principales:

```
ChatApp/
├── chat_server.exs   # El orquestador: salas, usuarios y mensajes
├── chat_room.exs     # Cada sala es un GenServer independiente
└── chat_client.exs   # Lógica de usuario (interfaz hacia el servidor)
```

### 2. Implementación de la sala de chat

Cree un archivo llamado `chat_room.exs` y defina el módulo `ChatRoom` utilizando `GenServer`:

```elixir
defmodule ChatRoom do
  use GenServer

  # Estado: %{name: String, users: %{pid => username}, messages: [String]}

  ## --- API pública ---

  def start_link(name) do
    GenServer.start_link(__MODULE__, %{name: name, users: %{}, messages: []})
  end

  def join(pid, user_pid, username), do: GenServer.cast(pid, {:join, user_pid, username})
  def leave(pid, user_pid), do: GenServer.cast(pid, {:leave, user_pid})
  def send_message(pid, user_pid, msg), do: GenServer.cast(pid, {:message, user_pid, msg})

  ## Callbacks

  @impl true
  def init(state), do: {:ok, state}

  @impl true
  def handle_cast({:join, pid, username}, state) do
    Process.monitor(pid) # Monitorear el proceso del usuario para detectar desconexiones
    IO.puts("#{username} se unió a #{state.name}")
    {:noreply, %{state | users: Map.put(state.users, pid, username)}}
  end

  def handle_cast({:leave, pid}, state) do
    {username, users} = Map.pop(state.users, pid) # Eliminar al usuario
    IO.puts("#{username} salió de #{state.name}")
    {:noreply, %{state | users: users}}
  end

  def handle_cast({:message, from_pid, msg}, state) do
    username = Map.get(state.users, from_pid, "Desconocido")
    full = "#{username}: #{msg}"
    Enum.each(state.users, fn {pid, _} -> send(pid, {:chat, state.name, full}) end)
    {:noreply, %{state | messages: [full | state.messages]}}
  end

  @impl true
  def handle_info({:DOWN, _ref, :process, pid, _}, state) do
    {username, users} = Map.pop(state.users, pid) # Eliminar al usuario desconectado cuando su proceso muere
    IO.puts("#{username} desconectado de #{state.name}")
    {:noreply, %{state | users: users}}
  end
end
```

### 3. Implementación del servidor de chat

Cree un archivo llamado `chat_server.exs` y defina el módulo `ChatServer` utilizando `GenServer`:

```elixir
defmodule ChatServer do
  use GenServer

  ## --- API pública ---

  def start_link(_opts \\ []) do
    GenServer.start_link(__MODULE__, %{}, name: __MODULE__)
  end

  def create_room(name), do: GenServer.call(__MODULE__, {:create_room, name})
  def list_rooms(), do: GenServer.call(__MODULE__, :list_rooms)
  def get_room_pid(name), do: GenServer.call(__MODULE__, {:get_room, name})

  ## --- Callbacks ---

  @impl true
  def init(_) do
    {:ok, sup} = DynamicSupervisor.start_link(strategy: :one_for_one) # Supervisor dinámico para las salas de chat
    {:ok, %{rooms: %{}, sup: sup}}
  end

  @impl true
  def handle_call({:create_room, name}, _from, state) do
    if Map.has_key?(state.rooms, name) do
      {:reply, {:error, :exists}, state}
    else
      {:ok, pid} = DynamicSupervisor.start_child(state.sup, {ChatRoom, name}) # Iniciar una nueva sala
      {:reply, {:ok, pid}, %{state | rooms: Map.put(state.rooms, name, pid)}}
    end
  end

  def handle_call(:list_rooms, _from, state) do
    {:reply, Map.keys(state.rooms), state}
  end

  def handle_call({:get_room, name}, _from, state) do
    {:reply, Map.get(state.rooms, name), state}
  end
end
```

`DynamicSupervisor` se utiliza para gestionar las salas de chat, permitiendo crear y eliminar salas de manera dinámica. Esto facilita la escalabilidad y la gestión de múltiples salas de chat.

La diferencia entre `start_link` y `start_child` es que `start_link` se utiliza para iniciar un proceso supervisado (como el servidor principal), mientras que `start_child` se utiliza para iniciar procesos hijos bajo un supervisor dinámico (como las salas de chat).

### 4. Implementación del cliente de chat

Cree un archivo llamado `chat_client.exs` y defina el módulo `ChatClient` utilizando `GenServer`:

```elixir
defmodule ChatClient do
  def start(username) do
    spawn(fn -> loop(username, %{}) end)
  end

  defp loop(username, joined_rooms) do
    receive do
      {:chat, room, msg} ->
        IO.puts("[#{room}] #{msg}")
        loop(username, joined_rooms)

      {:join, server_pid, room_name} ->
        case ChatServer.get_room_pid(room_name) do
          nil ->
            IO.puts("La sala #{room_name} no existe")
            loop(username, joined_rooms)

          room_pid ->
            ChatRoom.join(room_pid, self(), username)
            loop(username, Map.put(joined_rooms, room_name, room_pid))
        end

      {:send, room_name, msg} ->
        case Map.get(joined_rooms, room_name) do
          nil -> IO.puts("No estás en la sala #{room_name}")
          room_pid -> ChatRoom.send_message(room_pid, self(), msg)
        end
        loop(username, joined_rooms)

      {:leave, room_name} ->
        case Map.pop(joined_rooms, room_name) do
          {nil, _} -> IO.puts("No estás en #{room_name}")
          {pid, rest} -> ChatRoom.leave(pid, self()); loop(username, rest)
        end
    end
  end
end
```

El cliente cuenta con un bucle de recepción que maneja mensajes entrantes del servidor y permite al usuario unirse a salas, enviar mensajes y salir de salas.

### 5. Ejecutar la aplicación de chat

Una vez que tenga los tres archivos (`chat_server.exs`, `chat_room.exs`, `chat_client.exs`), puede iniciar el servidor de chat y crear salas. Luego, puede iniciar múltiples clientes que se conecten al servidor y participen en las salas de chat. Puede probar la funcionalidad en `iex` de la siguiente manera:

```elixir
iex> ChatServer.start_link()
{:ok, pid}

iex> ChatServer.create_room("general")
{:ok, #PID<0.130.0>}

iex> ChatServer.create_room("random")
{:ok, #PID<0.132.0>}

iex> alice = ChatClient.start("Alice")
iex> bob = ChatClient.start("Bob")

# Unirse
iex> send(alice, {:join, ChatServer, "general"})
iex> send(bob, {:join, ChatServer, "general"})

# Enviar mensajes
iex> send(alice, {:send, "general", "Hola Bob!"})
iex> send(bob, {:send, "general", "Hola Alice!"})

# Salir de una sala
iex> send(bob, {:leave, "general"})
```

### 6. Mejoras y consideraciones

Con base en el ejemplo anterior, puede mejorar la aplicación de chat separando el servidor y los clientes en nodos diferentes para aprovechar la capacidad de distribución de Elixir. 

---

## Para la próxima clase

- Investigue sobre Supervisores en OTP y cómo se utilizan para gestionar la recuperación de procesos en caso de fallos.
- Qué es Mix y cómo se utiliza para gestionar proyectos en Elixir.
- Investigue y lea cómo hace elixir para manejar la concurrencia y el paralelismo.



