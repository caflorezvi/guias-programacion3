<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script> 
<script> 
  document.addEventListener("DOMContentLoaded", function() { mermaid.initialize({ startOnLoad: true }); }); 
</script>

```
Universidad del Quind铆o
Programa de Ingenier铆a de Sistemas y Computaci贸n
Programaci贸n III - Procesos
Docente: Carlos Andr茅s Florez V.
```

# Procesos

En este documento se explican los conceptos b谩sicos sobre los procesos en elixir y c贸mo manejarlos. Adem谩s, se incluyen ejemplos pr谩cticos para ilustrar su uso.

## 驴Qu茅 es un proceso?

En los **sistemas operativos**, un **proceso** es un programa en ejecuci贸n que posee su propio espacio de memoria y los recursos necesarios para funcionar. Cada proceso es **independiente** y puede ejecutarse de forma **concurrente** con otros.

Por ejemplo, un sistema operativo es capaz de **gestionar la ejecuci贸n concurrente** de distintos programas, como un reproductor de m煤sica, un navegador web y un editor de texto, garantizando que cada uno disponga de los recursos necesarios sin interferir con los dem谩s.

## 驴Qu茅 es concurrencia?

La concurrencia es la **capacidad de un sistema para gestionar m煤ltiples tareas o procesos al mismo tiempo**, compartiendo los recursos disponibles. Por ejemplo, en un sistema operativo, la concurrencia permite que varios programas se ejecuten *simult谩neamente en apariencia*, alternando su uso de la CPU.

Por su parte, el **paralelismo** se refiere a la **ejecuci贸n real y simult谩nea de m煤ltiples tareas**, aprovechando la existencia de **varios procesadores o n煤cleos**. En este caso, cada tarea se ejecuta literalmente al mismo tiempo en diferentes unidades de procesamiento. Por ejemplo, en un computador con varios n煤cleos, un n煤cleo puede procesar datos mientras otro renderiza gr谩ficos, logrando as铆 una ejecuci贸n verdaderamente paralela.

>  **Nota:** La diferencia clave entre concurrencia y paralelismo radica en que la **concurrencia** se enfoca en la gesti贸n eficiente de m煤ltiples tareas, mientras que el **paralelismo** se centra en la ejecuci贸n simult谩nea de esas tareas.

---

## El Modelo de Actores

Antes de profundizar en los procesos de Elixir, es importante entender el **Modelo de Actores**, que es el paradigma de concurrencia sobre el cual est谩n construidos Elixir y Erlang.

### 驴Qu茅 es el Modelo de Actores?

El **Modelo de Actores** es un modelo matem谩tico de computaci贸n concurrente propuesto por Carl Hewitt en 1973. En este modelo, los **"actores"** son las unidades fundamentales de computaci贸n que:

1. **Tienen estado privado**: Cada actor mantiene su propio estado interno que no puede ser accedido directamente por otros actores.
2. **Se comunican mediante mensajes**: Los actores se comunican exclusivamente enviando mensajes as铆ncronos entre s铆.
3. **Procesan un mensaje a la vez**: Cada actor procesa los mensajes de su buz贸n (*mailbox*) de forma secuencial.
4. **Pueden crear nuevos actores**: Un actor puede crear (*spawn*) otros actores.
5. **Son completamente aislados**: Si un actor falla, no afecta a los dem谩s.

### Modelo de Actores vs Hilos Tradicionales

En otros lenguajes de programaci贸n, la concurrencia suele implementarse mediante **hilos tradicionales**, que comparten memoria y requieren mecanismos de sincronizaci贸n complejos. A continuaci贸n, se presenta una tabla comparativa entre ambos enfoques:

| Caracter铆stica | Hilos Tradicionales | Modelo de Actores |
|----------------|---------------------|-------------------|
| **Memoria** | Compartida | Aislada (sin compartir) |
| **Comunicaci贸n** | Variables compartidas + locks | Mensajes as铆ncronos |
| **Sincronizaci贸n** | Sem谩foros, mutex, locks | No necesaria |
| **Problemas comunes** | Race conditions, deadlocks | M谩s dif铆ciles de producir |
| **Escalabilidad** | Limitada por locks | Alta (miles/millones de actores) |
| **Peso** | Pesados (MB de memoria) | Ligeros (KB de memoria) |

### 驴Por qu茅 es importante en Elixir?

El Modelo de Actores es la raz贸n por la cual Elixir puede:

- Ejecutar **millones de procesos** concurrentemente en una sola m谩quina
- Construir sistemas **altamente disponibles** y **tolerantes a fallos**
- Escalar **horizontalmente** de forma natural (distribuci贸n en m煤ltiples nodos)
- Evitar problemas complejos de sincronizaci贸n que plagan otros lenguajes

El modelo de actores define la base sobre la cual Elixir implementa su sistema de concurrencia y distribuci贸n, permitiendo a los desarrolladores construir aplicaciones robustas y escalables de manera sencilla.

---

## Procesos en Elixir

En **Elixir (y Erlang)** tambi茅n se utiliza el concepto de *proceso*, aunque no se refiere a procesos del sistema operativo, sino a **procesos ligeros gestionados por la m谩quina virtual BEAM** que implementan el Modelo de Actores.

Esto implica que:

* Son mucho m谩s **ligeros** que los procesos del sistema operativo (ocupan apenas unos kilobytes).
* Pueden escalar hasta **miles o incluso millones** de procesos concurrentes en una sola m谩quina.
* Est谩n **completamente aislados**: no comparten memoria, cada uno tiene su propio estado.
* Se **comunican mediante el env铆o de mensajes** (`send` y `receive`), siguiendo el Modelo de Actores.
* Si uno falla, **no afecta a los dem谩s**, lo que otorga alta **tolerancia a fallos**.
* Cada proceso tiene su propia **cola de mensajes (mailbox)** donde se almacenan los mensajes entrantes.

Gracias a estas caracter铆sticas, Elixir resulta especialmente adecuado para construir **sistemas concurrentes y distribuidos**, como servidores web, aplicaciones de mensajer铆a o sistemas que requieren alta disponibilidad.

## Creaci贸n de procesos en Elixir

Al ejecutar un programa en Elixir, se crea autom谩ticamente un **proceso principal**, encargado de iniciar la ejecuci贸n del c贸digo. Todo el programa se ejecuta inicialmente dentro de este proceso, que act煤a como punto de partida para el resto de la aplicaci贸n. Sin embargo, Elixir permite **crear procesos adicionales** que pueden ejecutar tareas de forma **concurrente** y **aislada**, sin interferir ni bloquear al proceso principal.

Esta capacidad de dividir el trabajo entre varios procesos permite aprovechar mejor los recursos del sistema y brindar una experiencia m谩s fluida al usuario.

### Ejemplo b谩sico de creaci贸n de procesos

A continuaci贸n, se presentan algunas formas de crear procesos en Elixir mediante las funciones `spawn/1` y `spawn/3`.

**Ejemplo con `spawn/1`:**

Aunque no es necesario definir un m贸dulo para crear un proceso, es una buena pr谩ctica para organizar el c贸digo. Aqu铆 hay un ejemplo simple:

```elixir
defmodule MiModulo do
  def mi_funcion do
    IO.puts("Hola desde el proceso hijo!")
  end
end

IO.puts("Iniciando proceso...")
spawn(fn -> MiModulo.mi_funcion() end) # Se crea un proceso (un actor)
IO.puts("Proceso principal finalizado.")
``` 

Ejecute este c贸digo y ver谩 que el mensaje del proceso hijo se imprime en la consola. El proceso principal contin煤a su ejecuci贸n sin esperar a que el proceso hijo termine.

**Ejemplo con `spawn/3`:**

Otra forma de crear procesos es utilizar `spawn/3` como se muestra a continuaci贸n:

```elixir
defmodule MiModulo do
  def mi_funcion(arg) do
    IO.puts("Hola desde el proceso hijo!")
    IO.puts("Argumento recibido: #{arg}")
  end
end

IO.puts("Iniciando proceso...")
spawn(MiModulo, :mi_funcion, ["Elixir"]) # Se crea un proceso
IO.puts("Proceso principal finalizado.")
```

Hace lo mismo que el ejemplo anterior, solo cambia la forma de llamar a la funci贸n. Esta forma es 煤til cuando se desea llamar a una funci贸n espec铆fica de un m贸dulo con argumentos.

### Proceso principal y procesos hijos

Como se mencion贸 anteriormente, existe un **proceso principal**, encargado de iniciar la ejecuci贸n del programa y de generar los dem谩s procesos. Cuando este proceso principal finaliza, **todos los procesos hijos tambi茅n terminan**, ya que dependen de 茅l para mantenerse en ejecuci贸n.

En los ejemplos anteriores, dado que el **proceso hijo no realiza una tarea costosa**, no hay inconveniente, pues alcanza a completarse antes de que el proceso principal termine. Sin embargo, si el proceso hijo ejecuta una tarea que requiere m谩s tiempo, es posible que **no logre finalizarla** antes de que el proceso principal concluya, lo que puede producir resultados inesperados.

Por ejemplo:

```elixir
defmodule MiModulo do
  def mi_funcion do
    :timer.sleep(2000)  # Simula una tarea que toma tiempo
    IO.puts("Hola desde el proceso hijo despu茅s de 2 segundos!")
  end
end

IO.puts("Iniciando proceso...")
spawn(fn -> MiModulo.mi_funcion() end) # Se crea un proceso
IO.puts("Proceso principal finalizado.")
```

Ejecute este c贸digo y observe el comportamiento.

En este caso, es probable que el mensaje del proceso hijo no se imprima, ya que el **proceso principal termina antes de que el proceso hijo complete su tarea**. Para evitar esto, se puede agregar una pausa en el proceso principal para darle tiempo al proceso hijo de completarse. Modifique el c贸digo anterior agregando `:timer.sleep(3000)` justo antes de imprimir "Proceso principal finalizado." y vuelva a ejecutar el c贸digo para ver la diferencia.

Usar `:timer.sleep/1` en el proceso principal puede funcionar como una soluci贸n r谩pida para dar tiempo a que los procesos hijos finalicen, pero no es una pr谩ctica recomendable. En lugar de depender de pausas temporales, existen mecanismos m谩s robustos y eficientes en Elixir para gestionar esto. M谩s adelante los estudiaremos.

## Identificadores de procesos (PIDs)

Cada proceso tiene un **identificador 煤nico llamado PID** (*Process Identifier*), que se utiliza para referenciar y comunicarse con ese proceso. La funci贸n `spawn` devuelve el PID del proceso creado, lo que permite almacenarlo en una variable para futuras interacciones.

Por ejemplo, al crear varios procesos, se pueden obtener sus PIDs de la siguiente manera:

```elixir
pid1 = spawn(MiModulo, :mi_funcion, ["Elixir"])
IO.puts("El PID del proceso es: #{inspect(pid1)}")

pid2 = spawn(MiModulo, :mi_funcion, ["Erlang"])
IO.puts("El PID del proceso es: #{inspect(pid2)}")
```

Asimismo, se puede obtener el identificador del proceso actual (PID) mediante la funci贸n `self/0`:

```elixir
defmodule MiModulo do
  def mi_funcion(numero) do
    IO.inspect(self(), label: "Ejecuto la tarea #{numero}") # Muestra el PID del proceso actual
  end
end

# Se muestra el PID del proceso principal
IO.inspect(self(), label: "Proceso principal iniciado")

# Se crean dos procesos hijos concurrentes (dos actores)
spawn(fn -> MiModulo.mi_funcion(1) end)
spawn(fn -> MiModulo.mi_funcion(2) end)

IO.puts("Proceso principal finalizado.")
```

Ejecute este c贸digo y observe c贸mo **cada proceso tiene un PID diferente**, lo que indica que son procesos **independientes** que se ejecutan de manera **concurrente**. Cada uno es un actor con su propio estado y mailbox. Pruebe creando m谩s procesos y observe sus PID 煤nicos.

---

## Comunicaci贸n entre procesos

Los procesos en Elixir (actores) pueden comunicarse entre s铆 utilizando **mensajes**. Cada proceso tiene una **cola de mensajes** (*mailbox*) donde puede recibir mensajes de otros procesos. Para enviar un mensaje a otro proceso, se utiliza la funci贸n `send/2`, que toma el PID (identificador del proceso) del proceso receptor y el mensaje que se desea enviar. El proceso receptor puede recibir mensajes utilizando la construcci贸n `receive`, que bloquea la ejecuci贸n del proceso hasta que llegue un mensaje.

### Diagrama de comunicaci贸n entre procesos

Este diagrama ilustra c贸mo dos procesos (actores) pueden comunicarse entre s铆 mediante el env铆o y recepci贸n de mensajes:

<div class="mermaid" style="text-align: center;">
sequenceDiagram
    participant A as Actor A<br/>PID 0.50
    participant B as Actor B<br/>PID 0.51
    participant Console as Terminal/Console
    
    Note over A,B: Comunicaci贸n as铆ncrona<br/>(Modelo de Actores)
    
    A->>B: send(pidB, {:msg, "Hola"})
    Note right of B: Mensaje almacenado en mailbox<br/>[{:msg, "Hola"}]
    
    Note over B: Actor B ejecuta receive
    activate B
    B->>B: receive do<br/>{:msg, txt} -> IO.puts(txt)<br/>end
    Note right of B: Coincide el patr贸n {:msg, txt}<br/>txt = "Hola"
    
    B->>Console: IO.puts("Hola")
    Console-->>B: ok
    Note right of Console: Imprime: Hola
    
    Note right of B: Mailbox ahora vac铆o: []<br/>receive completado
    deactivate B
    
    Note over B: Actor B finaliza su ejecuci贸n
</div>

La comunicaci贸n entre procesos en Elixir es **as铆ncrona**, lo que significa que el proceso emisor no se bloquea ni espera a que el proceso receptor reciba el mensaje. Este enfoque favorece una mayor concurrencia y eficiencia en la ejecuci贸n, aunque, cuando el proceso emisor necesita una respuesta, debe implementar un mecanismo adicional para gestionarla.

### Ejemplo b谩sico de comunicaci贸n entre procesos

El siguiente ejemplo implementa el c贸digo del diagrama anterior, en el que un actor env铆a un mensaje a otro actor que lo recibe e imprime en la consola:

```elixir
# Definir task1 para recibir mensajes (Actor receptor)
task1_pid = spawn(fn ->
  receive do # Espera a recibir un mensaje en su mailbox
    {:mensaje, msg} -> # Si coincide el patr贸n, imprime el mensaje
      IO.puts("Mensaje recibido: #{msg}")
  end
end)

# Se env铆a un mensaje al actor task1 desde el proceso principal
send(task1_pid, {:mensaje, "Hola desde el proceso principal"})

# Mostrar mensaje de completado
IO.puts("Todas las tareas han terminado")
```

Ejecute este c贸digo y observe c贸mo el proceso principal (actor emisor) env铆a un mensaje al proceso `task1` (actor receptor), que lo recibe e imprime en la consola. En este ejemplo, el proceso hijo solo espera recibir un mensaje y luego termina su ejecuci贸n.

### Ejemplo de proceso receptor que recibe m煤ltiples mensajes

Si se desea que un actor reciba m煤ltiples mensajes, se puede utilizar un **bucle recursivo** dentro del proceso receptor para seguir esperando mensajes indefinidamente. Aqu铆 hay un ejemplo:

```elixir
# Se define un m贸dulo Receiver con una funci贸n start que crea un actor receptor
defmodule Receiver do
  def start do
    spawn(fn -> loop() end) # Crea un actor que ejecuta la funci贸n loop
  end

  defp loop do
    receive do
      {:mensaje, msg} ->
        IO.puts("Mensaje recibido: #{msg}")
        loop() # vuelve a esperar otro mensaje (estado se mantiene)
      :stop ->
        IO.puts("Proceso detenido")
        :ok # termina el actor
    end
  end
end

# Crear el actor receptor
pid = Receiver.start()

# Enviar m煤ltiples mensajes al actor receptor
send(pid, {:mensaje, "Hola 1"})
send(pid, {:mensaje, "Hola 2"})
send(pid, {:mensaje, "Hola 3"})
send(pid, :stop)
```

Ejecute este c贸digo y observe c贸mo el actor receptor puede recibir m煤ltiples mensajes y procesarlos uno tras otro. El actor tiene su `mailbox` donde almacena los mensajes recibidos hasta que los procesa.

---

## M贸dulo Process

El m贸dulo `Process` proporciona funciones para **inspeccionar, controlar y registrar procesos** dentro del entorno de ejecuci贸n de Elixir. Aunque normalmente trabajamos con procesos usando `spawn`, `send` y `receive`, este m贸dulo permite una gesti贸n m谩s detallada.

Algunas funciones 煤tiles del m贸dulo `Process` incluyen:

- `info/1`: Obtiene informaci贸n detallada sobre un proceso espec铆fico, como su estado, memoria utilizada y mensajes en la cola.
- `alive?/1`: Verifica si un proceso con un PID espec铆fico est谩 activo.
- `exit/2`: Env铆a una se帽al de terminaci贸n a un proceso.
- `register/2`: Asocia un nombre a un proceso para facilitar su referencia.
- `self/0`: Obtiene el PID del proceso actual.

Por medio del m贸dulo `Process`, es posible monitorear y controlar el comportamiento de los procesos en Elixir, lo que resulta 煤til para la depuraci贸n y gesti贸n avanzada de aplicaciones concurrentes.

> ** Nota:** Aunque m谩s adelante veremos ejemplos pr谩cticos, es recomendable consultar la documentaci贸n oficial para explorar todas las funciones disponibles en el m贸dulo `Process`.

Ejemplo con algunas funciones del m贸dulo `Process`:

```elixir
defmodule DemoProcess do
  def iniciar do
    pid = spawn(fn -> loop() end)
    Process.register(pid, :contador) # Registrar el proceso con un nombre 
    IO.puts("Proceso registrado como :contador con PID #{inspect(pid)}")

    # Enviar mensajes al proceso registrado
    send(:contador, {:sumar, 5})
    send(:contador, {:sumar, 3})
    send(:contador, :mostrar)

    # Inspeccionar el mailbox del proceso registrado
    IO.inspect(Process.info(pid, :message_queue_len), label: "Mensajes pendientes")
    # Verificar si el proceso est谩 activo
    IO.puts("驴El proceso sigue activo?: #{Process.alive?(pid)}")
  end

  defp loop(total \\ 0) do
    receive do
      {:sumar, n} -> loop(total + n)
      :mostrar ->
        IO.puts("Total acumulado: #{total}")
        loop(total)
    end
  end
end

DemoProcess.iniciar()
```

Para m谩s informaci贸n sobre el m贸dulo `Process`, puede consultar la documentaci贸n oficial en: [https://hexdocs.pm/elixir/Process.html](https://hexdocs.pm/elixir/Process.html).

---

## M贸dulo Task

El m贸dulo `Task` en Elixir proporciona una forma sencilla de crear y manejar procesos concurrentes. Permite ejecutar funciones de manera as铆ncrona y obtener resultados cuando est茅n disponibles. Sus funciones m谩s comunes son:

- `Task.async/1`: Crea un nuevo proceso que ejecuta una funci贸n de manera as铆ncrona y devuelve un struct `Task` que contiene el PID del proceso.
- `Task.await/2`: Espera a que el proceso asociado al struct `Task` termine y devuelve su resultado. Si el proceso no termina en el tiempo especificado, se lanza una excepci贸n.

Aqu铆 hay un ejemplo de c贸mo usar el m贸dulo `Task`:

```elixir
IO.puts("Iniciando programa...")

# Crear un proceso as铆ncrono (un actor que ejecuta una tarea)
task = Task.async(fn ->
  :timer.sleep(2000)  # Simula una tarea que toma tiempo
  42  # Retorna un valor
end)

# Hacer otras cosas mientras la tarea se ejecuta
IO.puts("Haciendo otras cosas...")

# Obtener el resultado de la tarea cuando est茅 listo. Esto bloquea el proceso principal hasta que la tarea termine.
result = Task.await(task)
IO.puts("El resultado de la tarea es: #{result}")
```

Si no se llama a `Task.await/1`, el proceso principal puede terminar antes de que la tarea haya completado su ejecuci贸n, lo que podr铆a resultar en que el resultado de la tarea nunca se obtenga. Por lo tanto, es **importante asegurarse de esperar** el resultado de la tarea si se necesita.

Ejecute este c贸digo y observe c贸mo el proceso principal contin煤a ejecut谩ndose mientras la tarea est谩 en progreso, y luego espera el resultado de la tarea antes de imprimirlo.

### Diagrama de concurrencia con Task

Este diagrama ilustra c贸mo el proceso principal puede crear m煤ltiples tareas (actores) que se ejecutan en paralelo y luego espera a que todas terminen para recolectar sus resultados:

<div class="mermaid" style="text-align: center;">
graph TD
    M[Proceso Principal<br/>spawn tasks concurrently]
    
    subgraph Tasks["Tareas Ejecut谩ndose (Actores)"]
        T1[Task 1<br/>PID 0.125.0<br/>Task.async fn ->]
        T2[Task 2<br/>PID 0.126.0<br/>Task.async fn ->]
        T3[Task 3<br/>PID 0.127.0<br/>Task.async fn ->]
        Tn[Task N<br/>PID 0.12X.0<br/>Task.async fn ->]
    end
    
    R[Recolecci贸n de Resultados<br/>Task.await_many tasks]
    
    Final[Proceso Principal<br/>Resultados Completos]
    
    M -.-> T1
    M -.-> T2
    M -.-> T3
    M -.-> Tn
    
    T1 --> R
    T2 --> R
    T3 --> R
    Tn --> R
    
    R --> Final
    
    style M fill:#e1f5fe
    style T1 fill:#fff3e0
    style T2 fill:#fff3e0
    style T3 fill:#fff3e0
    style Tn fill:#fff3e0
    style R fill:#f3e5f5
    style Final fill:#e8f5e8
</div>

Gracias a la funci贸n `Task.async/1`, el proceso principal puede lanzar m煤ltiples tareas (actores) que se ejecutan en paralelo, aprovechando la concurrencia de Elixir. Luego, con `Task.await/1`, puede esperar a que cada tarea termine y recolectar sus resultados de manera ordenada.

---

## Comparativa spawn vs Process vs Task

Tanto `spawn` como el m贸dulo `Process` y el m贸dulo `Task` permiten crear y manejar procesos en Elixir, pero cada uno tiene sus propias caracter铆sticas y casos de uso recomendados. A continuaci贸n, se presenta una tabla comparativa que resume las diferencias clave entre ellos:

| Caracter铆stica              | `spawn`                          | `Process`                                                       | `Task`                                       |
| --------------------------- | -------------------------------- | --------------------------------------------------------------- | -------------------------------------------- |
| **Nivel de abstracci贸n**    | Bajo nivel: solo crea procesos   | Medio nivel: permite inspeccionar y gestionar procesos          | Alto nivel: pensado para tareas              |
| **Manejo de errores**       | El proceso muere en silencio     | Permite monitorear o enlazar procesos (`monitor`, `link`)       | Los errores se propagan al creador           |
| **Obtenci贸n de resultados** | Manual, con `send/receive`       | Manual, con `send/receive`                                     | Directa, con `Task.await`                    |
| **Funciones extra**         | Ninguna                          | `register`, `whereis`, `alive?`, `exit`, `flag`                 | `async_stream`, integraci贸n con supervisores |
| **Uso recomendado**         | Casos avanzados con control fino | Depuraci贸n, registro o monitoreo de procesos                    | La mayor铆a de situaciones pr谩cticas          |
| **Modelo de Actores**       | Implementaci贸n directa           | Herramientas para gestionar actores                             | Abstracci贸n de alto nivel sobre actores      |

Para profundizar un poco m谩s en este tema puede revisar [esta p谩gina de Elixir School](https://elixirschool.com/en/lessons/intermediate/concurrency).

---

## Ejemplos pr谩cticos

A continuaci贸n, se presentan algunos ejemplos pr谩cticos que ilustran el uso de procesos y concurrencia en Elixir utilizando tanto `spawn` como el m贸dulo `Task`. Intente hacer su propia implementaci贸n de cada ejemplo para comprender mejor c贸mo funcionan los procesos en Elixir.

### Ejemplo 1

En este ejemplo, se crean dos funciones, `tarea1` y `tarea2`, que se ejecutan de manera concurrente utilizando `Task.async/1`. Cada tarea simula una operaci贸n que toma tiempo utilizando `:timer.sleep/1`. El proceso principal contin煤a ejecut谩ndose mientras las tareas est谩n en progreso y luego espera a que ambas tareas terminen para obtener sus resultados.

```elixir
defmodule Ejemplo do
  # Simula una tarea que tarda en completarse
  def tarea1 do
    IO.puts("[Tarea 1] Iniciando proceso largo...")
    :timer.sleep(3000)  # Simula una operaci贸n que toma tiempo
    "[Tarea 1] Proceso completado exitosamente"
  end

  # Simula otra tarea m谩s r谩pida
  def tarea2 do
    IO.puts("[Tarea 2] Ejecut谩ndose...")
    :timer.sleep(1000)
    "[Tarea 2] Finaliz贸 correctamente"
  end

  # Ejecuta ambas tareas de forma concurrente
  def ejecutar_tareas do
    IO.puts("Iniciando tareas concurrentes...\n")

    # Lanza ambas tareas en procesos separados (actores)
    task1 = Task.async(&tarea1/0)
    task2 = Task.async(&tarea2/0)

    IO.puts("El proceso principal sigue ejecut谩ndose mientras las tareas trabajan...\n")

    # Espera los resultados (bloquea hasta que cada tarea termine)
    result1 = Task.await(task1)
    result2 = Task.await(task2)

    IO.puts("\n--- Resultados ---")
    IO.puts(result1)
    IO.puts(result2)
  end
end

Ejemplo.ejecutar_tareas()
```

### Ejemplo 2

En este ejemplo creamos m煤ltiples tareas en un bucle y las ejecutamos tanto de manera secuencial como concurrente para comparar los tiempos de ejecuci贸n y resultados.

```elixir
defmodule EjemploMultiplesTareas do
  # Simula una tarea que toma tiempo y devuelve un mensaje
  def tarea(n) do
    IO.puts("[Tarea #{n}] Iniciando...")
    :timer.sleep(1000 * n)  # Simula una operaci贸n costosa
    IO.puts("[Tarea #{n}] Finaliz贸 despu茅s de #{n} segundos")
    "Resultado de la tarea #{n}: #{n * n}"
  end

  # Ejecuta las tareas una por una (de forma secuencial)
  def ejecutar_secuencialmente do
    IO.puts("\n=== Ejecuci贸n Secuencial ===")

    numeros = [1, 2, 3, 4, 5]

    # Ejecutar cada tarea una por una
    resultados = Enum.map(numeros, fn n -> tarea(n) end)

    IO.puts("\nResultados finales (secuencial):")
    IO.inspect(resultados)
  end

  # Ejecuta todas las tareas al mismo tiempo (de forma concurrente)
  def ejecutar_concurrentemente do
    IO.puts("\n=== Ejecuci贸n Concurrente ===")

    numeros = [1, 2, 3, 4, 5]

    # Lanzar todas las tareas en procesos separados (actores)
    tasks = Enum.map(numeros, fn n -> Task.async(fn -> tarea(n) end) end)

    # Esperar los resultados de todas las tareas. Se bloquea el proceso principal hasta que todas terminen.
    resultados = Enum.map(tasks, fn task -> Task.await(task) end)

    # Mostrar los resultados
    IO.puts("\nResultados finales (concurrente):")
    IO.inspect(resultados)
  end
end
```

Analice el c贸digo anterior y estime el tiempo que tomar铆a cada enfoque. Luego, ejecute ambas funciones para observar la diferencia en los tiempos de ejecuci贸n y los resultados obtenidos. Para ejecutar cada enfoque, escriba lo siguiente al final del archivo:

```elixir
EjemploMultiplesTareas.ejecutar_secuencialmente()
```

```elixir
EjemploMultiplesTareas.ejecutar_concurrentemente()
```

> 锔 **Importante:** Investigue sobre `:timer.tc/1` para medir el tiempo de ejecuci贸n de cada enfoque y confirmar la diferencia en eficiencia.

### Ejemplo 3

En este ejemplo, se muestra c贸mo dos procesos pueden comunicarse entre s铆 utilizando el m贸dulo `Task`, sin necesidad de usar `send` ni `receive` directamente. Aqu铆, el Proceso 2 env铆a un mensaje al Proceso 1 y espera una respuesta utilizando `Task.async` y `Task.await`.

```elixir
defmodule EjemploComunicacionTask do
  @moduledoc """
  Ejemplo de comunicaci贸n entre dos procesos en Elixir usando `Task`,
  conservando dos procesos independientes (Proceso 1 y Proceso 2) sin usar `send` ni `receive`.
  """

  # === Proceso 1 (Actor) ===
  # Recibe un mensaje, lo procesa y retorna una confirmaci贸n.
  def proceso1(msg) do
    IO.puts("[Proceso 1] Recibi贸 mensaje: #{msg}")
    :timer.sleep(500)
    IO.puts("[Proceso 1] Procesamiento completado.")
    "Confirmaci贸n desde Proceso 1: mensaje recibido correctamente."
  end

  # === Proceso 2 (Actor) ===
  # Env铆a un mensaje a Proceso 1 y espera la respuesta.
  def proceso2 do
    IO.puts("[Proceso 2] Enviando mensaje a Proceso 1...")

    # Lanza proceso 1 como una tarea as铆ncrona (un actor)
    task1 = Task.async(fn -> proceso1("隆Hola desde Proceso 2!") end)

    # Espera la respuesta del proceso 1 (bloqueante hasta 3 segundos)
    respuesta = Task.await(task1, 3000)

    IO.puts("[Proceso 2] Recibi贸 respuesta: #{respuesta}")
    IO.puts("[Proceso 2] Finalizando ejecuci贸n.")
  end

  # === Proceso principal ===
  # Inicia ambos procesos de forma controlada.
  def iniciar do
    IO.puts("=== Iniciando comunicaci贸n entre procesos ===\n")

    # Lanzamos el proceso 2 (quien a su vez invoca al proceso 1)
    task2 = Task.async(fn -> proceso2() end)

    # Esperamos a que Proceso 2 termine completamente
    Task.await(task2)

    IO.puts("\n=== Comunicaci贸n finalizada ===")
  end
end

# Ejecutar el ejemplo
EjemploComunicacionTask.iniciar()
```

### Ejemplo 4: Uso de after en receive

Haga un nuevo script que cree dos procesos: uno que env铆e un mensaje y otro que lo reciba e imprima y le env铆e una confirmaci贸n de vuelta al proceso emisor. Para este ejemplo use `spawn`, `send`, `receive` y `after`. No use `Task`.

Investigue c贸mo usar `after` en la construcci贸n `receive` para manejar casos en los que no se recibe ning煤n mensaje en un tiempo determinado. El bloque `after` **evita que los procesos queden bloqueados indefinidamente** esperando un mensaje que podr铆a no llegar.

Si creamos tareas que no deben quedar esperando para siempre, es una buena pr谩ctica usar `after` para definir un tiempo m谩ximo de espera. Por otro lado, si un proceso puede recibir mensajes en cualquier momento y no queremos que termine, podemos usar un **bucle recursivo** para mantenerlo activo.

---

## Ejercicio

### Ejercicio 1: Contador con estado 

Cree un script que implemente un actor contador utilizando procesos en Elixir. El actor debe mantener un estado interno que represente el valor del contador y debe responder a los siguientes mensajes:

- `{:incrementar, n}`: Incrementa el contador en `n`.
- `{:decrementar, n}`: Decrementa el contador en `n`.
- `{:obtener, pid}`: Env铆a el valor actual del contador al proceso con PID `pid`.
- `:reiniciar`: Reinicia el contador a 0.
- `:detener`: Detiene el actor. Retorna `:ok`.

Aseg煤rese que su implementaci贸n cumpla con las caracter铆sticas del Modelo de Actores:

- El actor mantiene **estado privado** (el valor del contador)
- Se comunica **exclusivamente mediante mensajes**
- Procesa mensajes **secuencialmente** uno a la vez
- El estado solo puede modificarse a trav茅s de la **interfaz de mensajes**
- Es completamente **aislado** de otros procesos

---

## Para la pr贸xima clase

- Investigar sobre aplicaciones distribuidas en Elixir y c贸mo los procesos pueden comunicarse a trav茅s de nodos. Puede leer sobre el m贸dulo `Node` en la documentaci贸n oficial de Elixir: [https://hexdocs.pm/elixir/Node.html](https://hexdocs.pm/elixir/Node.html).
- Leer sobre redes locales, direcciones IP y comunicaci贸n entre m谩quinas para entender mejor los sistemas distribuidos.