<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script> 
<script> 
  document.addEventListener("DOMContentLoaded", function() { mermaid.initialize({ startOnLoad: true }); }); 
</script>

```
Universidad del Quindío
Programa de Ingeniería de Sistemas y Computación
Programación III - Procesos
Docente: Carlos Andrés Florez V.
```

# Procesos

En este documento se explican los conceptos básicos sobre los procesos en Elixir y cómo manejarlos. Además, se incluyen ejemplos prácticos para ilustrar su uso.

## ¿Qué es un proceso?

En los **sistemas operativos**, un **proceso** es un programa en ejecución que posee su propio espacio de memoria y los recursos necesarios para funcionar. Cada proceso es **independiente** y puede ejecutarse de forma **concurrente** con otros.

Por ejemplo, un sistema operativo es capaz de **gestionar la ejecución concurrente** de distintos programas, como un reproductor de música, un navegador web y un editor de texto, garantizando que cada uno disponga de los recursos necesarios sin interferir con los demás.

## ¿Qué es concurrencia?

La concurrencia es la **capacidad de un sistema para gestionar múltiples tareas o procesos al mismo tiempo**, compartiendo los recursos disponibles. Por ejemplo, en un sistema operativo, la concurrencia permite que varios programas se ejecuten *simultáneamente en apariencia*, alternando su uso de la CPU.

Por su parte, el **paralelismo** se refiere a la **ejecución real y simultánea de múltiples tareas**, aprovechando la existencia de **varios procesadores o núcleos**. En este caso, cada tarea se ejecuta literalmente al mismo tiempo en diferentes unidades de procesamiento. Por ejemplo, en un computador con varios núcleos, un núcleo puede procesar datos mientras otro renderiza gráficos, logrando así una ejecución verdaderamente paralela.

> ⚠️ La diferencia clave entre concurrencia y paralelismo radica en que la **concurrencia** se enfoca en la gestión eficiente de múltiples tareas, mientras que el **paralelismo** se centra en la ejecución simultánea de esas tareas.

---

## El Modelo de Actores

Antes de profundizar en los procesos de Elixir, es importante entender el **Modelo de Actores**, que es el paradigma de concurrencia sobre el cual están construidos Elixir y Erlang.

### ¿Qué es el Modelo de Actores?

El **Modelo de Actores** es un modelo matemático de computación concurrente propuesto por Carl Hewitt en 1973. En este modelo, los **"actores"** son las unidades fundamentales de computación que:

1. **Tienen estado privado**: Cada actor mantiene su propio estado interno que no puede ser accedido directamente por otros actores.
2. **Se comunican mediante mensajes**: Los actores se comunican exclusivamente enviando mensajes asíncronos entre sí.
3. **Procesan un mensaje a la vez**: Cada actor procesa los mensajes de su buzón (*mailbox*) de forma secuencial.
4. **Pueden crear nuevos actores**: Un actor puede crear (*spawn*) otros actores.
5. **Son completamente aislados**: Si un actor falla, no afecta a los demás.

### Modelo de Actores vs Hilos Tradicionales

En otros lenguajes de programación, la concurrencia suele implementarse mediante **hilos tradicionales**, que comparten memoria y requieren mecanismos de sincronización complejos. A continuación, se presenta una tabla comparativa entre ambos enfoques:

| Característica | Hilos Tradicionales | Modelo de Actores |
|----------------|---------------------|-------------------|
| **Memoria** | Compartida | Aislada (sin compartir) |
| **Comunicación** | Variables compartidas + locks | Mensajes asíncronos |
| **Sincronización** | Semáforos, mutex, locks | No necesaria |
| **Problemas comunes** | Race conditions, deadlocks | Más difíciles de producir |
| **Escalabilidad** | Limitada por locks | Alta (miles/millones de actores) |
| **Peso** | Pesados (MB de memoria) | Ligeros (KB de memoria) |

### ¿Por qué es importante en Elixir?

El Modelo de Actores es la razón por la cual Elixir puede:

- Ejecutar **millones de procesos** concurrentemente en una sola máquina
- Construir sistemas **altamente disponibles** y **tolerantes a fallos**
- Escalar **horizontalmente** de forma natural (distribución en múltiples nodos)
- Evitar problemas complejos de sincronización que plagan otros lenguajes

El modelo de actores define la base sobre la cual Elixir implementa su sistema de concurrencia y distribución, permitiendo a los desarrolladores construir aplicaciones robustas y escalables de manera sencilla.

---

## Procesos en Elixir

En **Elixir (y Erlang)** también se utiliza el concepto de *proceso*, aunque no se refiere a procesos del sistema operativo, sino a **procesos ligeros gestionados por la máquina virtual BEAM** que implementan el Modelo de Actores.

Esto implica que:

* Son mucho más **ligeros** que los procesos del sistema operativo (ocupan apenas unos kilobytes).
* Pueden escalar hasta **miles o incluso millones** de procesos concurrentes en una sola máquina.
* Están **completamente aislados**: no comparten memoria, cada uno tiene su propio estado.
* Se **comunican mediante el envío de mensajes** (`send` y `receive`), siguiendo el Modelo de Actores.
* Si uno falla, **no afecta a los demás**, lo que otorga alta **tolerancia a fallos**.
* Cada proceso tiene su propia **cola de mensajes (mailbox)** donde se almacenan los mensajes entrantes.

Gracias a estas características, Elixir resulta especialmente adecuado para construir **sistemas concurrentes y distribuidos**, como servidores web, aplicaciones de mensajería o sistemas que requieren alta disponibilidad.

## Creación de procesos en Elixir

Al ejecutar un programa en Elixir, se crea automáticamente un **proceso principal**, encargado de iniciar la ejecución del código. Todo el programa se ejecuta inicialmente dentro de este proceso, que actúa como punto de partida para el resto de la aplicación. Sin embargo, Elixir permite **crear procesos adicionales** que pueden ejecutar tareas de forma **concurrente** y **aislada**, sin interferir ni bloquear al proceso principal.

Esta capacidad de dividir el trabajo entre varios procesos permite aprovechar mejor los recursos del sistema y brindar una experiencia más fluida al usuario.

### Ejemplo básico de creación de procesos

A continuación, se presentan algunas formas de crear procesos en Elixir mediante las funciones `spawn/1` y `spawn/3`.

**Ejemplo con `spawn/1`:**

Aunque no es necesario definir un módulo para crear un proceso, es una buena práctica para organizar el código. Aquí hay un ejemplo simple:

```elixir
defmodule MiModulo do
  def mi_funcion do
    IO.puts("Hola desde el proceso hijo!")
  end
end

IO.puts("Iniciando proceso...")
spawn(fn -> MiModulo.mi_funcion() end) # Se crea un proceso (un actor)
IO.puts("Proceso principal finalizado.")
``` 

Ejecute este código y verá que el mensaje del proceso hijo se imprime en la consola. El proceso principal continúa su ejecución sin esperar a que el proceso hijo termine.

**Ejemplo con `spawn/3`:**

Otra forma de crear procesos es utilizar `spawn/3` como se muestra a continuación:

```elixir
defmodule MiModulo do
  def mi_funcion(arg) do
    IO.puts("Hola desde el proceso hijo!")
    IO.puts("Argumento recibido: #{arg}")
  end
end

IO.puts("Iniciando proceso...")
spawn(MiModulo, :mi_funcion, ["Elixir"]) # Se crea un proceso
IO.puts("Proceso principal finalizado.")
```

Hace lo mismo que el ejemplo anterior, solo cambia la forma de llamar a la función. Esta forma es útil cuando se desea llamar a una función específica de un módulo con argumentos.

### Proceso principal y procesos hijos

Como se mencionó anteriormente, existe un **proceso principal**, encargado de iniciar la ejecución del programa y de generar los demás procesos. Cuando este proceso principal finaliza, **todos los procesos hijos también terminan**, ya que dependen de él para mantenerse en ejecución.

En los ejemplos anteriores, dado que el **proceso hijo no realiza una tarea costosa**, no hay inconveniente, pues alcanza a completarse antes de que el proceso principal termine. Sin embargo, si el proceso hijo ejecuta una tarea que requiere más tiempo, es posible que **no logre finalizarla** antes de que el proceso principal concluya, lo que puede producir resultados inesperados.

Por ejemplo:

```elixir
defmodule MiModulo do
  def mi_funcion do
    :timer.sleep(2000)  # Simula una tarea que toma tiempo
    IO.puts("Hola desde el proceso hijo después de 2 segundos!")
  end
end

IO.puts("Iniciando proceso...")
spawn(fn -> MiModulo.mi_funcion() end) # Se crea un proceso
IO.puts("Proceso principal finalizado.")
```

Ejecute este código y observe el comportamiento.

En este caso, es probable que el mensaje del proceso hijo no se imprima, ya que el **proceso principal termina antes de que el proceso hijo complete su tarea**. Para evitar esto, se puede agregar una pausa en el proceso principal para darle tiempo al proceso hijo de completarse. Modifique el código anterior agregando `:timer.sleep(3000)` justo antes de imprimir "Proceso principal finalizado." y vuelva a ejecutar el código para ver la diferencia.

Usar `:timer.sleep/1` en el proceso principal puede funcionar como una solución rápida para dar tiempo a que los procesos hijos finalicen, pero no es una práctica recomendable. En lugar de depender de pausas temporales, existen mecanismos más robustos y eficientes en Elixir para gestionar esto. Más adelante los estudiaremos.

## Identificadores de procesos (PIDs)

Cada proceso tiene un **identificador único llamado PID** (*Process Identifier*), que se utiliza para referenciar y comunicarse con ese proceso. La función `spawn` devuelve el PID del proceso creado, lo que permite almacenarlo en una variable para futuras interacciones.

Por ejemplo, al crear varios procesos, se pueden obtener sus PIDs de la siguiente manera:

```elixir
pid1 = spawn(MiModulo, :mi_funcion, ["Elixir"])
IO.puts("El PID del proceso es: #{inspect(pid1)}")

pid2 = spawn(MiModulo, :mi_funcion, ["Erlang"])
IO.puts("El PID del proceso es: #{inspect(pid2)}")
```

Asimismo, se puede obtener el identificador del proceso actual (PID) mediante la función `self/0`:

```elixir
defmodule MiModulo do
  def mi_funcion(numero) do
    IO.inspect(self(), label: "Ejecuto la tarea #{numero}") # Muestra el PID del proceso actual
  end
end

# Se muestra el PID del proceso principal
IO.inspect(self(), label: "Proceso principal iniciado")

# Se crean dos procesos hijos concurrentes (dos actores)
spawn(fn -> MiModulo.mi_funcion(1) end)
spawn(fn -> MiModulo.mi_funcion(2) end)

IO.puts("Proceso principal finalizado.")
```

Ejecute este código y observe cómo **cada proceso tiene un PID diferente**, lo que indica que son procesos **independientes** que se ejecutan de manera **concurrente**. Cada uno es un actor con su propio estado y mailbox. Pruebe creando más procesos y observe sus PID únicos.

---

## Comunicación entre procesos

Los procesos en Elixir (actores) pueden comunicarse entre sí utilizando **mensajes**. Cada proceso tiene una **cola de mensajes** (*mailbox*) donde puede recibir mensajes de otros procesos. Para enviar un mensaje a otro proceso, se utiliza la función `send/2`, que toma el PID (identificador del proceso) del proceso receptor y el mensaje que se desea enviar. El proceso receptor puede recibir mensajes utilizando la construcción `receive`, que bloquea la ejecución del proceso hasta que llegue un mensaje.

### Diagrama de comunicación entre procesos

Este diagrama ilustra cómo dos procesos (actores) pueden comunicarse entre sí mediante el envío y recepción de mensajes:

<div class="mermaid" style="text-align: center;">
sequenceDiagram
    participant A as Actor A<br/>PID 0.50
    participant B as Actor B<br/>PID 0.51
    participant Console as Terminal/Console
    
    Note over A,B: Comunicación asíncrona<br/>(Modelo de Actores)
    
    A->>B: send(pidB, {:msg, "Hola"})
    Note right of B: Mensaje almacenado en mailbox<br/>[{:msg, "Hola"}]
    
    Note over B: Actor B ejecuta receive
    activate B
    B->>B: receive do<br/>{:msg, txt} -> IO.puts(txt)<br/>end
    Note right of B: Coincide el patrón {:msg, txt}<br/>txt = "Hola"
    
    B->>Console: IO.puts("Hola")
    Console-->>B: ok
    Note right of Console: Imprime: Hola
    
    Note right of B: Mailbox ahora vacío: []<br/>receive completado
    deactivate B
    
    Note over B: Actor B finaliza su ejecución
</div>

La comunicación entre procesos en Elixir es **asíncrona**, lo que significa que el proceso emisor no se bloquea ni espera a que el proceso receptor reciba el mensaje. Este enfoque favorece una mayor concurrencia y eficiencia en la ejecución, aunque, cuando el proceso emisor necesita una respuesta, debe implementar un mecanismo adicional para gestionarla.

### Ejemplo básico de comunicación entre procesos

El siguiente ejemplo implementa el código del diagrama anterior, en el que un actor envía un mensaje a otro actor que lo recibe e imprime en la consola:

```elixir
# Definir task1 para recibir mensajes (Actor receptor)
task1_pid = spawn(fn ->
  receive do # Espera a recibir un mensaje en su mailbox
    {:mensaje, msg} -> # Si coincide el patrón, imprime el mensaje
      IO.puts("Mensaje recibido: #{msg}")
  end
end)

# Se envía un mensaje al actor task1 desde el proceso principal
send(task1_pid, {:mensaje, "Hola desde el proceso principal"})

# Mostrar mensaje de completado
IO.puts("Todas las tareas han terminado")
```

Ejecute este código y observe cómo el proceso principal (actor emisor) envía un mensaje al proceso `task1` (actor receptor), que lo recibe e imprime en la consola. En este ejemplo, el proceso hijo solo espera recibir un mensaje y luego termina su ejecución.

### Ejemplo de proceso receptor que recibe múltiples mensajes

Si se desea que un actor reciba múltiples mensajes, se puede utilizar un **bucle recursivo** dentro del proceso receptor para seguir esperando mensajes indefinidamente. Aquí hay un ejemplo:

```elixir
# Se define un módulo Receiver con una función start que crea un actor receptor
defmodule Receiver do
  def start do
    spawn(fn -> loop() end) # Crea un actor que ejecuta la función loop
  end

  defp loop do
    receive do
      {:mensaje, msg} ->
        IO.puts("Mensaje recibido: #{msg}")
        loop() # vuelve a esperar otro mensaje (estado se mantiene)
      :stop ->
        IO.puts("Proceso detenido")
        :ok # termina el actor
    end
  end
end

# Crear el actor receptor
pid = Receiver.start()

# Enviar múltiples mensajes al actor receptor
send(pid, {:mensaje, "Hola 1"})
send(pid, {:mensaje, "Hola 2"})
send(pid, {:mensaje, "Hola 3"})
send(pid, :stop)
```

Ejecute este código y observe cómo el actor receptor puede recibir múltiples mensajes y procesarlos uno tras otro. El actor tiene su `mailbox` donde almacena los mensajes recibidos hasta que los procesa.

---

## Módulo Process

El módulo `Process` proporciona funciones para **inspeccionar, controlar y registrar procesos** dentro del entorno de ejecución de Elixir. Aunque normalmente trabajamos con procesos usando `spawn`, `send` y `receive`, este módulo permite una gestión más detallada.

Algunas funciones útiles del módulo `Process` incluyen:

- `Process.info/1`: Obtiene información detallada sobre un proceso específico, como su estado, memoria utilizada y mensajes en la cola.
- `Process.alive?/1`: Verifica si un proceso con un PID específico está activo.
- `Process.exit/2`: Envía una señal de terminación a un proceso.
- `Process.register/2`: Asocia un nombre a un proceso para facilitar su referencia.
- `Process.self/0`: Obtiene el PID del proceso actual.

Por medio del módulo `Process`, es posible monitorear y controlar el comportamiento de los procesos en Elixir, lo que resulta útil para la depuración y gestión avanzada de aplicaciones concurrentes.

Ejemplo con algunas funciones del módulo `Process`:

```elixir
defmodule DemoProcess do
  def iniciar do
    pid = spawn(fn -> loop() end)
    Process.register(pid, :contador) # Registrar el proceso con un nombre 
    IO.puts("Proceso registrado como :contador con PID #{inspect(pid)}")

    # Enviar mensajes al proceso registrado
    send(:contador, {:sumar, 5})
    send(:contador, {:sumar, 3})
    send(:contador, :mostrar)

    # Inspeccionar el mailbox del proceso registrado
    IO.inspect(Process.info(pid, :message_queue_len), label: "Mensajes pendientes")
    # Verificar si el proceso está activo
    IO.puts("¿El proceso sigue activo?: #{Process.alive?(pid)}")
  end

  defp loop(total \\ 0) do
    receive do
      {:sumar, n} -> loop(total + n)
      :mostrar ->
        IO.puts("Total acumulado: #{total}")
        loop(total)
    end
  end
end

DemoProcess.iniciar()
```

Para más información sobre el módulo `Process`, puede consultar la documentación oficial en: [https://hexdocs.pm/elixir/Process.html](https://hexdocs.pm/elixir/Process.html).

---

## Módulo Task

El módulo `Task` en Elixir proporciona una forma sencilla de crear y manejar procesos concurrentes. Permite ejecutar funciones de manera asíncrona y obtener resultados cuando estén disponibles. Sus funciones más comunes son:

- `Task.async/1`: Crea un nuevo proceso que ejecuta una función de manera asíncrona y devuelve un struct `Task` que contiene el PID del proceso.
- `Task.await/2`: Espera a que el proceso asociado al struct `Task` termine y devuelve su resultado. Si el proceso no termina en el tiempo especificado, se lanza una excepción.

Aquí hay un ejemplo de cómo usar el módulo `Task`:

```elixir
IO.puts("Iniciando programa...")

# Crear un proceso asíncrono (un actor que ejecuta una tarea)
task = Task.async(fn ->
  :timer.sleep(2000)  # Simula una tarea que toma tiempo
  42  # Retorna un valor
end)

# Hacer otras cosas mientras la tarea se ejecuta
IO.puts("Haciendo otras cosas...")

# Obtener el resultado de la tarea cuando esté listo. Esto bloquea el proceso principal hasta que la tarea termine.
result = Task.await(task)
IO.puts("El resultado de la tarea es: #{result}")
```

Si no se llama a `Task.await/1`, el proceso principal puede terminar antes de que la tarea haya completado su ejecución, lo que podría resultar en que el resultado de la tarea nunca se obtenga. Por lo tanto, es **importante asegurarse de esperar** el resultado de la tarea si se necesita.

Ejecute este código y observe cómo el proceso principal continúa ejecutándose mientras la tarea está en progreso, y luego espera el resultado de la tarea antes de imprimirlo.

### Diagrama de concurrencia con Task

Este diagrama ilustra cómo el proceso principal puede crear múltiples tareas (actores) que se ejecutan en paralelo y luego espera a que todas terminen para recolectar sus resultados:

<div class="mermaid" style="text-align: center;">
graph TD
    M[Proceso Principal<br/>spawn tasks concurrently]
    
    subgraph Tasks["Tareas Ejecutándose (Actores)"]
        T1[Task 1<br/>PID 0.125.0<br/>Task.async fn ->]
        T2[Task 2<br/>PID 0.126.0<br/>Task.async fn ->]
        T3[Task 3<br/>PID 0.127.0<br/>Task.async fn ->]
        Tn[Task N<br/>PID 0.12X.0<br/>Task.async fn ->]
    end
    
    R[Recolección de Resultados<br/>Task.await_many tasks]
    
    Final[Proceso Principal<br/>Resultados Completos]
    
    M -.-> T1
    M -.-> T2
    M -.-> T3
    M -.-> Tn
    
    T1 --> R
    T2 --> R
    T3 --> R
    Tn --> R
    
    R --> Final
    
    style M fill:#e1f5fe
    style T1 fill:#fff3e0
    style T2 fill:#fff3e0
    style T3 fill:#fff3e0
    style Tn fill:#fff3e0
    style R fill:#f3e5f5
    style Final fill:#e8f5e8
</div>

Gracias a la función `Task.async/1`, el proceso principal puede lanzar múltiples tareas (actores) que se ejecutan en paralelo, aprovechando la concurrencia de Elixir. Luego, con `Task.await/1`, puede esperar a que cada tarea termine y recolectar sus resultados de manera ordenada.

---

## Comparativa spawn vs Process vs Task

Tanto `spawn` como el módulo `Process` y el módulo `Task` permiten crear y manejar procesos en Elixir, pero cada uno tiene sus propias características y casos de uso recomendados. A continuación, se presenta una tabla comparativa que resume las diferencias clave entre ellos:

| Característica              | `spawn`                          | `Process`                                                       | `Task`                                       |
| --------------------------- | -------------------------------- | --------------------------------------------------------------- | -------------------------------------------- |
| **Nivel de abstracción**    | Bajo nivel: solo crea procesos   | Medio nivel: permite inspeccionar y gestionar procesos          | Alto nivel: pensado para tareas              |
| **Manejo de errores**       | El proceso muere en silencio     | Permite monitorear o enlazar procesos (`monitor`, `link`)       | Los errores se propagan al creador           |
| **Obtención de resultados** | Manual, con `send/receive`       | Manual, con `send/receive`                                     | Directa, con `Task.await`                    |
| **Funciones extra**         | Ninguna                          | `register`, `whereis`, `alive?`, `exit`, `flag`                 | `async_stream`, integración con supervisores |
| **Uso recomendado**         | Casos avanzados con control fino | Depuración, registro o monitoreo de procesos                    | La mayoría de situaciones prácticas          |
| **Modelo de Actores**       | Implementación directa           | Herramientas para gestionar actores                             | Abstracción de alto nivel sobre actores      |

Para profundizar un poco más en este tema puede revisar [esta página de Elixir School](https://elixirschool.com/en/lessons/intermediate/concurrency).

---

## Ejemplos prácticos

A continuación, se presentan algunos ejemplos prácticos que ilustran el uso de procesos y concurrencia en Elixir utilizando tanto `spawn` como el módulo `Task`.

### Ejemplo 1

En este ejemplo, se crean dos funciones, `tarea1` y `tarea2`, que se ejecutan de manera concurrente utilizando `Task.async/1`. Cada tarea simula una operación que toma tiempo utilizando `:timer.sleep/1`. El proceso principal continúa ejecutándose mientras las tareas están en progreso y luego espera a que ambas tareas terminen para obtener sus resultados.

```elixir
defmodule Ejemplo do
  # Simula una tarea que tarda en completarse
  def tarea1 do
    IO.puts("[Tarea 1] Iniciando proceso largo...")
    :timer.sleep(3000)  # Simula una operación que toma tiempo
    "[Tarea 1] Proceso completado exitosamente"
  end

  # Simula otra tarea más rápida
  def tarea2 do
    IO.puts("[Tarea 2] Ejecutándose...")
    :timer.sleep(1000)
    "[Tarea 2] Finalizó correctamente"
  end

  # Ejecuta ambas tareas de forma concurrente
  def ejecutar_tareas do
    IO.puts("Iniciando tareas concurrentes...\n")

    # Lanza ambas tareas en procesos separados (actores)
    task1 = Task.async(&tarea1/0)
    task2 = Task.async(&tarea2/0)

    IO.puts("El proceso principal sigue ejecutándose mientras las tareas trabajan...\n")

    # Espera los resultados (bloquea hasta que cada tarea termine)
    result1 = Task.await(task1)
    result2 = Task.await(task2)

    IO.puts("\n--- Resultados ---")
    IO.puts(result1)
    IO.puts(result2)
  end
end

Ejemplo.ejecutar_tareas()
```

### Ejemplo 2

En este ejemplo creamos múltiples tareas en un bucle y las ejecutamos tanto de manera secuencial como concurrente para comparar los tiempos de ejecución y resultados.

```elixir
defmodule EjemploMultiplesTareas do
  # Simula una tarea que toma tiempo y devuelve un mensaje
  def tarea(n) do
    IO.puts("[Tarea #{n}] Iniciando...")
    :timer.sleep(1000 * n)  # Simula una operación costosa
    IO.puts("[Tarea #{n}] Finalizó después de #{n} segundos")
    "Resultado de la tarea #{n}: #{n * n}"
  end

  # Ejecuta las tareas una por una (de forma secuencial)
  def ejecutar_secuencialmente do
    IO.puts("\n=== Ejecución Secuencial ===")

    numeros = [1, 2, 3, 4, 5]

    # Ejecutar cada tarea una por una
    resultados = Enum.map(numeros, fn n -> tarea(n) end)

    IO.puts("\nResultados finales (secuencial):")
    IO.inspect(resultados)
  end

  # Ejecuta todas las tareas al mismo tiempo (de forma concurrente)
  def ejecutar_concurrentemente do
    IO.puts("\n=== Ejecución Concurrente ===")

    numeros = [1, 2, 3, 4, 5]

    # Lanzar todas las tareas en procesos separados (actores)
    tasks = Enum.map(numeros, fn n -> Task.async(fn -> tarea(n) end) end)

    # Esperar los resultados de todas las tareas. Se bloquea el proceso principal hasta que todas terminen.
    resultados = Enum.map(tasks, fn task -> Task.await(task) end)

    # Mostrar los resultados
    IO.puts("\nResultados finales (concurrente):")
    IO.inspect(resultados)
  end
end
```

Analice el código anterior y estime el tiempo que tomaría cada enfoque. Luego, ejecute ambas funciones para observar la diferencia en los tiempos de ejecución y los resultados obtenidos. Para ejecutar cada enfoque, escriba lo siguiente al final del archivo:

```elixir
EjemploMultiplesTareas.ejecutar_secuencialmente()
```

```elixir
EjemploMultiplesTareas.ejecutar_concurrentemente()
```

> ⚠️ **Importante:** Investigue sobre `:timer.tc/1` para medir el tiempo de ejecución de cada enfoque y confirmar la diferencia en eficiencia.

### Ejemplo 3

En este ejemplo, se muestra cómo dos procesos pueden comunicarse entre sí utilizando el módulo `Task`, sin necesidad de usar `send` ni `receive` directamente. Aquí, el Proceso 2 envía un mensaje al Proceso 1 y espera una respuesta utilizando `Task.async` y `Task.await`.

```elixir
defmodule EjemploComunicacionTask do
  @moduledoc """
  Ejemplo de comunicación entre dos procesos en Elixir usando `Task`,
  conservando dos procesos independientes (Proceso 1 y Proceso 2) sin usar `send` ni `receive`.
  """

  # === Proceso 1 (Actor) ===
  # Recibe un mensaje, lo procesa y retorna una confirmación.
  def proceso1(msg) do
    IO.puts("[Proceso 1] Recibió mensaje: #{msg}")
    :timer.sleep(500)
    IO.puts("[Proceso 1] Procesamiento completado.")
    "Confirmación desde Proceso 1: mensaje recibido correctamente."
  end

  # === Proceso 2 (Actor) ===
  # Envía un mensaje a Proceso 1 y espera la respuesta.
  def proceso2 do
    IO.puts("[Proceso 2] Enviando mensaje a Proceso 1...")

    # Lanza proceso 1 como una tarea asíncrona (un actor)
    task1 = Task.async(fn -> proceso1("¡Hola desde Proceso 2!") end)

    # Espera la respuesta del proceso 1 (bloqueante hasta 3 segundos)
    respuesta = Task.await(task1, 3000)

    IO.puts("[Proceso 2] Recibió respuesta: #{respuesta}")
    IO.puts("[Proceso 2] Finalizando ejecución.")
  end

  # === Proceso principal ===
  # Inicia ambos procesos de forma controlada.
  def iniciar do
    IO.puts("=== Iniciando comunicación entre procesos ===\n")

    # Lanzamos el proceso 2 (quien a su vez invoca al proceso 1)
    task2 = Task.async(fn -> proceso2() end)

    # Esperamos a que Proceso 2 termine completamente
    Task.await(task2)

    IO.puts("\n=== Comunicación finalizada ===")
  end
end

# Ejecutar el ejemplo
EjemploComunicacionTask.iniciar()
```

### Ejemplo 4: Uso de after en receive

Haga un nuevo script que cree dos procesos: uno que envíe un mensaje y otro que lo reciba e imprima y le envíe una confirmación de vuelta al proceso emisor. Para este ejemplo use `spawn`, `send`, `receive` y `after`. No use `Task`.

Investigue cómo usar `after` en la construcción `receive` para manejar casos en los que no se recibe ningún mensaje en un tiempo determinado. El bloque `after` **evita que los procesos queden bloqueados indefinidamente** esperando un mensaje que podría no llegar.

**Ejemplo de solución:**

```elixir
defmodule EjemploAfter do
  @moduledoc """
  Ejemplo de comunicación entre procesos (actores) usando spawn, send, receive y after.
  El Proceso B envía un mensaje al Proceso A y espera confirmación.
  """

  # Proceso A: Recibe mensaje y envía confirmación
  def proceso_a do
    receive do
      {:mensaje, contenido, pid_emisor} ->
        IO.puts("[Proceso A] Mensaje recibido: #{contenido}")
        :timer.sleep(1000)  # Simula procesamiento
        send(pid_emisor, {:confirmacion, "Mensaje procesado exitosamente"})
        IO.puts("[Proceso A] Confirmación enviada")
    after
      5000 ->
        IO.puts("[Proceso A] Timeout: No se recibió mensaje en 5 segundos")
    end
  end

  # Proceso B: Envía mensaje y espera confirmación
  def proceso_b(pid_proceso_a) do
    IO.puts("[Proceso B] Enviando mensaje a Proceso A...")
    send(pid_proceso_a, {:mensaje, "Hola desde Proceso B", self()})

    receive do
      {:confirmacion, respuesta} ->
        IO.puts("[Proceso B] Confirmación recibida: #{respuesta}")
    after
      3000 ->
        IO.puts("[Proceso B] Timeout: No se recibió confirmación en 3 segundos")
    end
  end

  # Iniciar la comunicación entre procesos
  def iniciar do
    IO.puts("=== Iniciando comunicación entre procesos ===\n")

    # Crear Proceso A
    pid_a = spawn(fn -> proceso_a() end)

    # Crear Proceso B que se comunica con Proceso A
    pid_b = spawn(fn -> proceso_b(pid_a) end)

    # Esperar a que terminen (no recomendado en producción, solo para demo)
    :timer.sleep(4000)

    IO.puts("\n=== Comunicación finalizada ===")
  end
end

# Ejecutar el ejemplo
EjemploAfter.iniciar()
```

Si creamos tareas que no deben quedar esperando para siempre, es una buena práctica usar `after` para definir un tiempo máximo de espera. Por otro lado, si un proceso puede recibir mensajes en cualquier momento y no queremos que termine, podemos usar un **bucle recursivo** para mantenerlo activo.

### Ejemplo 5: Contador con estado (Actor Pattern)

Este ejemplo demuestra el patrón clásico de un actor con estado interno que responde a diferentes tipos de mensajes:

```elixir
defmodule ContadorActor do
  @moduledoc """
  Implementación de un actor contador que mantiene estado interno.
  Demuestra el Modelo de Actores puro en Elixir.
  """

  # API pública para crear el actor
  def start(valor_inicial \\ 0) do
    spawn(fn -> loop(valor_inicial) end)
  end

  # Funciones de interfaz para interactuar con el actor
  def incrementar(pid, cantidad \\ 1) do
    send(pid, {:incrementar, cantidad})
  end

  def decrementar(pid, cantidad \\ 1) do
    send(pid, {:decrementar, cantidad})
  end

  def obtener_valor(pid) do
    send(pid, {:obtener, self()})
    receive do
      {:valor, n} -> n
    after
      1000 -> {:error, :timeout}
    end
  end

  def reiniciar(pid) do
    send(pid, :reiniciar)
  end

  def detener(pid) do
    send(pid, :detener)
  end

  # Implementación privada del bucle del actor
  defp loop(valor) do
    receive do
      {:incrementar, cantidad} ->
        nuevo_valor = valor + cantidad
        IO.puts("[Contador] Incrementado en #{cantidad}. Nuevo valor: #{nuevo_valor}")
        loop(nuevo_valor)

      {:decrementar, cantidad} ->
        nuevo_valor = valor - cantidad
        IO.puts("[Contador] Decrementado en #{cantidad}. Nuevo valor: #{nuevo_valor}")
        loop(nuevo_valor)

      {:obtener, pid_solicitante} ->
        send(pid_solicitante, {:valor, valor})
        loop(valor)

      :reiniciar ->
        IO.puts("[Contador] Reiniciado a 0")
        loop(0)

      :detener ->
        IO.puts("[Contador] Detenido. Valor final: #{valor}")
        :ok  # Termina el actor
    end
  end
end

# Ejemplo de uso
defmodule DemoContador do
  def run do
    IO.puts("=== Demo de Actor Contador ===\n")

    # Crear el actor
    contador = ContadorActor.start(10)

    # Interactuar con el actor
    ContadorActor.incrementar(contador, 5)
    ContadorActor.incrementar(contador, 3)
    ContadorActor.decrementar(contador, 2)

    # Obtener el valor actual
    valor = ContadorActor.obtener_valor(contador)
    IO.puts("\nValor actual del contador: #{valor}")

    ContadorActor.reiniciar(contador)
    nuevo_valor = ContadorActor.obtener_valor(contador)
    IO.puts("Valor después de reiniciar: #{nuevo_valor}")

    # Detener el actor
    ContadorActor.detener(contador)

    IO.puts("\n=== Demo finalizada ===")
  end
end

# Ejecutar la demo
DemoContador.run()
```

Este ejemplo ilustra perfectamente el **Modelo de Actores**:
- El actor mantiene **estado privado** (el valor del contador)
- Se comunica **exclusivamente mediante mensajes**
- Procesa mensajes **secuencialmente** uno a la vez
- El estado solo puede modificarse a través de la **interfaz de mensajes**
- Es completamente **aislado** de otros procesos

---

## Para la próxima clase

- Investigar sobre **aplicaciones distribuidas** en Elixir y cómo los procesos pueden comunicarse a través de nodos. Puede leer sobre el módulo `Node` en la documentación oficial de Elixir: [https://hexdocs.pm/elixir/Node.html](https://hexdocs.pm/elixir/Node.html).
- Leer sobre **redes locales, direcciones IP y comunicación entre máquinas** para entender mejor los sistemas distribuidos.