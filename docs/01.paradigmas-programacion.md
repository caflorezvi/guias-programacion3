<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script> 
<script> 
  document.addEventListener("DOMContentLoaded", function() { mermaid.initialize({ startOnLoad: true }); }); 
</script>

```
Universidad del Quindío
Programa de Ingeniería de Sistemas y Computación
Programación III - Una Introducción a los Paradigmas de Programación
Docente: Carlos Andrés Florez V.
```

# Una Introducción a los Paradigmas de Programación

## ¿Qué es un Paradigma de Programación?

Un **paradigma de programación** es una filosofía, un estilo o una manera de pensar para resolver problemas utilizando un lenguaje de programación. No es un lenguaje en sí mismo, sino un conjunto de ideas, principios y conceptos que dan forma a cómo estructuramos y escribimos nuestro código.

Podemos pensar en ello con una analogía culinaria:
-   Un **paradigma** es como un estilo de cocina (ej. "cocina a la parrilla", "cocina al vapor"). Define el enfoque general.
-   Un **lenguaje de programación** es como una herramienta específica (ej. "parrilla de carbón", "vaporera", "horno").

Diferentes paradigmas son adecuados para resolver diferentes tipos de problemas. Los dos grandes enfoques o familias de paradigmas son el **Imperativo** y el **Declarativo**.

<div class="mermaid" style="text-align: center;">
graph TD
    A["Paradigmas de Programación"] --> B["Imperativo<br/><i>(Cómo hacerlo)</i>"]
    A --> C["Declarativo<br/><i>(Qué hacer)</i>"]
    
    B --> D["Procedimental"]
    B --> E["Orientado a Objetos (POO)"]
    
    C --> F["Funcional (FP)"]
    C --> G["Lógico"]
    
    subgraph " "
    D1["Secuencias de instrucciones<br/>(C, Pascal)"]
    E1["Objetos, mensajes, estado encapsulado<br/>(Java, C++, Python)"]
    F1["Funciones puras, inmutabilidad<br/>(Elixir, Haskell, Lisp)"]
    G1["Hechos y reglas lógicas<br/>(Prolog)"]
    end

    D -.-> D1
    E -.-> E1
    F -.-> F1
    G -.-> G1

    classDef top fill:#333,color:#fff,stroke-width:2px,stroke:#fff
    classDef imperative fill:#e74c3c,color:#fff,stroke-width:2px,stroke:#fff
    classDef declarative fill:#3498db,color:#fff,stroke-width:2px,stroke:#fff
    class A top
    class B imperative
    class C declarative
</div>

## El Enfoque Imperativo: Dando Órdenes

La programación imperativa se centra en describir **cómo** debe realizarse una tarea. El código es una secuencia de instrucciones explícitas que modifican el estado del programa paso a paso. Es como dar una receta detallada a un cocinero: "primero, corta las cebollas; segundo, calienta el aceite; tercero, añade las cebollas a la sartén".

### Programación Orientada a Objetos (POO)

Es el sub-paradigma imperativo más popular. Organiza el código en torno a "objetos", que son unidades que agrupan datos (atributos) y los comportamientos que operan sobre esos datos (métodos).

**Principios Clave de la POO**:
- **Encapsulamiento**: Los datos de un objeto son privados. Solo se puede acceder a ellos o modificarlos a través de los métodos públicos del objeto. Esto protege el estado de modificaciones indebidas.
- **Herencia**: Una clase puede heredar atributos y métodos de otra, permitiendo la reutilización de código.
- **Polimorfismo**: Objetos de diferentes clases pueden responder al mismo mensaje (llamada de método) de maneras específicas a su tipo.

#### Ejemplo en Java (Imperativo y POO)

Veamos cómo sumar los números pares de una lista. Este código describe cada paso y modifica una variable `sumaPares` en cada iteración.

```java
import java.util.List;

public class SumadorImperativo {
    public static void main(String[] args) {
        List<Integer> numeros = List.of(1, 2, 3, 4, 5, 6);
        int sumaPares = 0; // 1. Se inicializa una variable de estado

        for (int numero : numeros) { // 2. Se itera sobre la colección
            if (numero % 2 == 0) {
                sumaPares += numero; // 3. Se modifica el estado en cada paso
            }
        }
        // El resultado final depende de todas las mutaciones anteriores
        System.out.println("La suma de los pares es: " + sumaPares); // Salida: 12
    }
}
```
Aquí, el control del flujo y la gestión del estado son manuales y explícitos, se debe escribrir cada paso detalladamente.

## El Enfoque Declarativo: Describiendo el Resultado

La programación declarativa se centra en describir **qué** se quiere lograr, sin detallar los pasos para conseguirlo. La lógica del "cómo" se abstrae. Siguiendo la analogía, sería como pedirle a un chef "un plato de pasta con salsa de tomate", sin especificarle cómo cortar los tomates o hervir la pasta.

### Programación Funcional (FP)

La Programación Funcional es el principal paradigma declarativo que estudiaremos. Trata la computación como la evaluación de funciones matemáticas y se fundamenta en varios principios clave para evitar la complejidad del estado mutable. Estos principios los estudiaremos en detalle más adelante.

#### Ejemplo en Java (Funcional)

Lenguajes como Java, aunque principalmente orientados a objetos, han incorporado características funcionales. Veamos cómo se resolvería el mismo problema de sumar los pares utilizando la API de Streams de Java, que permite un estilo más declarativo.

```java
import java.util.List;

public class SumadorFuncional {
    public static void main(String[] args) {
        List<Integer> numeros = List.of(1, 2, 3, 4, 5, 6);

        int sumaPares = numeros.stream()  // 1. Convierte la lista en un stream de datos
                               .filter(n -> n % 2 == 0) // 2. Describe que queremos solo los pares
                               .mapToInt(Integer::intValue) // 3. Convierte a un stream de enteros primitivos
                               .sum(); // 4. Describe que queremos la suma

        System.out.println("La suma de los pares es: " + sumaPares); // Salida: 12
    }
}
```
Este código es declarativo: no decimos "crea un acumulador, itera, comprueba, suma...". Simplemente declaramos una secuencia de transformaciones sobre los datos: `filtrar` y luego `sumar`. El "cómo" se hace (la iteración, etc.) queda abstraído por la API de Streams.

## Comparación de Enfoques

| Característica | Programación Imperativa / POO | Programación Funcional |
| :--- | :--- | :--- |
| **Enfoque Principal** | Describe **cómo** hacer las cosas. | Describe **qué** se quiere lograr. |
| **Estado** | El estado es mutable y compartido. | El estado es inmutable y se evita. |
| **Flujo de Datos** | El control de flujo es explícito (bucles, condicionales). | El flujo de datos es a través de funciones que se componen. |
| **Conceptos Clave** | Objetos, métodos, herencia, estado mutable. | Funciones puras, inmutabilidad, composición. |
| **Principal Desafío** | Gestionar la complejidad del estado y los efectos secundarios. | Pensar en transformaciones de datos en lugar de pasos secuenciales. |

## Conclusión

Aunque muchos lenguajes modernos son **multi-paradigma** (permiten escribir código en diferentes estilos), suelen tener un paradigma dominante que influye en su diseño y ecosistema. Java y C# tienen su raíz en la POO, mientras que lenguajes como Elixir y Haskell fueron diseñados desde cero para ser funcionales.

---

## Para la próxima clase

Investigar cuáles son los principios fundamentales de la programación funcional, tales como funciones puras, inmutabilidad, y composición de funciones. Además, explorar ejemplos de código en lenguajes funcionales como Elixir para entender cómo se aplican estos principios en la práctica.