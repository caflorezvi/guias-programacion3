```
Universidad del Quindío
Programa de Ingeniería de Sistemas y Computación
Programación III - OTP (Open Telecom Platform)
Docente: Carlos Andrés Florez V.
```

# Introducción a OTP

Antes de entrar en detalles sobre OTP, es importante entender el concepto de **Agentes** en Elixir, ya que son una forma sencilla de manejar el estado compartido y mutable en aplicaciones concurrentes.

# Agent

El módulo `Agent` en Elixir proporciona una forma sencilla de crear y manejar procesos que mantienen un estado compartido. Los agentes son útiles cuando se necesita un proceso que almacene y gestione un estado mutable de manera concurrente. El módulo `Agent` ofrece una interfaz simple para crear, actualizar y leer el estado del agente. Entre las funciones más comunes del módulo `Agent` se encuentran:

- `Agent.start_link/2`: Inicia un nuevo agente con un estado inicial.
- `Agent.get/2`: Obtiene el estado actual del agente.
- `Agent.update/2`: Actualiza el estado del agente utilizando una función.
- `Agent.get_and_update/2`: Obtiene y actualiza el estado del agente en una sola operación.
- `Agent.stop/1`: Detiene el agente.

En el proyecto que hicimos previamente (Gimnasio), podemos usar un `Agent` para mantener el estado del gimnasio y su mapa de miembros. Para esto, podemos escribir lo siguiente:

```elixir
defmodule Gimnasio do

  use Agent # Importar el módulo Agent

  def start_link do
    # Iniciar el agente con un mapa vacío como estado inicial
    Agent.start_link(fn -> %{} end, name: __MODULE__)
  end

  defp agregar_socio(cedula, socio) do
    # Agregar un nuevo socio al mapa, actualizando el estado del agente
    Agent.update(__MODULE__, fn socios -> Map.put(socios, cedula, socio) end)
  end

  defp obtener_socio(cedula) do
    # Obtener un socio del mapa por su cédula
    Agent.get(__MODULE__, fn socios -> Map.get(socios, cedula) end)
  end

  defp eliminar_socio(cedula) do
    # Eliminar un socio del mapa por su cédula
    Agent.update(__MODULE__, fn socios -> Map.delete(socios, cedula) end)
  end

  defp listar_socios do
    # Listar todos los socios en el mapa
    Agent.get(__MODULE__, fn socios -> socios end)
  end

  defp inscribir_clase(cedula, clase) do
    # Se actualiza el estado del agente para inscribir una clase a un socio
    Agent.update(__MODULE__, fn socios ->
      case Map.get(socios, cedula) do
        nil -> socios  # Si el socio no existe, no hacer nada
        socio ->
          actualizado = %{socio | clases: [clase | socio.clases]}
          Map.put(socios, cedula, actualizado)
      end
    end)
  end

  def main do
    start_link() # Iniciar el agente (es importante hacerlo antes de usarlo)

    agregar_socio("123", %Socio{nombre: "Juan", edad: 30, clases: []})
    agregar_socio("456", %Socio{nombre: "Ana", edad: 25, clases: []})

    IO.inspect(obtener_socio("123"))
    IO.inspect(listar_socios())

    inscribir_clase("123", "Yoga")
    IO.inspect(obtener_socio("123"))

    eliminar_socio("456")
    IO.inspect(listar_socios())
  end
  
end

Gimnasio.main()
```

Dado que el `Agent` maneja su propio proceso, no es necesario preocuparse por la concurrencia al acceder o modificar el estado del gimnasio. El `Agent` se encarga de sincronizar el acceso al estado interno, lo que facilita la implementación de aplicaciones concurrentes. Además, **no es necesario pasar el mapa de socios** entre funciones, ya que el `Agent` mantiene el estado internamente. 

Elixir facilita el manejo del estado compartido y mutable mediante el uso de agentes, lo que permite construir aplicaciones concurrentes de manera más sencilla y segura.

Para más información sobre el módulo `Agent`, puedes consultar la [documentación oficial](https://hexdocs.pm/elixir/1.12/Agent.html).

# OTP (Open Telecom Platform)

En elixir, OTP (Open Telecom Platform) es un conjunto de bibliotecas y herramientas que facilitan la construcción de aplicaciones concurrentes, distribuidas y tolerantes a fallos. OTP proporciona una serie de comportamientos (behaviours) predefinidos que ayudan a estructurar el código y manejar tareas comunes en sistemas concurrentes. 

Algunos de los componentes clave de OTP incluyen:

- **GenServer**: Un comportamiento que facilita la creación de servidores genéricos. Permite manejar llamadas síncronas y asíncronas, mantener estado y gestionar la concurrencia de manera sencilla.
- **Supervisor**: Un comportamiento que supervisa otros procesos (como GenServers) y los reinicia automáticamente en caso de fallos. Esto ayuda a construir sistemas tolerantes a fallos.
- **Arbol de Supervisión**: Una estructura jerárquica de supervisores que permite organizar y gestionar múltiples procesos y supervisores de manera eficiente.

## GenServer

GenServer (Generic Server) es un comportamiento en OTP que facilita la creación de servidores genéricos. Proporciona una interfaz para manejar llamadas síncronas y asíncronas, mantener estado y gestionar la concurrencia.

### Ejemplo de uso

A continuación se muestra un ejemplo básico de cómo implementar un GenServer en Elixir:

```elixir
defmodule MiGenServer do
  use GenServer

  # Callback para iniciar el GenServer
  def start_link(initial_state) do
    # Registrar el GenServer con un nombre. Similar a Agent ya que maneja su propio proceso y estado
    GenServer.start_link(__MODULE__, initial_state, name: __MODULE__) 
  end

  # Callback para manejar la inicialización
  def init(initial_state) do
    {:ok, initial_state}
  end

  # Callback para manejar llamadas síncronas
  def handle_call(:get_state, _from, state) do
    {:reply, state, state}
  end

  # Callback para manejar mensajes asíncronos
  def handle_cast({:set_state, new_state}, _old_state) do
    {:noreply, new_state}
  end
end
```

En este ejemplo, `MiGenServer` es un GenServer simple que mantiene un estado interno. Proporciona una llamada síncrona para obtener el estado y una llamada asíncrona para establecer un nuevo estado.

La diferencia entre `handle_call` y `handle_cast` es que el primero es para llamadas síncronas (el cliente espera una respuesta), mientras que el segundo es para mensajes asíncronos (el cliente no espera una respuesta).

Para más información sobre GenServer, puedes consultar la [documentación oficial](https://hexdocs.pm/elixir/1.12/GenServer.html).

### Diferencias entre Agent y GenServer

La diferencia principal entre `Agent` y `GenServer` es que `GenServer` ofrece una mayor flexibilidad y control sobre el manejo de mensajes y el ciclo de vida del proceso. Mientras que `Agent` está diseñado para casos simples de manejo de estado, `GenServer` es más adecuado para aplicaciones más complejas que requieren lógica personalizada para manejar diferentes tipos de mensajes y estados.

--

## Ejemplo 1

