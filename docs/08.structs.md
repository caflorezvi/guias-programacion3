```
Universidad del Quindío
Programa de Ingeniería de Sistemas y Computación
Programación III - Structs
Docente: Carlos Andrés Florez V.
```

# Structs

Los **structs** en Elixir son una forma de crear **estructuras de datos tipadas** con un conjunto fijo de campos. A diferencia de los mapas genéricos, los structs:

1. **Tienen un esquema definido**: Especifican exactamente qué campos pueden existir
2. **Están asociados a un módulo**: Cada struct pertenece a un módulo específico
3. **Proporcionan valores por defecto**: Se pueden definir valores iniciales para los campos
4. **Son mapas especializados**: Internamente son mapas con metadatos adicionales
5. **Mejoran la legibilidad**: Hacen el código más autodocumentado y mantenible

Los structs son ideales para representar **entidades del dominio** como usuarios, productos, pedidos, etc.

---

## Definición de Structs

Para definir un struct, se utiliza la palabra clave `defstruct` dentro de un módulo y se especifican los campos que tendrá. Los campos se pueden definir de tres formas principales:

### Forma 1: Con valores por defecto

```elixir
defmodule Usuario do
  defstruct nombre: "", edad: 0, email: nil, activo: true
end

# Crear instancia
usuario = %Usuario{}
# => %Usuario{nombre: "", edad: 0, email: nil, activo: true}

usuario = %Usuario{nombre: "Juan", edad: 30}
# => %Usuario{nombre: "Juan", edad: 30, email: nil, activo: true}
```

### Forma 2: Sin valores por defecto (keyword list)

```elixir
defmodule Producto do
  defstruct [:codigo, :nombre, :precio]
end

# Todos los campos son nil por defecto
producto = %Producto{}
# => %Producto{codigo: nil, nombre: nil, precio: nil}

producto = %Producto{codigo: "P001", nombre: "Laptop", precio: 1200}
# => %Producto{codigo: "P001", nombre: "Laptop", precio: 1200}
```

### Forma 3: Mixta

```elixir
defmodule Pedido do
  defstruct [:id, :cliente, total: 0, estado: :pendiente, items: []]
end

pedido = %Pedido{id: 1, cliente: "Maria"}
# => %Pedido{id: 1, cliente: "Maria", total: 0, estado: :pendiente, items: []}
```

---

## Acceso y actualización

Para acceder y actualizar campos en un struct, se utilizan las mismas técnicas que con los mapas, a continuación se muestran ejemplos prácticos.

### Acceso a campos

```elixir
usuario = %Usuario{nombre: "Ana", edad: 25}

# Acceso con punto (recomendado)
usuario.nombre  # => "Ana"
usuario.edad    # => 25

# Acceso con corchetes (funciona porque es un mapa)
usuario[:nombre]  # => "Ana"

# Pattern matching
%Usuario{nombre: nombre, edad: edad} = usuario
IO.puts("#{nombre} tiene #{edad} años")
```

### Actualización de campos

Los structs son **inmutables**, por lo que actualizar crea una nueva instancia:

```elixir
usuario = %Usuario{nombre: "Carlos", edad: 28}

# Sintaxis de actualización
usuario_actualizado = %{usuario | edad: 29, activo: false}
# => %Usuario{nombre: "Carlos", edad: 29, ...}

# El original no cambia
usuario.edad  # => 28
usuario_actualizado.edad  # => 29
```

---

## Campos obligatorios con `@enforce_keys`

Al definir un struct, se puede usar la directiva `@enforce_keys` para especificar campos que **deben ser proporcionados** al crear una instancia del struct. Si no se proporcionan, se lanzará un error en tiempo de ejecución.

```elixir
defmodule Persona do
  @enforce_keys [:nombre, :cedula]
  defstruct [:nombre, :cedula, edad: 0, ciudad: ""]
end

# Correcto
%Persona{nombre: "Laura", cedula: "123456"}

# Error: falta campo obligatorio
%Persona{edad: 30}
# ** (ArgumentError) the following keys must also be given when building struct Persona: [:nombre, :cedula]
```

Esto es útil para garantizar que ciertos datos críticos siempre estén presentes, como por ejemplo un identificador o un nombre.

---

## Diferencias entre Structs y Mapas

Aunque los structs se basan en mapas, hay algunas diferencias clave entre ellos:

1. **Definición fija**: Los structs tienen un conjunto fijo de claves y valores, mientras que los mapas pueden tener cualquier número de claves y valores.
2. **Depende del módulo**: Los structs están asociados a un módulo específico, lo que significa que cada struct pertenece a un módulo diferente. Los mapas no tienen esta restricción.
3. **Rendimiento**: Los structs son más eficientes en términos de rendimiento que los mapas, ya que tienen una estructura fija y no requieren la misma cantidad de memoria para almacenar datos.
4. **No es enumerable**: Los structs no son enumerables por defecto, lo que significa que no se pueden recorrer con funciones como `Enum.map/2` o `Enum.each/2`. Sin embargo, se puede convertir un struct en un mapa utilizando la función `Map.from_struct/1`.
5. **Validación de claves**: Al crear un struct, se validan las claves proporcionadas. Si se intenta crear un struct con una clave que no está definida en la estructura, se generará un error. En contraste, los mapas permiten cualquier clave sin validación.
   
### Comparación práctica

En el siguiente ejemplo se muestra cómo los mapas permiten agregar cualquier clave, mientras que los structs no:

```elixir
# Mapa: flexible pero sin garantías
mapa = %{nombre: "Juan", edad: 30}
mapa = Map.put(mapa, :telefono, "123")  # Permite agregar cualquier clave

# Struct: rígido pero predecible
struct = %Usuario{nombre: "Juan", edad: 30}
struct = %{struct | telefono: "123"}  # Error: clave no definida
```

---

## ¿Por qué los Structs no son Enumerables?

Los structs **no implementan el protocolo Enumerable** por defecto para:

1. **Separar comportamiento de datos**: Un struct es una entidad, no solo una colección
2. **Evitar confusión**: No queremos iterar sobre campos internos accidentalmente
3. **Encapsulación**: Los campos pueden ser privados conceptualmente

---

## Funciones en el módulo del Struct

Es una buena práctica definir funciones relacionadas en el mismo módulo:

```elixir
defmodule Usuario do
  @enforce_keys [:nombre, :email]
  defstruct [:nombre, :email, edad: 0, activo: true, creado_en: nil]

  # Constructor con validaciones
  def nuevo(nombre, email, edad) do
    if valido?(email) do
      {:ok, %__MODULE__{
        nombre: nombre,
        email: email,
        edad: edad,
        creado_en: DateTime.utc_now()
      }}
    else
      {:error, :email_invalido}
    end
  end

  # Funciones de utilidad
  def mayor_de_edad?(%__MODULE__{edad: edad}), do: edad >= 18
  
  def activar(%__MODULE__{} = usuario) do
    %{usuario | activo: true}
  end

  def desactivar(%__MODULE__{} = usuario) do
    %{usuario | activo: false}
  end

  # Validación privada
  defp valido?(email) do
    String.contains?(email, "@")
  end
end

# Uso
case Usuario.nuevo("Juan", "juan@example.com", 25) do
  {:ok, usuario} ->
    IO.puts("Usuario creado")
    Usuario.mayor_de_edad?(usuario)  # => true
  {:error, razon} ->
    IO.puts("Error: #{razon}")
end
```

**Nota:** `__MODULE__` es una macro que se expande al nombre del módulo actual.

---

## Ejercicio 1: Sistema de Gimnasio

Un gimnasio quiere llevar el control de sus socios y las clases a las que asisten. Cada socio tiene una cédula, un nombre, una edad y una lista de clases a las que está inscrito.

Se requiere implementar las siguientes funcionalidades:
- Crear un nuevo socio y agregarlo a una colección
- Actualizar la información de un socio
- Eliminar un socio
- Inscribir a un socio en una clase
- Desinscribir a un socio de una clase
- Buscar un socio por su cédula
- Listar todos los socios

### 1. Crear el struct `Socio`

Definir el struct Socio con los campos nombre, edad y clases.

```elixir
defmodule Socio do
  @enforce_keys [:nombre, :edad] # Campos obligatorios
  defstruct [:nombre, :edad, clases: []]
end
```

### 2. Agregar funcionalidades al módulo `Socio`

Para manejar las operaciones relacionadas con los socios, se pueden agregar funciones al módulo `Socio`.

```elixir
defmodule Socio do
  @enforce_keys [:nombre, :edad]
  defstruct [:nombre, :edad, clases: []]

  # Constructor con validación
  def nuevo(nombre, edad) when edad > 0 and edad < 100 do
    {:ok, %__MODULE__{nombre: nombre, edad: edad}}
  end

  def nuevo(_nombre, _edad), do: {:error, :edad_invalida}

  # Funciones de utilidad
  def inscribir_clase(%__MODULE__{clases: clases} = socio, clase) do
    if clase in clases do
      {:error, :ya_inscrito}
    else
      {:ok, %{socio | clases: [clase | clases]}}
    end
  end

  def desinscribir_clase(%__MODULE__{clases: clases} = socio, clase) do
    %{socio | clases: List.delete(clases, clase)}
  end

  def tiene_clase?(%__MODULE__{clases: clases}, clase) do
    clase in clases
  end

end
```

### 2. Crear el módulo `Gimnasio`

El módulo `Gimnasio` va a tener la lógica para manejar los socios. En este caso, se usará un mapa para almacenarlos, ya que permite un acceso rápido a los datos mediante una clave única (la cédula del socio).

Se inicializa un mapa vacío para almacenar los socios.

```elixir
defmodule Gimnasio do
  def main do
    socios = %{}
  end
end
```

### 3. Implementar las funcionalidades

Dentro del módulo `Gimnasio`, implementar las funciones para manejar los socios y sus inscripciones en clases.

Se debe considerar que como el **mapa es inmutable**, cada función debe retornar una nueva versión del mapa con los cambios aplicados.

#### Agregar un nuevo socio

Se reciben los datos del socio y se crea un nuevo struct `Socio` usando la función `Socio.nuevo/2`. Luego, se verifica si la cédula ya existe en el mapa antes de agregarlo. Si pasa las validaciones, se agrega al mapa y se retorna la nueva versión.

```elixir
def agregar_socio(socios, cedula, nombre, edad) do
  case Socio.nuevo(nombre, edad) do
    {:ok, nuevo_socio} ->
      if Map.has_key?(socios, cedula) do
        {:error, :cedula_duplicada}
      else
        {:ok, Map.put(socios, cedula, nuevo_socio)}
      end
    {:error, razon} ->
      {:error, razon}
  end
end
```

Observe que cada función retorna una tupla `{:ok, nuevo_mapa}` o `{:error, razon}` para manejar errores de manera clara.

#### Obtener socio por cédula

El acceso a un socio se hace mediante su cédula, que es la clave en el mapa. Esta operación es muy eficiente (mucho más que buscar en una lista).

```elixir
def obtener_socio(socios, cedula) do
  case Map.get(socios, cedula) do
    nil -> {:error, :no_encontrado}
    socio -> {:ok, socio}
  end
end
```

#### Actualizar la información de un socio

Se busca el socio por su cédula, si existe, se actualizan los campos necesarios y se vuelve a insertar en el mapa.

```elixir
def actualizar_socio(socios, cedula, nombre, edad) do
  case Map.get(socios, cedula) do
    nil ->
      {:error, :no_encontrado}
    socio ->
      actualizado = %{socio | nombre: nombre, edad: edad}
      {:ok, Map.put(socios, cedula, actualizado)}
  end
end
```

La función `Map.put/3` reemplaza el valor existente si la clave ya está en el mapa, por lo que no es necesario eliminar el socio antes de actualizarlo.

#### Eliminar un socio

Se hace uso de `Map.delete/2` para eliminar el socio del mapa. Si la cédula no existe, el mapa permanece sin cambios. Se retorna el nuevo mapa sin el socio eliminado.

```elixir
def eliminar_socio(socios, cedula) do
  if Map.has_key?(socios, cedula) do
    {:ok, Map.delete(socios, cedula)}
  else
    {:error, :no_encontrado}
  end
end
```

#### Inscribir a un socio en una clase

Se busca el socio por su cédula, si existe, se agrega la clase a la lista de clases del socio haciendo uso de la función `Socio.inscribir_clase/2`. Se retorna el nuevo mapa con el socio actualizado.

```elixir
def inscribir_clase(socios, cedula, clase) do
  case Map.get(socios, cedula) do
    nil ->
      {:error, :no_encontrado}
    socio ->
      case Socio.inscribir_clase(socio, clase) do
        {:ok, actualizado} ->
          {:ok, Map.put(socios, cedula, actualizado)}
        {:error, razon} ->
          {:error, razon}
      end
  end
end
```

#### Desinscribir a un socio de una clase

Al igual que en la inscripción, se busca el socio y se elimina la clase de su lista usando `Socio.desinscribir_clase/2`. Luego se retorna el mapa actualizado.

```elixir
def desinscribir_clase(socios, cedula, clase) do
  case Map.get(socios, cedula) do
    nil ->
      {:error, :no_encontrado}
    socio ->
      actualizado = Socio.desinscribir_clase(socio, clase)
      {:ok, Map.put(socios, cedula, actualizado)}
  end
end
```

#### Listar todos los socios

Accedemos a todos los valores del mapa, que son los structs de tipo `Socio`.

```elixir
def listar_socios(socios) do
  Map.values(socios)
end
```

#### Otras funcionalidades adicionales

Adicionalmente, se pueden implementar funciones para obtener estadísticas o filtrar socios por clase.

```elixir
# Devuelve la lista de socios que pertenece a una clase específica
def socios_en_clase(socios, clase) do
  socios
  |> Map.values()
  |> Enum.filter(&Socio.tiene_clase?(&1, clase))
end

# Devuelve estadísticas básicas del gimnasio
def estadisticas(socios) do
  %{
    total: map_size(socios),
    edad_promedio: calcular_edad_promedio(socios)
  }
end

defp calcular_edad_promedio(socios) when map_size(socios) == 0, do: 0
defp calcular_edad_promedio(socios) do
  edades = socios |> Map.values() |> Enum.map(& &1.edad)
  Enum.sum(edades) / length(edades)
end
```

### 4. Probar las funcionalidades

Para probar las funcionalidades, se invocan las funciones dentro de la función `main` del módulo `Gimnasio`. Se prueba con datos de ejemplo y se imprime el resultado en la consola.

```elixir
defmodule Gimnasio do
  def main do
    # Inicializar
    {:ok, socios} = {:ok, %{}}

    # Agregar socios
    {:ok, socios} = agregar_socio(socios, "123", "Juan Pérez", 30)
    {:ok, socios} = agregar_socio(socios, "456", "María García", 25)
    {:ok, socios} = agregar_socio(socios, "789", "Carlos López", 35)

    # Intentar agregar duplicado
    case agregar_socio(socios, "123", "Otro Juan", 28) do
      {:error, :cedula_duplicada} ->
        IO.puts("No se puede agregar: cédula duplicada")
      {:ok, _} ->
        IO.puts("Socio agregado")
    end

    # Inscribir en clases
    {:ok, socios} = inscribir_clase(socios, "123", "Yoga")
    {:ok, socios} = inscribir_clase(socios, "123", "Pilates")
    {:ok, socios} = inscribir_clase(socios, "456", "Spinning")

    # Intentar inscribir duplicado
    case inscribir_clase(socios, "123", "Yoga") do
      {:error, :ya_inscrito} ->
        IO.puts("Ya está inscrito en esa clase")
      {:ok, _} ->
        IO.puts("Inscrito en clase")
    end

    # Mostrar información
    case obtener_socio(socios, "123") do
      {:ok, socio} ->
        IO.puts("\n=== Socio 123 ===")
        IO.inspect(socio)
      {:error, _} ->
        IO.puts("Socio no encontrado")
    end

    # Estadísticas
    stats = estadisticas(socios)
    IO.puts("\n=== Estadísticas ===")
    IO.inspect(stats)

    # Listar socios en una clase
    IO.puts("\n=== Socios en Yoga ===")
    socios_yoga = socios_en_clase(socios, "Yoga")
    Enum.each(socios_yoga, &IO.puts(&1.nombre))

    # Actualizar socio
    {:ok, socios} = actualizar_socio(socios, "123", "Juan Pérez Gómez", 31)

    # Eliminar socio
    {:ok, socios} = eliminar_socio(socios, "789")

    # Mostrar todos
    IO.inspect(listar_socios(socios))
  end
end

Gimnasio.main()
```

---

## Ejercicio 2: Sistema de Inventario

Implementar un struct `Producto` con los campos `codigo`, `nombre`, `precio` y `cantidad`. Luego, crear un módulo `Inventario` que permita agregar, actualizar, eliminar y listar productos en un inventario. Utilizar un mapa para almacenar los productos, donde la clave sea el código del producto. 

Tenga en cuenta los siguientes requisitos:
- Validar que no se pueda agregar un producto con código repetido.
- Validar que el precio y la cantidad no sean negativos.
- Validar que el código del producto tenga una longitud máxima de 5 caracteres.
- Validar que la cantidad del producto sea un número entero.

Además, se requiere calcular los siguientes reportes:
- Listado de productos cuyo nombre contenga al menos dos vocales. Devoler una tupla con su código y nombre por cada producto que cumpla con esta condición.
- Listado de productos cuyo nombre comience y termine con la misma letra.
- Listado de productos por debajo de un precio dado.
- Retornar los tres productos más caros del inventario.
- Retornar una cadena de caracteres con el nombre y precio de cada producto, separados por comas de aquellos productos cuyo precio esté entre dos valores dados.
- Crear un reporte de productos agrupados por rango de precio, ej.: Menores de \$50000, Entre \$50000 y \$100000, Mayores de \$100000.

---

## Ejercicio 3: Sistema de Biblioteca

Diseñe e implemente un sistema de biblioteca con los siguientes structs:

### Requisitos

1. **Struct `Libro`**:
   - Campos: ISBN, título, autor, año, género, disponible
   - ISBN debe ser obligatorio y único
   - Funciones: prestar, devolver, es_clasico? (más de 50 años)

2. **Struct `Usuario`**:
   - Campos: id, nombre, email, libros_prestados
   - Email debe ser obligatorio
   - Funciones: puede_prestar? (máximo 3 libros), agregar_prestamo, quitar_prestamo

3. **Struct `Prestamo`**:
   - Campos: id, libro_isbn, usuario_id, fecha_prestamo, fecha_devolucion
   - Calcular días de retraso

4. **Módulo `Biblioteca`**:
   - Gestionar catálogo de libros
   - Gestionar usuarios
   - Registrar préstamos
   - Generar reportes:
     * Libros más prestados
     * Usuarios con préstamos vencidos
     * Libros por género
     * Disponibilidad de libros

### Estructura sugerida

```elixir
defmodule Libro do
  @enforce_keys [:isbn, :titulo, :autor]
  defstruct [:isbn, :titulo, :autor, :año, :genero, disponible: true]
  
  # Implementar funciones...
end

defmodule Usuario do
  @enforce_keys [:id, :nombre, :email]
  defstruct [:id, :nombre, :email, libros_prestados: []]
  
  # Implementar funciones...
end

defmodule Prestamo do
  @enforce_keys [:id, :libro_isbn, :usuario_id, :fecha_prestamo]
  defstruct [:id, :libro_isbn, :usuario_id, :fecha_prestamo, fecha_devolucion: nil]
  
  # Implementar funciones...
end

defmodule Biblioteca do
  # Estado: %{libros: %{}, usuarios: %{}, prestamos: %{}}
  
  # Implementar funciones...
end
```

---

## Buenas prácticas con Structs

Cuando se trabaja con structs en Elixir, es importante seguir ciertas buenas prácticas para mantener el código limpio, eficiente y fácil de mantener. Aquí hay algunas recomendaciones clave:

### 1. Usar @enforce_keys para campos críticos

Se recomienda utilizar `@enforce_keys` para asegurar que ciertos campos esenciales estén siempre presentes al crear una instancia del struct.

```elixir
defmodule Pedido do
  @enforce_keys [:id, :cliente_id]
  defstruct [:id, :cliente_id, items: [], total: 0]
end
```

### 2. Definir constructores con validación

Es útil definir funciones constructoras que incluyan validaciones para garantizar que los datos sean correctos al crear una instancia del struct.

```elixir
defmodule Email do
  defstruct [:direccion]

  def nuevo(direccion) do
    if valido?(direccion) do
      {:ok, %__MODULE__{direccion: direccion}}
    else
      {:error, :email_invalido}
    end
  end

  defp valido?(email), do: String.contains?(email, "@")
end
```

### 3. Agrupar funciones relacionadas en el módulo

Si el struct representa una entidad del dominio, agrupa las funciones relacionadas dentro del mismo módulo para mejorar la cohesión.

```elixir
defmodule Usuario do
  defstruct [:nombre, :email, activo: true]

  # Constructores
  def nuevo(nombre, email), do: %__MODULE__{nombre: nombre, email: email}

  # Consultas
  def activo?(%__MODULE__{activo: activo}), do: activo

  # Comandos
  def activar(%__MODULE__{} = usuario), do: %{usuario | activo: true}
  def desactivar(%__MODULE__{} = usuario), do: %{usuario | activo: false}
end
```

### 4. Usar pattern matching en funciones

Para manejar diferentes casos basados en los valores de los campos del struct, utiliza pattern matching en las definiciones de funciones.

```elixir
def procesar(%Usuario{activo: true} = usuario), do: {:ok, usuario}
def procesar(%Usuario{activo: false}), do: {:error, :usuario_inactivo}
```

### 5. Documentar el struct

Como siempre, documentar adecuadamente el código es crucial. Recuerde usar `@moduledoc` y `@typedoc` para describir el propósito del struct y sus campos.

```elixir
defmodule Producto do
  @moduledoc """
  Representa un producto en el inventario.
  """

  @enforce_keys [:codigo, :nombre]
  defstruct [:codigo, :nombre, precio: 0.0, cantidad: 0]

  @typedoc """
  Tipo que representa un producto.

  ## Campos
  - `:codigo` - Identificador único del producto (máximo 5 caracteres)
  - `:nombre` - Nombre del producto
  - `:precio` - Precio unitario (debe ser positivo)
  - `:cantidad` - Cantidad en inventario (debe ser entero positivo)
  """
  @type t :: %__MODULE__{
    codigo: String.t(),
    nombre: String.t(),
    precio: float(),
    cantidad: integer()
  }

  @doc """
  Crea un nuevo producto con validaciones.

  ## Ejemplos

      iex> Producto.nuevo("P001", "Laptop", 1200.0, 10)
      {:ok, %Producto{codigo: "P001", nombre: "Laptop", precio: 1200.0, cantidad: 10}}

      iex> Producto.nuevo("CODIGO_LARGO", "Producto", 100.0, 5)
      {:error, :codigo_muy_largo}
  """
  @spec nuevo(String.t(), String.t(), float(), integer()) :: {:ok, t()} | {:error, atom()}
  def nuevo(codigo, nombre, precio, cantidad) do
    # Implementación...
  end
end
```

---

## Para la próxima clase

1. **Protocolos**:
   - Qué son y cómo funcionan los protocolos en Elixir
   - Implementar protocolos personalizados

2. **Streams**:
   - Módulo Stream
   - Evaluación perezosa (lazy evaluation)
   - Diferencias con Enum
   - Casos de uso prácticos

3. **Preparación**:
   - Completar ejercicio 2 (Inventario)
   - Completar ejercicio 3 (Biblioteca)