```
Universidad del Quind铆o
Programa de Ingenier铆a de Sistemas y Computaci贸n
Programaci贸n III - Structs
Docente: Carlos Andr茅s Florez V.
```

# Structs

Los **structs** en Elixir son una forma de crear **estructuras de datos tipadas** con un conjunto fijo de campos. A diferencia de los mapas gen茅ricos, los structs:

1. **Tienen un esquema definido**: Especifican exactamente qu茅 campos pueden contener
2. **Est谩n asociados a un m贸dulo**: Cada struct pertenece a un m贸dulo espec铆fico
3. **Proporcionan valores por defecto**: Se pueden definir valores iniciales para los campos
4. **Son mapas especializados**: Internamente son mapas con metadatos adicionales
5. **Mejoran la legibilidad**: Hacen el c贸digo m谩s autodocumentado y mantenible

Los structs son ideales para representar **entidades del dominio** como usuarios, productos, pedidos, etc.

## Definici贸n de Structs

Para definir un struct, se utiliza la palabra clave `defstruct` dentro de un m贸dulo y se especifican los campos que tendr谩. Los campos se pueden definir de tres formas principales:

### Forma 1: Con valores por defecto

```elixir
defmodule Usuario do
  defstruct nombre: "", edad: 0, email: nil, activo: true
end

# Crear una instancia del struct
usuario = %Usuario{}
# => %Usuario{nombre: "", edad: 0, email: nil, activo: true}

usuario = %Usuario{nombre: "Juan", edad: 30}
# => %Usuario{nombre: "Juan", edad: 30, email: nil, activo: true}
```

### Forma 2: Sin valores por defecto (keyword list)

```elixir
defmodule Producto do
  defstruct [:codigo, :nombre, :precio]
end

# Todos los campos son nil por defecto
producto = %Producto{}
# => %Producto{codigo: nil, nombre: nil, precio: nil}

producto = %Producto{codigo: "P001", nombre: "Laptop", precio: 1200}
# => %Producto{codigo: "P001", nombre: "Laptop", precio: 1200}
```

### Forma 3: Mixta

```elixir
defmodule Pedido do
  defstruct [:id, :cliente, total: 0, estado: :pendiente, items: []]
end

pedido = %Pedido{id: 1, cliente: "Maria"}
# => %Pedido{id: 1, cliente: "Maria", total: 0, estado: :pendiente, items: []}
```

Cualquiera de estas formas es v谩lida y se puede elegir seg煤n las necesidades del dise帽o de lo que se est谩 modelando.

## Acceso y actualizaci贸n

Para acceder y actualizar campos en un struct, se utilizan las mismas t茅cnicas que con los mapas, a continuaci贸n se muestran ejemplos pr谩cticos.

### Acceso a campos

```elixir
usuario = %Usuario{nombre: "Ana", edad: 25}

# Acceso con punto (recomendado)
usuario.nombre  # => "Ana"
usuario.edad    # => 25

# Acceso con corchetes (funciona porque es un mapa)
usuario[:nombre]  # => "Ana"

# Pattern matching
%Usuario{nombre: nombre, edad: edad} = usuario
IO.puts("#{nombre} tiene #{edad} a帽os")
```

### Actualizaci贸n de campos

Los structs son **inmutables**, por lo que actualizar crea una nueva instancia:

```elixir
usuario = %Usuario{nombre: "Carlos", edad: 28}

# Sintaxis de actualizaci贸n
usuario_actualizado = %{usuario | edad: 29, activo: false}
# => %Usuario{nombre: "Carlos", edad: 29, ...}

# El original no cambia
usuario.edad  # => 28
usuario_actualizado.edad  # => 29
```

## Campos obligatorios con `@enforce_keys`

Al definir un struct, se puede usar la directiva `@enforce_keys` para especificar campos que **deben ser proporcionados** al crear una instancia del struct. Si no se proporcionan, se lanzar谩 un error en tiempo de ejecuci贸n.

```elixir
defmodule Persona do
  @enforce_keys [:nombre, :cedula]
  defstruct [:nombre, :cedula, edad: 0, ciudad: ""]
end

# Correcto
%Persona{nombre: "Laura", cedula: "123456"}

# Error: falta campo obligatorio
%Persona{edad: 30}
# ** (ArgumentError) the following keys must also be given when building struct Persona: [:nombre, :cedula]
```

Esto es 煤til para garantizar que ciertos datos cr铆ticos siempre est茅n presentes, como por ejemplo un identificador o un nombre.

---

## Diferencias entre Structs y Mapas

Aunque los structs se basan en mapas, hay algunas diferencias clave entre ellos:

1. **Definici贸n fija**: Los structs tienen un conjunto fijo de claves y valores, mientras que los mapas pueden tener cualquier n煤mero de claves y valores.
2. **Depende del m贸dulo**: Los structs est谩n asociados a un m贸dulo espec铆fico, lo que significa que cada struct pertenece a un m贸dulo diferente. Los mapas no tienen esta restricci贸n.
3. **Rendimiento**: Los structs son m谩s eficientes en t茅rminos de rendimiento que los mapas, ya que tienen una estructura fija y no requieren la misma cantidad de memoria para almacenar datos.
4. **No es enumerable**: Los structs no son enumerables por defecto, lo que significa que no se pueden recorrer con funciones como `Enum.map/2` o `Enum.each/2`. Sin embargo, se puede convertir un struct en un mapa utilizando la funci贸n `Map.from_struct/1`.
5. **Validaci贸n de claves**: Al crear un struct, se validan las claves proporcionadas. Si se intenta crear un struct con una clave que no est谩 definida en la estructura, se generar谩 un error. En contraste, los mapas permiten cualquier clave sin validaci贸n.
   
### Comparaci贸n pr谩ctica

En el siguiente ejemplo se muestra c贸mo los mapas permiten agregar cualquier clave, mientras que los structs no:

```elixir
# Mapa: flexible pero sin garant铆as
mapa = %{nombre: "Juan", edad: 30}
mapa = Map.put(mapa, :telefono, "123")  # Permite agregar cualquier clave

# Struct: r铆gido pero predecible
struct = %Usuario{nombre: "Juan", edad: 30}
struct = %{struct | telefono: "123"}  # Error: clave no definida
```

---

## Funciones en el m贸dulo del Struct

Es una buena pr谩ctica definir funciones relacionadas en el mismo m贸dulo:

```elixir
defmodule Usuario do
  @enforce_keys [:nombre, :email]
  defstruct [:nombre, :email, edad: 0, activo: true, creado_en: nil]

  # Constructor con validaciones
  def nuevo(nombre, email, edad) do
    if valido?(email) do
      {:ok, %__MODULE__{
        nombre: nombre,
        email: email,
        edad: edad,
        creado_en: DateTime.utc_now()
      }}
    else
      {:error, :email_invalido}
    end
  end

  # Funciones de utilidad
  def mayor_de_edad?(%__MODULE__{edad: edad}), do: edad >= 18
  
  def activar(%__MODULE__{} = usuario) do
    %{usuario | activo: true}
  end

  def desactivar(%__MODULE__{} = usuario) do
    %{usuario | activo: false}
  end

  # Validaci贸n privada
  defp valido?(email) do
    String.contains?(email, "@")
  end
end

# Uso
case Usuario.nuevo("Juan", "juan@example.com", 25) do
  {:ok, usuario} ->
    IO.puts("Usuario creado")
    Usuario.mayor_de_edad?(usuario)  # => true
  {:error, razon} ->
    IO.puts("Error: #{razon}")
end
```

>**锔 Nota:** En algunas funciones se usa `%__MODULE__{}` para referirse al struct definido en el mismo m贸dulo, lo que mejora la legibilidad y evita errores si el nombre del m贸dulo cambia. Pero tambi茅n se puede usar el nombre expl铆cito del m贸dulo, como `%Usuario{}`.

---

## Ejemplo 1: Sistema de Gimnasio

Un gimnasio quiere llevar el control de sus socios y las clases a las que asisten. Cada socio tiene una c茅dula, un nombre, una edad y una lista de clases a las que est谩 inscrito.

Se requiere implementar las siguientes funcionalidades:
- Crear un nuevo socio y agregarlo a una colecci贸n
- Actualizar la informaci贸n de un socio
- Eliminar un socio
- Inscribir a un socio en una clase
- Desinscribir a un socio de una clase
- Buscar un socio por su c茅dula
- Listar todos los socios

### 1. Crear el struct `Socio`

Definir el struct Socio con los campos nombre, edad y clases.

```elixir
defmodule Socio do
  @enforce_keys [:nombre, :edad] # Campos obligatorios
  defstruct [:nombre, :edad, clases: []]
end
```

### 2. Agregar funcionalidades al m贸dulo `Socio`

Para manejar las operaciones relacionadas con los socios, se pueden agregar funciones al m贸dulo `Socio`.

```elixir
defmodule Socio do
  @enforce_keys [:nombre, :edad]
  defstruct [:nombre, :edad, clases: []]

  # Constructor con validaci贸n
  def nuevo(nombre, edad) when edad > 0 and edad < 100 do
    {:ok, %__MODULE__{nombre: nombre, edad: edad}}
  end

  def nuevo(_nombre, _edad), do: {:error, :edad_invalida}

  # Funciones de utilidad
  def inscribir_clase(%__MODULE__{clases: clases} = socio, clase) do
    if clase in clases do
      {:error, :ya_inscrito}
    else
      {:ok, %{socio | clases: [clase | clases]}}
    end
  end

  def desinscribir_clase(%__MODULE__{clases: clases} = socio, clase) do
    %{socio | clases: List.delete(clases, clase)}
  end

  def tiene_clase?(%__MODULE__{clases: clases}, clase) do
    clase in clases
  end

end
```

> ** Nota:** Las funciones dentro de la estructura deben manejar la l贸gica relacionada con el struct para mantener el c贸digo organizado y modular.

### 2. Crear el m贸dulo `Gimnasio`

El m贸dulo `Gimnasio` va a tener la l贸gica para manejar los socios. En este caso, se usar谩 un mapa para almacenarlos, ya que permite un acceso r谩pido a los datos mediante una clave 煤nica (la c茅dula del socio).

Se inicializa un mapa vac铆o para almacenar los socios.

```elixir
defmodule Gimnasio do
  def main do
    socios = %{}
  end
end
```

### 3. Implementar las funcionalidades

Dentro del m贸dulo `Gimnasio`, implementar las funciones para manejar los socios y sus inscripciones en clases.

Se debe considerar que como el **mapa es inmutable**, cada funci贸n debe retornar una nueva versi贸n del mapa con los cambios aplicados.

#### Agregar un nuevo socio

Una versi贸n simple de la funci贸n para agregar un socio ser铆a:

```elixir
def agregar_socio(socios, cedula, nombre, edad) do
  nuevo_socio = %Socio{nombre: nombre, edad: edad, clases: []}
  Map.put(socios, cedula, nuevo_socio)
end
```

Pero, vamos a usar la funci贸n `Socio.nuevo/2` para crear el struct y validar los datos. Luego, se verifica si la c茅dula ya existe en el mapa antes de agregarlo. Si pasa las validaciones, se agrega al mapa y se retorna la nueva versi贸n.

```elixir
def agregar_socio(socios, cedula, nombre, edad) do
  case Socio.nuevo(nombre, edad) do
    {:ok, nuevo_socio} ->
      if Map.has_key?(socios, cedula) do
        {:error, :cedula_duplicada}
      else
        {:ok, Map.put(socios, cedula, nuevo_socio)}
      end
    {:error, razon} ->
      {:error, razon}
  end
end
```

Observe que cada funci贸n retorna una tupla `{:ok, nuevo_mapa}` o `{:error, razon}` para manejar errores de manera clara.

#### Obtener socio por c茅dula

El acceso a un socio se hace mediante su c茅dula, que es la clave en el mapa. Esta operaci贸n es muy eficiente (mucho m谩s que buscar en una lista).

```elixir
def obtener_socio(socios, cedula) do
  case Map.get(socios, cedula) do
    nil -> {:error, :no_encontrado}
    socio -> {:ok, socio}
  end
end
```

#### Actualizar la informaci贸n de un socio

Se busca el socio por su c茅dula, si existe, se actualizan los campos necesarios y se vuelve a insertar en el mapa.

```elixir
def actualizar_socio(socios, cedula, nombre, edad) do
  case Map.get(socios, cedula) do
    nil ->
      {:error, :no_encontrado}
    socio ->
      actualizado = %{socio | nombre: nombre, edad: edad}
      {:ok, Map.put(socios, cedula, actualizado)}
  end
end
```

La funci贸n `Map.put/3` reemplaza el valor existente si la clave ya est谩 en el mapa, por lo que no es necesario eliminar el socio antes de actualizarlo.

#### Eliminar un socio

Se hace uso de `Map.delete/2` para eliminar el socio del mapa. Si la c茅dula no existe, el mapa permanece sin cambios. Se retorna el nuevo mapa sin el socio eliminado.

```elixir
def eliminar_socio(socios, cedula) do
  if Map.has_key?(socios, cedula) do
    {:ok, Map.delete(socios, cedula)}
  else
    {:error, :no_encontrado}
  end
end
```

#### Inscribir a un socio en una clase

Se busca el socio por su c茅dula, si existe, se agrega la clase a la lista de clases del socio haciendo uso de la funci贸n `Socio.inscribir_clase/2`. Se retorna el nuevo mapa con el socio actualizado.

```elixir
def inscribir_clase(socios, cedula, clase) do
  case Map.get(socios, cedula) do
    nil ->
      {:error, :no_encontrado}
    socio ->
      case Socio.inscribir_clase(socio, clase) do
        {:ok, actualizado} ->
          {:ok, Map.put(socios, cedula, actualizado)}
        {:error, razon} ->
          {:error, razon}
      end
  end
end
```

#### Desinscribir a un socio de una clase

Al igual que en la inscripci贸n, se busca el socio y se elimina la clase de su lista usando `Socio.desinscribir_clase/2`. Luego se retorna el mapa actualizado.

```elixir
def desinscribir_clase(socios, cedula, clase) do
  case Map.get(socios, cedula) do
    nil ->
      {:error, :no_encontrado}
    socio ->
      actualizado = Socio.desinscribir_clase(socio, clase)
      {:ok, Map.put(socios, cedula, actualizado)}
  end
end
```

#### Listar todos los socios

Accedemos a todos los valores del mapa, que son los structs de tipo `Socio`.

```elixir
def listar_socios(socios) do
  Map.values(socios)
end
```

#### Otras funcionalidades adicionales (opcional)

Adicionalmente, se pueden implementar funciones para obtener estad铆sticas o filtrar socios por clase.

```elixir
# Devuelve la lista de socios que pertenece a una clase espec铆fica
def socios_en_clase(socios, clase) do
  socios
  |> Map.values()
  |> Enum.filter(&Socio.tiene_clase?(&1, clase))
end

# Devuelve estad铆sticas b谩sicas del gimnasio
def estadisticas(socios) do
  %{
    total: map_size(socios),
    edad_promedio: calcular_edad_promedio(socios)
  }
end

defp calcular_edad_promedio(socios) when map_size(socios) == 0, do: 0
defp calcular_edad_promedio(socios) do
  edades = socios |> Map.values() |> Enum.map(& &1.edad)
  Enum.sum(edades) / length(edades)
end
```

### 4. Probar las funcionalidades

Para probar las funcionalidades, se invocan las funciones dentro de la funci贸n `main` del m贸dulo `Gimnasio`. Se prueba con datos de ejemplo y se imprime el resultado en la consola.

```elixir
defmodule Gimnasio do
  def main do
    # Inicializar
    {:ok, socios} = {:ok, %{}}

    # Agregar socios
    {:ok, socios} = agregar_socio(socios, "123", "Juan P茅rez", 30)
    {:ok, socios} = agregar_socio(socios, "456", "Mar铆a Garc铆a", 25)
    {:ok, socios} = agregar_socio(socios, "789", "Carlos L贸pez", 35)

    # Intentar agregar duplicado
    case agregar_socio(socios, "123", "Otro Juan", 28) do
      {:error, :cedula_duplicada} ->
        IO.puts("No se puede agregar: c茅dula duplicada")
      {:ok, _} ->
        IO.puts("Socio agregado")
    end

    # Inscribir en clases
    {:ok, socios} = inscribir_clase(socios, "123", "Yoga")
    {:ok, socios} = inscribir_clase(socios, "123", "Pilates")
    {:ok, socios} = inscribir_clase(socios, "456", "Spinning")

    # Intentar inscribir duplicado
    case inscribir_clase(socios, "123", "Yoga") do
      {:error, :ya_inscrito} ->
        IO.puts("Ya est谩 inscrito en esa clase")
      {:ok, _} ->
        IO.puts("Inscrito en clase")
    end

    # Mostrar informaci贸n
    case obtener_socio(socios, "123") do
      {:ok, socio} ->
        IO.puts("\n=== Socio 123 ===")
        IO.inspect(socio)
      {:error, _} ->
        IO.puts("Socio no encontrado")
    end

    # Estad铆sticas
    stats = estadisticas(socios)
    IO.puts("\n=== Estad铆sticas ===")
    IO.inspect(stats)

    # Listar socios en una clase
    IO.puts("\n=== Socios en Yoga ===")
    socios_yoga = socios_en_clase(socios, "Yoga")
    Enum.each(socios_yoga, &IO.puts(&1.nombre))

    # Actualizar socio
    {:ok, socios} = actualizar_socio(socios, "123", "Juan P茅rez G贸mez", 31)

    # Eliminar socio
    {:ok, socios} = eliminar_socio(socios, "789")

    # Mostrar todos
    IO.inspect(listar_socios(socios))
  end
end
```

Dado que cada funci贸n retorna un nuevo mapa con los cambios aplicados, es importante reasignar el resultado a la variable `socios` en cada paso. Como estamos usando el mismo nombre de variable, cada vez que se reasigna, el valor previo se pierde, pero en este caso es lo que queremos, ya que cada funci贸n retorna el mapa actualizado.

### 5. Ejecutar el programa

Por 煤ltimo, se ejecuta el programa para ver los resultados de las operaciones realizadas. Recuerde llamar a la funci贸n `main` del m贸dulo `Gimnasio` al final del archivo.

```elixir
Gimnasio.main()
```

> ** Nota:** Aunque el ejemplo no lo hace, ser铆a ideal que la interacci贸n con el usuario se realice a trav茅s de la terminal para facilitar el uso del sistema y evitar escribir los valores directamente en el c贸digo.

---

## Ejercicio 2: Sistema de Inventario de Productos

Implementar un struct `Producto` con los campos `codigo`, `nombre`, `precio` y `cantidad`. Luego, crear un m贸dulo `Inventario` que permita agregar, actualizar, eliminar y listar productos en un inventario. Utilizar un mapa para almacenar los productos, donde la clave sea el c贸digo del producto. 

Tenga en cuenta los siguientes requisitos:
- Validar que no se pueda agregar un producto con c贸digo repetido.
- Validar que el precio y la cantidad no sean negativos.
- Validar que el c贸digo del producto tenga una longitud m谩xima de 5 caracteres.
- Validar que la cantidad del producto sea un n煤mero entero.

Adem谩s, se requiere calcular los siguientes reportes:
- Listado de productos cuyo nombre contenga al menos dos vocales. Devoler una tupla con su c贸digo y nombre por cada producto que cumpla con esta condici贸n.
- Listado de productos cuyo nombre comience y termine con la misma letra.
- Listado de productos por debajo de un precio dado.
- Retornar los tres productos m谩s caros del inventario.
- Retornar una cadena de caracteres con el nombre y precio de cada producto, separados por comas de aquellos productos cuyo precio est茅 entre dos valores dados.
- Crear un reporte de productos agrupados por rango de precio, ej.: Menores de \$50000, Entre \$50000 y \$100000, Mayores de \$100000.

---

## Ejercicio 3: Sistema de Biblioteca

Dise帽e e implemente un sistema de biblioteca con los siguientes structs:

### Requisitos

1. **Struct `Libro`**:
   - Campos: ISBN, t铆tulo, autor, a帽o, g茅nero, disponible
   - ISBN debe ser obligatorio y 煤nico
   - Funciones: prestar, devolver, es_clasico? (m谩s de 50 a帽os)

2. **Struct `Usuario`**:
   - Campos: id, nombre, email, libros_prestados
   - Email debe ser obligatorio
   - Funciones: puede_prestar? (m谩ximo 3 libros), agregar_prestamo, quitar_prestamo

3. **Struct `Prestamo`**:
   - Campos: id, libro_isbn, usuario_id, fecha_prestamo, fecha_devolucion
   - Calcular d铆as de retraso

4. **M贸dulo `Biblioteca`**:
   - Gestionar cat谩logo de libros
   - Gestionar usuarios
   - Registrar pr茅stamos
   - Generar reportes:
     * Libros m谩s prestados
     * Usuarios con pr茅stamos vencidos
     * Libros por g茅nero
     * Disponibilidad de libros

### Estructura sugerida

```elixir
defmodule Libro do
  @enforce_keys [:isbn, :titulo, :autor]
  defstruct [:isbn, :titulo, :autor, :a帽o, :genero, disponible: true]
  
  # Implementar funciones...
end

defmodule Usuario do
  @enforce_keys [:id, :nombre, :email]
  defstruct [:id, :nombre, :email, libros_prestados: []]
  
  # Implementar funciones...
end

defmodule Prestamo do
  @enforce_keys [:id, :libro_isbn, :usuario_id, :fecha_prestamo]
  defstruct [:id, :libro_isbn, :usuario_id, :fecha_prestamo, fecha_devolucion: nil]
  
  # Implementar funciones...
end

defmodule Biblioteca do
  # Estado: %{libros: %{}, usuarios: %{}, prestamos: %{}}
  
  # Implementar funciones...
end
```

----

## Para la pr贸xima clase

- Investigar qu茅 son los protocolos en Elixir y c贸mo se utilizan. 
- Qu茅 es un `Agent` en elixir y para qu茅 sirve.
- Lea acerca del m贸dulo `Stream` en la documentaci贸n oficial de Elixir.

