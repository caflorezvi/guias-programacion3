```
Universidad del Quindío
Programa de Ingeniería de Sistemas y Computación
Programación III - Structs
Docente: Carlos Andrés Florez V.
```

# Structs

Los structs en elixir son una forma de agrupar datos relacionados en una sola entidad. A diferencia de los mapas, los structs tienen un conjunto fijo de claves y valores, lo que los hace más predecibles y seguros. Los structs se definen utilizando la macro `defstruct` y se pueden utilizar para representar entidades del mundo real, como usuarios, productos, etc.

## Ejemplo de uso

Se crea un struct para representar un usuario de la siguiente manera:

```elixir
defmodule Usuario do
  defstruct nombre: "", edad: 0
end

usuario = %Usuario{nombre: "Juan", edad: 30}
IO.inspect(usuario)
```

Otra forma de crear un struct es usando una **keyword list**, la ventaja es que se puede omitir los valores por defecto:

```elixir
defmodule Usuario do
  defstruct [:nombre, :edad]
end

usuario = %Usuario{nombre: "Juan", edad: 30}
IO.inspect(usuario)
```

## Diferencia entre Structs y Mapas

Aunque los structs se basan en mapas, hay algunas diferencias clave entre ellos:

1. **Definición fija**: Los structs tienen un conjunto fijo de claves y valores, mientras que los mapas pueden tener cualquier número de claves y valores.
2. **Depende del módulo**: Los structs están asociados a un módulo específico, lo que significa que cada struct pertenece a un módulo diferente. Los mapas no tienen esta restricción.
3. **Rendimiento**: Los structs son más eficientes en términos de rendimiento que los mapas, ya que tienen una estructura fija y no requieren la misma cantidad de memoria para almacenar datos.  
4. **No es enumerable:** Los structs no son enumerables por defecto, lo que significa que no se pueden recorrer con funciones como `Enum.map/2` o `Enum.each/2`. Sin embargo, se puede convertir un struct en un mapa utilizando la función `Map.from_struct/1`.
5. **Validación de claves:** Al crear un struct, se validan las claves proporcionadas. Si se intenta crear un struct con una clave que no está definida en la estructura, se generará un error. En contraste, los mapas permiten cualquier clave sin validación.

---

## Ejercicio 1

Un gimnasio quiere llevar el control de sus socios y las clases a las que asisten. Cada socio tiene un nombre, una edad y una lista de clases a las que está inscrito. 

Se require implementar las siguientes funcionalidades: 
- Crear un nuevo socio y agregarlo a una colección.
- Actualizar la información de un socio.
- Eliminar un socio.
- Inscribir a un socio en una clase.
- Buscar un socio por su cédula.
- Listar todos los socios.

### 1. Crear el struct `Socio`

Definir el struct `Socio` con los campos `nombre`, `edad` y `clases`.

```elixir
defmodule Socio do
  defstruct nombre: "", edad: 0, clases: []
end
```

### 2. Crear el módulo `Gimnasio`

El módulo `Gimnasio` va a tener la lógica para manejar los socios. En este caso, se usará un mapa para almacenarlos, ya que permite un acceso rápido a los datos mediante una clave única (la cédula del socio).

Se inicializa un mapa vacío para almacenar los socios.

```elixir
defmodule Gimnasio do
  def main do
    socios = %{}
  end
end
```

### 3. Implementar las funcionalidades

Dentro del módulo `Gimnasio`, implementar las funciones para manejar los socios y sus inscripciones en clases.
   
Se debe considerar que como el **mapa es inmutable**, cada función debe retornar una nueva versión del mapa con los cambios aplicados.

#### Agregar un nuevo socio

Se reciben los datos del socio y se crea un nuevo struct `Socio`. Luego, se agrega al mapa usando la cédula como clave. Se retorna el nuevo mapa con el socio agregado.

```elixir
def agregar_socio(socios, cedula, nombre, edad) do
  nuevo_socio = %Socio{nombre: nombre, edad: edad, clases: []}
  Map.put(socios, cedula, nuevo_socio)
end
```

#### Obtener un socio por su cédula

El acceso a un socio se hace mediante su cédula, que es la clave en el mapa. Esta operación es muy eficiente (mucho más que buscar en una lista).

```elixir
def obtener_socio(socios, cedula) do
  Map.get(socios, cedula)
end
```

#### Actualizar la información de un socio

Se busca el socio por su cédula, si existe, se actualizan los campos necesarios y se vuelve a insertar en el mapa.

```elixir
def actualizar_socio(socios, cedula, nombre, edad) do
  case Map.get(socios, cedula) do
    nil ->
      {:error, "Socio no encontrado"}
    socio ->
      actualizado = %Socio{socio | nombre: nombre, edad: edad}
      Map.put(socios, cedula, actualizado)
  end
end
```

La función `Map.put/3` reemplaza el valor existente si la clave ya está en el mapa, por lo que no es necesario eliminar el socio antes de actualizarlo.

#### Eliminar un socio

Se hace uso de `Map.delete/2` para eliminar el socio del mapa. Si la cédula no existe, el mapa permanece sin cambios. Se retorna el nuevo mapa sin el socio eliminado.

```elixir
def eliminar_socio(socios, cedula) do
  Map.delete(socios, cedula)
end
```

#### Inscribir a un socio en una clase

Se busca el socio por su cédula, si existe, se agrega la clase a la lista de clases del socio y se vuelve a insertar en el mapa.

```elixir
def inscribir_clase(socios, cedula, clase) do
  case Map.get(socios, cedula) do
    nil ->
      {:error, "Socio no encontrado"}
    socio ->
      actualizado = %Socio{socio | clases: [clase | socio.clases]}
      Map.put(socios, cedula, actualizado)
  end
end
```

#### Listar todos los socios

Accedemos a todos los valores del mapa, que son los structs de tipo `Socio`.

```elixir
def listar_socios(socios) do
  Map.values(socios)
end
```

### 4. Probar las funcionalidades

Para probar las funcionalidades, se invocan las funciones dentro de la función `main` del módulo `Gimnasio`. Se prueba con datos de ejemplo y se imprime el resultado en la consola.

```elixir
defmodule Gimnasio do
  def main do
    # Inicializar el mapa de socios
    socios = %{} 

    # Agregar socios, pasando el mapa previo y recibiendo el nuevo mapa
    socios = agregar_socio(socios, "123", "Juan", 30)
    socios = agregar_socio(socios, "456", "Maria", 25)

    IO.inspect(obtener_socio(socios, "123"))

    # Actualizar socio, pasando el mapa previo y recibiendo el nuevo mapa
    socios = actualizar_socio(socios, "123", "Juan Perez", 31)
    IO.inspect(obtener_socio(socios, "123"))

    # Inscribir en clases, pasando el mapa previo y recibiendo el nuevo mapa
    socios = inscribir_clase(socios, "123", "Yoga")
    socios = inscribir_clase(socios, "123", "Pilates")
    IO.inspect(obtener_socio(socios, "123"))

    IO.inspect(listar_socios(socios))

    # Eliminar socio, pasando el mapa previo y recibiendo el nuevo mapa
    socios = eliminar_socio(socios, "456")
    IO.inspect(listar_socios(socios))
  end
end
```

Dado que cada función retorna un nuevo mapa con los cambios aplicados, es importante reasignar el resultado a la variable `socios` en cada paso. Como estamos usando el mismo nombre de variable, cada vez que se reasigna, el valor previo se pierde, pero en este caso es lo que queremos, ya que cada función retorna el mapa actualizado.

### 5. Ejecutar el programa

Por último, se ejecuta el programa para ver los resultados de las operaciones realizadas. Recuerde llamar a la función `main` del módulo `Gimnasio` al final del archivo.

```elixir
Gimnasio.main()
```

---

## Ejercicio 2

Implementar un struct `Producto` con los campos `codigo`, `nombre`, `precio` y `cantidad`. Luego, crear un módulo `Inventario` que permita agregar, actualizar, eliminar y listar productos en un inventario. Utilizar un mapa para almacenar los productos, donde la clave sea el código del producto. 

Tenga en cuenta los siguientes requisitos:
- Validar que no se pueda agregar un producto con código repetido.
- Validar que el precio y la cantidad no sean negativos.
- Validar que el código del producto tenga una longitud máxima de 5 caracteres.
- Validar que la cantidad del producto sea un número entero.

Además, se requiere calcular los siguientes reportes:
- Listado de productos cuyo nombre contenga al menos dos vocales. Devoler una tupla con su código y nombre por cada producto que cumpla con esta condición.
- Listado de productos cuyo nombre comience y termine con la misma letra.
- Listado de productos por debajo de un precio dado.
- Retornar los tres productos más caros del inventario.
- Retornar una cadena de caracteres con el nombre y precio de cada producto, separados por comas de aquellos productos cuyo precio esté entre dos valores dados.
- Crear un reporte de productos agrupados por rango de precio, ej.: Menores de \$50000, Entre \$50000 y \$100000, Mayores de \$100000.

----

## Para la próxima clase

- Investigar qué son los protocolos en Elixir y cómo se utilizan. 
- Para qué sirve `@enforce_keys` en la definición de un struct.
- Qué es un `Agent` en elixir y para qué sirve.
- Lea acerca del módulo `File` en la documentación oficial de Elixir.

