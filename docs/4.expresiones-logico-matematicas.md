```
Universidad del Quindío
Programa de Ingeniería de Sistemas y Computación
Programación III - Expresiones lógico-matemáticas
```

# Expresiones lógico-matemáticas

Para comprender las expresiones lógico-matemáticas en Elixir, es importante familiarizarse con su sintaxis y características principales. A continuación, se presentan algunos de los conceptos fundamentales que se abordarán en esta guía:

- Operadores lógicos y matemáticos.
- Funciones lambda.
- Evaluación de expresiones.
- Patrones de coincidencia (pattern matching).
- Ejemplos prácticos.

## Ejercicio 1

La oﬁcina de tesorería de una empresa requiere de un programa que le permita calcular el salario a pagar a un empleado. Al empleado le pagan de acuerdo con el número de horas que haya laborado durante el periodo a razón de un valor específico cada hora. Calcule el salario de un empleado, pidiendo su nombre, horas trabajadas y valor por hora.

#### Versión 1

```elixir
defmodule Salario do

  def main do
    nombre = leer_nombre()
    horas_trabajadas = leer_horas_trabajadas()
    valor_por_hora = leer_valor_por_hora()
    salario = calcular_salario(horas_trabajadas, valor_por_hora)
    imprimir_mensaje(nombre, salario)
  end

  defp leer_nombre do
    IO.gets("Ingrese el nombre del empleado: ") 
    |> String.trim()
  end

  defp leer_horas_trabajadas do
    IO.gets("Ingrese las horas trabajadas: ") 
    |> String.trim() 
    |> String.to_integer()
  end

  defp leer_valor_por_hora do
    IO.gets("Ingrese el valor por hora: ") 
    |> String.trim() 
    |> String.to_float()
  end

  defp calcular_salario(horas_trabajadas, valor_por_hora) do
    horas_trabajadas * valor_por_hora
  end

  defp imprimir_mensaje(nombre, salario) do
    IO.puts("El salario de #{nombre} es: $#{salario}")
  end
end

Salario.main()
```

Así como vimos en la clase anterior, el módulo `String` de elixir tiene una serie de funciones útiles para manipular cadenas de texto. Algunas de estas funciones incluyen:

- `String.trim/1`: Elimina los espacios en blanco al inicio y al final de una cadena.
- `String.to_integer/1`: Convierte una cadena en un número entero.
- `String.to_float/1`: Convierte una cadena en un número de punto flotante.
- `String.length/1`: Devuelve la longitud de una cadena.
- `String.at/2`: Devuelve el carácter en la posición especificada de una cadena.

> **⚠️ Importante:** Las funciones `String.to_integer/1` y `String.to_float/1` pueden fallar si la cadena no representa un número válido. Para manejar estos casos, se recomienda utilizar estas funciones dentro de un bloque `try`/`rescue`. Otra alternativa es usar el módulo `Integer` y `Float` para realizar los casteos.

#### Versión 2

En este caso, se utilizarán las funciones `Integer.parse/1` y `Float.parse/1` para manejar la entrada del usuario de manera más robusta.

```elixir
defmodule Salario do

  def main do
    nombre = leer_nombre()
    horas_trabajadas = leer_horas_trabajadas()
    valor_por_hora = leer_valor_por_hora()
    salario = calcular_salario(horas_trabajadas, valor_por_hora)
    imprimir_mensaje(nombre, salario)
  end

  defp leer_nombre do
    IO.gets("Ingrese el nombre del empleado: ") 
    |> String.trim()
  end

  defp leer_horas_trabajadas do
    horas = IO.gets("Ingrese las horas trabajadas: ") 
    |> String.trim() 
    |> Integer.parse()

    case horas do
      {numero, _} -> numero
      :error -> 
        imprimir_error("Horas trabajadas inválidas. Se utilizará 0 como valor predeterminado.")
        0
    end
  end

  defp leer_valor_por_hora do
    valor = IO.gets("Ingrese el valor por hora: ") 
    |> String.trim() 
    |> Float.parse()

    case valor do
      {numero, _} -> numero
      :error -> 
        imprimir_error("Valor por hora inválido. Se utilizará 0 como valor predeterminado.")
        0.0
    end
  end

  defp calcular_salario(horas_trabajadas, valor_por_hora) do
    horas_trabajadas * valor_por_hora
  end

  defp imprimir_mensaje(nombre, salario) do
    IO.puts("El salario de #{nombre} es: $#{salario}")
  end

  defp imprimir_error(mensaje) do
    IO.puts(:standard_error, mensaje)
  end

end

Salario.main()
```

En este caso se opta por usar `Integer.parse/1` y `Float.parse/1` ya que estas funciones permiten capturar errores de conversión y proporcionar valores predeterminados en caso de entradas inválidas. Esto es **mucho más seguro** que usar `String.to_integer/1` y `String.to_float/1`, ya que estas últimas pueden lanzar excepciones si la entrada no es válida.

Tanto `Integer.parse/1` como `Float.parse/1` retornan un `tupla` con el número parseado y el resto de la cadena. Si no se puede parsear, retornan el átomo `:error`. 

> **⚠️ Importante:** Investigar qué es un átomo en Elixir. Puede leer la documentación oficial [desde este link](https://hexdocs.pm/elixir/1.12/Atom.html).

Además, en el código se está utilizando un `case`, el cual permite manejar diferentes patrones de manera concisa y legible. En este caso, se utiliza para evaluar el resultado de las funciones de parseo y proporcionar valores predeterminados en caso de errores. Este es un ejemplo de **pattern matching**.

Por último, se agrega la función `imprimir_error/1` para manejar los mensajes de error de manera centralizada. Observe que `IO.puts/2` se utiliza para imprimir mensajes de error en la salida estándar de error (esto se hace por buenas prácticas).

Para más información puede leer acerca del [Módulo String](https://hexdocs.pm/elixir/String.html), [Módulo Integer](https://hexdocs.pm/elixir/Integer.html) y [Módulo Float](https://hexdocs.pm/elixir/Float.html). Adicionalmente, se recomienda visitar [este link](https://hexdocs.pm/elixir/case-cond-and-if.html#case) para profundizar en el uso de la estructura `case`.

#### Versión 3

Para mejorar la organización del código, se puede **crear un módulo separado** para manejar las operaciones de entrada/salida. Esto permite que el módulo `Salario` se enfoque en la lógica de negocio y delegue las operaciones de entrada/salida a otro módulo.

```elixir
defmodule Salario do

  def main do
    nombre = "Ingrese el nombre del empleado: "
    |> Util.leer(:string)

    horas_trabajadas = "Ingrese las horas trabajadas: "
    |> Util.leer(:integer)

    valor_por_hora = "Ingrese el valor por hora: "
    |> Util.leer(:float)

    salario = calcular_salario(horas_trabajadas, valor_por_hora)

    generar_mensaje(nombre, salario)
    |> Util.imprimir_mensaje
  end

  defp calcular_salario(horas_trabajadas, valor_por_hora) do
    horas_trabajadas * valor_por_hora
  end

  defp generar_mensaje(nombre, salario) do
    "El salario de #{nombre} es: $#{salario}"
  end

end

defmodule Util do

  def leer(mensaje, :string) do
    IO.gets(mensaje)
    |> String.trim()
  end

  def leer(mensaje, :integer) do
    horas = IO.gets(mensaje)
    |> String.trim()
    |> Integer.parse()

    case horas do
      {numero, _} -> numero
      :error ->
        imprimir_error("Error. Se utilizará 0 como valor predeterminado.")
        0
    end
  end

  def leer(mensaje, :float) do
    valor = IO.gets(mensaje)
    |> String.trim()
    |> Float.parse()

    case valor do
      {numero, _} -> numero
      :error ->
        imprimir_error("Error. Se utilizará 0 como valor predeterminado.")
        0
    end
  end

  def imprimir_error(mensaje) do
    IO.puts(:standard_error, mensaje)
  end

  def imprimir_mensaje(mensaje) do
    IO.puts(mensaje)
  end

end

Salario.main()

```

Ahora las funciones del módulo `Util` gestionan la entrada y salida de datos y pueden reutilizarse fácilmente desde otros módulos. Además, se emplea un **átomo** para indicar el tipo de dato a leer (`:string`, `:integer` o `:float`), y Elixir invoca automáticamente la función de parseo correspondiente gracias al **pattern matching**.

#### Versión 4

Finalmente, se modificará el módulo `Util` para que las funciones de lectura de enteros y flotantes utilicen una función auxiliar encargada de la captura del valor, su parseo y el manejo de errores. Con este cambio se **reduce la duplicación de código** y se mejora la legibilidad.

```elixir
defmodule Util do

  def leer(mensaje, :string) do
    IO.gets(mensaje)
    |> String.trim()
  end

  def leer(mensaje, :integer) do
    leer_con_parser(mensaje, &Integer.parse/1)
  end

  def leer(mensaje, :float) do
    leer_con_parser(mensaje, &Float.parse/1)
  end

  defp leer_con_parser(mensaje, parser) do
    valor = IO.gets(mensaje)
    |> String.trim()
    |> parser.()

    case valor do
      {numero, _} -> numero
      :error ->
        imprimir_error("Error. Se utilizará 0 como valor predeterminado.")
        0
    end
  end

  def imprimir_error(mensaje) do
    IO.puts(:standard_error, mensaje)
  end

  def imprimir_mensaje(mensaje) do
    IO.puts(mensaje)
  end

end
```

> ⚠️ **Importante:** No es necesario modificar el módulo `Salario` ya que ahora las funciones de lectura están centralizadas en el módulo `Util`.

La función `leer_con_parser/2` recibe el mensaje y la función de parseo. Para el caso de `leer(mensaje, :integer)` la función de parseo es `Integer.parse/1`. Para ejecutarla se utiliza el operador `.` así: `parser.(valor)`. Otra alternativa es pasar la función así:

```elixir
def leer(mensaje, :integer) do
  leer_con_parser(mensaje, fn valor -> Integer.parse(valor) end)
end
```

Ambas hacen lo mismo, ya depende de cómo prefiera el desarrollador escribir el código. Estas funciones se conocen como **funciones anónimas o lambdas**.

---

## Ejercicio 2

Un estudiante necesita un programa que le ayude a calcular la nota definitiva de dos cursos, cada curso tiene 4 notas parciales. El primer curso calcula la nota definitiva como un promedio aritmético, mientras que el segundo curso lo hace mediante un promedio ponderado usando los porcentajes de 15%, 30%, 35% y 20% respectivamente. Además, el programa debe indicar si el estudiante aprueba o no.

#### Versión 1

```elixir
defmodule Notas do

  def main do
    n1 = Util.leer("Ingrese la nota 1: ", :float)
    n2 = Util.leer("Ingrese la nota 2: ", :float)
    n3 = Util.leer("Ingrese la nota 3: ", :float)
    n4 = Util.leer("Ingrese la nota 4: ", :float)

    nota_final = calcular_nota_curso_1(n1, n2, n3, n4)
    es_aprobado = aprobado?(nota_final)

    generar_mensaje(es_aprobado, nota_final)
    |> Util.imprimir_mensaje

  end

  defp calcular_nota_curso_1(n1, n2, n3, n4), do: (n1 + n2 + n3 + n4) / 4

  defp calcular_nota_curso_2(n1, n2, n3, n4), do: n1 * 0.15 + n2 * 0.30 + n3 * 0.35 + n4 * 0.20

  defp aprobado?(nota), do: nota >= 3.0

  defp generar_mensaje(es_aprobado, nota) do
    if es_aprobado do
      "El estudiante aprobó el curso con una nota de #{nota}."
    else
      "El estudiante no aprobó el curso con una nota de #{nota}."
    end
  end

end

Notas.main()
```

Como se puede ver en el código, si una función es muy simple, se puede utilizar la sintaxis de una sola línea. Además, se pueden utilizar funciones de orden superior para simplificar aún más el código. 

#### Versión 2

Para esta versión se ha usado el pattern matching para simplificar la generación de mensajes.

```elixir
defmodule Notas do

  def main do
    n1 = Util.leer("Ingrese la nota 1: ", :float)
    n2 = Util.leer("Ingrese la nota 2: ", :float)
    n3 = Util.leer("Ingrese la nota 3: ", :float)
    n4 = Util.leer("Ingrese la nota 4: ", :float)

    nota_final = calcular_nota_curso_1(n1, n2, n3, n4)
    es_aprobado = aprobado?(nota_final)

    generar_mensaje(es_aprobado, nota_final)
    |> Util.imprimir_mensaje

  end

  defp calcular_nota_curso_1(n1, n2, n3, n4), do: (n1 + n2 + n3 + n4) / 4

  defp calcular_nota_curso_2(n1, n2, n3, n4), do: n1 * 0.15 + n2 * 0.30 + n3 * 0.35 + n4 * 0.20

  defp aprobado?(nota), do: nota >= 3.0

  defp generar_mensaje(true, nota), do: "El estudiante aprobó el curso con una nota de #{nota}."
  defp generar_mensaje(false, nota), do: "El estudiante no aprobó el curso con una nota de #{nota}."

end

Notas.main()
```

Hay dos funciones `generar_mensaje/2`, la primera asume que el estudiante aprobó el curso, mientras que la segunda asume que no lo aprobó, observe que el primer patrón coincide con `true` y el segundo con `false`.

Los nombres de las funciones que retornan un `boolean` deben terminar con un signo de interrogación (`?`) por convención.

> ⚠️ **Investigación:** Investigar cómo el módulo `Util` puede utilizarse en cualquier programa que requiera operaciones de entrada y salida de datos, evitando así tener que copiar y pegar el mismo código en cada implementación.

---

## Ejercicio 3

Una empresa está haciendo una campaña para promocionar un nuevo producto. Por lo tanto, se está dando un porcentaje de descuento al valor total de la compra de los clientes, el cual varía según el monto de la compra. 

El programa debe solicitar al usuario el monto de la compra y luego aplicar el descuento correspondiente. Los rangos de descuento son los siguientes:

- Si el monto es mayor a **\$50.000** y menor o igual a **\$100.000**, el descuento es del 5%.
- Si el monto es mayor a **\$100.000** y menor o igual a **\$500.000**, el descuento es del 10%.
- Si el monto es mayor a **\$500.000**, el descuento es del 15%.

Se requiere implementar un programa que calcule el precio final después de aplicar el descuento correspondiente e imprima un mensaje con el resultado.

#### Versión 1

```elixir
defmodule Descuento do

  def main do
    precio = Util.leer("Ingrese el valor de la compra: ", :float)
    descuento = obtener_descuento(precio)
    precio_final = calcular_descuento(precio, descuento)

    generar_mensaje(precio, descuento, precio_final)
    |> Util.imprimir_mensaje
  end

  defp obtener_descuento(precio) do
    if precio <= 50000 do
      0
    else
      if precio <= 100000 do
        0.05
      else
        if precio <= 500000 do
          0.1
        else
          0.15
        end
      end
    end
  end

  defp calcular_descuento(precio, descuento), do: precio - (precio * descuento)

  defp generar_mensaje(precio, descuento, precio_final) do
    "El precio original es: #{precio}, el descuento aplicado es: #{descuento * 100}%, y el precio final es: #{precio_final}"
  end

end

Descuento.main()
```

Aunque el código funciona, se puede mejorar utilizando `cond` o `guard` para simplificar la lógica de obtención del descuento.

#### Versión 2

En esta nueva versión se modifica la función `obtener_descuento/1` para utilizar `cond`.

```elixir
defp obtener_descuento(precio) do
  cond do
    precio <= 50000 -> 0
    precio <= 100000 -> 0.05
    precio <= 500000 -> 0.1
    true -> 0.15
  end
end
```

Al usar `cond`, la función `obtener_descuento/1` se simplifica al eliminar la necesidad de múltiples cláusulas `if` que se vuelven difíciles de leer y mantener.

#### Versión 3

En esta nueva versión se modifica la función `obtener_descuento/1` para utilizar `guard`.

```elixir
defp obtener_descuento(precio) when precio > 50000 and precio <= 100000, do: 0.05
defp obtener_descuento(precio) when precio > 100000 and precio <= 500000, do: 0.1
defp obtener_descuento(precio) when precio > 500000, do: 0.15
defp obtener_descuento(_), do: 0.0
```

Al utilizar `guard`, la función `obtener_descuento/1` se divide en múltiples cláusulas, cada una de las cuales maneja un caso específico. Esto hace que el código sea más legible y fácil de mantener. El último caso maneja cualquier valor (`_`) que no cumpla con los criterios anteriores y devuelve un descuento del 0%.

Para más información puede leer acerca de [cond](https://hexdocs.pm/elixir/case-cond-and-if.html#cond) y [guard](https://hexdocs.pm/elixir/1.6.5/guards.html) en la documentación oficial de Elixir.

---

## Ejercicio 4

Se requiere un programa que simule una lotería básica, donde el usuario puede elegir un número entre 1 y 100, luego el programa debe generar un número aleatorio en el mismo rango, determinar si el usuario ganó o no y cuál fue la diferencia. Si el usuario escribe un número fuera de este rango, el programa debe informarle que su elección es inválida y terminar.

Para generar números aleatorios en Elixir, se puede utilizar el módulo `:rand` de Erlang. Para más información, puede consultar la documentación oficial [aquí](https://www.erlang.org/doc/apps/stdlib/rand.html).


```elixir
defmodule Loteria do
  @minimo 1
  @maximo 10

  def main do
    numero = Util.leer("Ingrese un número entre #{@minimo} y #{@maximo}: ", :integer)

    numero
    |> validar_y_jugar()
    |> Util.imprimir_mensaje()
  end

  defp validar_y_jugar(numero) when numero >= @minimo and numero <= @maximo do
    ejecutar_sorteo(numero)
  end

  defp validar_y_jugar(_numero), do: "Número no válido, fin del juego."

  defp ejecutar_sorteo(numero_usuario) do
    numero_ganador = :rand.uniform(@maximo)
    diferencia = abs(numero_usuario - numero_ganador)
    evaluar_resultado(diferencia)
  end

  defp evaluar_resultado(diferencia) do
    case diferencia do
      0 -> mostrar_victoria()
      _ -> mostrar_derrota(diferencia)
    end
  end

  defp mostrar_victoria(), do: "¡Felicidades, has ganado!"

  defp mostrar_derrota(diferencia), do: "Lo siento, has perdido. La diferencia fue de #{diferencia}."

end

Loteria.main()

```

En esta implementación se usan dos constantes, `@minimo` y `@maximo`, para definir el rango de números válidos. Esto facilita la modificación del rango en el futuro, si es necesario.

---

## Ejercicio 5

Se requiere un programa que calcule las operaciones aritméticas básicas a partir de dos números ingresados por el usuario. Se debe validar que en la división no se produzca una división por cero, cuando una operación se pueda hacer debe retornar un `:ok` junto a la respuesta, en caso contrario debe retornar `:error` con un mensaje apropiado.

```elixir
defmodule Calculadora do

  def main do
    numero1 = Util.leer("Ingrese el primer número: ", :integer)
    numero2 = Util.leer("Ingrese el segundo número: ", :integer)
    operacion = Util.leer("Escriba 1 para suma, 2 para resta, 3 para multiplicación, 4 para división: ", :integer)

    validar_operacion(numero1, numero2, operacion)
    |> generar_mensaje()
    |> Util.imprimir_mensaje()
  end

  def validar_operacion(numero1, numero2, operacion) when operacion in 1..4 do
    operar(numero1, numero2, operacion)
  end

  def validar_operacion(_, _, _), do: {:error, "Operación no válida."}

  defp operar(numero1, numero2, 1), do: {:ok, numero1 + numero2}
  defp operar(numero1, numero2, 2), do: {:ok, numero1 - numero2}
  defp operar(numero1, numero2, 3), do: {:ok, numero1 * numero2}
  defp operar(_numero1, 0, 4), do: {:error, "División por cero no permitida."}
  defp operar(numero1, numero2, 4), do: {:ok, numero1 / numero2}
  defp operar(_, _, _), do: {:error, "Operación no válida."}

  def generar_mensaje({:ok, resultado}) do
    "El resultado es: #{resultado}"
  end

  def generar_mensaje({:error, mensaje}) do
    "Error: #{mensaje}"
  end

end

Calculadora.main()

```

Se destaca la utilización de **tuplas** para manejar los resultados de las operaciones, lo que permite un manejo de errores más claro y conciso. Además, gracias al **pattern matching**, se puede descomponer fácilmente el resultado en varias partes y actuar en consecuencia. Lea el código e intente identificar cómo se manejan los diferentes casos.

---

## Para la próxima clase

- Investigar qué estructuras de datos ofrece Elixir y sus características principales.
- Investigar para qué sirve el operador `&` y cómo se utiliza en Elixir.
- Investigar sobre el manejo de errores en Elixir y las mejores prácticas.